---
title: Linux 输出重定向的问题
id: 2017050401
date: 2017-05-04 21:50:17
updated: 2019-04-24 21:50:17
categories: Linux 命令系列
tags: [Linux,redirect]
keywords: Linux,redirect
---


最近遇到一个好玩的事，在使用 Linux 命令执行任务【Java 程序或者 Python 程序】时，需要把输出内容日志重定向到文件中，并且保持任务后台执行，这样就可以继续执行其它的命令，不占用 SSH 工具的 session。而且，如果等不了任务的运行，直接退出 SSH 登录即可，任务会在后台继续执行，下次重新登录时可以继续查看任务的状态、分析日志的内容。这里面会涉及到输出重定向、设备文件、输出类型的概念，本文记录这个问题以及涉及的相关知识点。


<!-- more -->


# 基础概念


首先，通过一个很常见的具体的例子来说明基础概念，让读者有一个深刻印象。在 Linux 机器上面运行程序的时候，很多人都很熟练地使用类似于 `nohup run_your_program > /dev/null 2>&1 &`，一些人一看就明白了，还有一些人可能会使用，但是不太了解什么意思。当然，大多数人肯定都查过，了解过相关知识，只不过有时候不在意它，久而久之就忘记了。下面我就以这个例子为样本分析各个符号的含义。

- 起始的 `nohup` 和结尾的 `&` 是一对命令，常常放在一起使用，表示让运行的进程忽略 **SIGHUP** 信号，并进入后台运行，这样就可以保证这个进程一直运行下去，不受用户退出、系统 **SIGHUP** 信号的影响
- `run_your_program`，表示运行的程序命令，可以是 Java、Shell、Python、Go 等
- `>`，表示**重定向**，可以把输入或者输出重定向到一个地方，后面一般跟着的是文件
- `>` 重定向符号前面缺省了默认值1，完整应该是 `1>`，表示**标准输出文件**，即 `stdout`
- `/dev/null`，表示**空设备文件**，它是一个特殊的文件，表示什么都没有，它跟在重定向符号后面则表示把运行程序产生的**标准输出文件**重定向到空设备文件，即不会输出**标准输出文件**的内容
- `2>&1`，根据前面的解释，这些符号可以放在一起理解，`2`表示**标准错误文件**，即 `stderr`，`>` 仍旧是重定向，`&1` 则表示重定向的文件和1一样，即把**标准错误文件**也重定向到 `/dev/null` 中，即不会输出**标准错误文件**的内容

想必读者已经看明白了，上面的描述已经很清楚，但是有些地方我觉得还是需要再总结完善一下。

对于 `nohup` 与 `&` 的使用，还需要了解一下控制信号、后台进程相关的知识点，这样才能知其然并且知其所以然。关于控制信号的知识点，可以参考我另外一篇博文：[Linux 之 kill 命令入门实践](https://www.playpi.org/2019042101.html) ，关于后台进程的知识点，也可以参考我另外一篇博文：[Linux 让进程在后台运行的几种方法](https://www.playpi.org/2019051501.html) 。

`1`、`2` 这2个数字，是文件描述符，都是有特殊含义的，`1`是缺省值，其实还有一个 `0`。一般情况下，Linux/Unix 系统在启动进程时，会打开三个文件，由这三个文件描述符来表示，它们的具体含义如下：

- 标准输入文件，`stdin`，文件描述符为0，进程默认从 `stdin` 读取数据，一般是从键盘输入读取
- 标准输出文件，`stdout`，文件描述符为1，进程默认向 `stdout` 输出数据，一般是输出到终端界面
- 标准错误文件，`stderr`，文件描述符为2，进程默认向 `stder` 输出错误数据【例如异常日志】，一般是输出到终端界面

这里再多提一点，有时候读者还会见到 `&> /dev/null` 这种重定向的使用，这里的 `&` 其实表示的是 `1`、`2` 的合集，即把**标准输出文件**、**标准错误文件**都重定向到 `/dev/null` 中，效果等价于使用 `1> /dev/null 2>&1`，但是效率是不是一致还有待于商榷【涉及到文件的管道，待探索】。

`/dev/null` 是一个极为特殊的设备文件，输出到这里的数据是不可见的，也就是数据会被丢弃，如果尝试从这个文件中读取数据，什么也读不到。如果读者希望在运行程序时，程序产生的日志、计算结果都不要在屏幕上输出，那么就可以选择将**标准输出文件**、**标准错误文件**都重定向到 `/dev/null`，此时无论程序产生了什么异常，你都看不到了。总的来说，这个空设备文件虽然看上去很奇怪，似乎没有什么价值，但是如果将所有的输出重定向这里，就可以达到禁止输出的效果。

好，至此概念讲解完毕，接下来会使用更加详细的命令来演示重定向的神奇功能，并且还会对比一些看起来差不多的命令。


# 详细举例


在这里如果只使用 nohup 不使用 & 把程序后台运行【仍旧是前台运行】，表面上看把输出日志重定向文件中了，屏幕不再滚动打印出来大量的文本内容。其实，程序此时仍旧在占用着键盘的输入流，你的终端命令行在等待着输入，你无法使用键盘进行其它的命令操作，而且你不能使用 ctrl + c 的方式中断，否则程序会退出。此时如果想把进程调到后台运行，可以使用 `ctrl + z` 暂停进程【同时调到后台，变为作业】，然后使用 bg 让作业在后台继续运行，如果后台的作业比较多，先使用 `jobs` 查看作业的编号，使用 `bg 作业编号` 指定某个作业在后台运行。



# 注意事项


1、在执行 Python 脚本时，发现日志内容并没有及时更新【在 Python 脚本中 print 的内容】，实时查看日志文件的内容【使用 tail -f name.log 命令】，发现不会像 Java 程序那样实时刷出来新的内容，而是会卡住一段时间，然后突然一大段日志出来。造成这种现象的原因是 Python 有输出流缓存机制，不会把输出内容实时写入输出流，而是等待缓冲区积累一定的内容再操作，这样一来，重定向到文件中的内容总是一批一批的。

当然，可以选择关闭这个选项，在执行 Python 脚本时，使用 -u 参数就可以把输出内容实时写入到输出流，也就可以实时重定向到日志文件了。

