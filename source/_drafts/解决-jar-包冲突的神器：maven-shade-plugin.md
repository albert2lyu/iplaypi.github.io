---
title: 解决 jar 包冲突的神器：maven-shade-plugin
id: 2019-12-01 00:54:21
date: 2019-12-01 00:54:21
updated: 2019-12-01 00:54:21
categories:
tags:
keywords:
---

2019120101
踩坑记录
Java,Maven,shade


最近因为协助升级相关业务 `sdk`，遇到过多次 ` jar` 包冲突的问题，此外自己在升级算法接口 `sdk` 时，也遇到过 `jar` 冲突问题。而且，这种冲突是灾难性的，不要指望通过排除、升级版本、降级版本解决，根本无法解决。

那么，最高效的方法是使用 `shade` 插件，只要加上冲突相关的配置，变更类名，即可迅速化解冲突的问题。


<!-- more -->




https://www.cnblogs.com/ilinuxer/p/6819560.html

https://blog.csdn.net/taiyangdao/article/details/78324723


还要注意一点，低版本的 `shade` 插件并不支持 `relocation` 参数来制作影子，编译时会报错。

例如 `v2.4.3` 就不行，需要 `v3.0` 以上，例如：`v3.1.0`、`v3.2.1`。

新建模块卡住的问题：

archetypeCatalog=internal

打包完成之后，在解压的包里面可以看到原本com.google.common下面的类全部被保留，低版本的路径没有变化，高版本的被放在了iplaypi下面，而这正是shade的功劳。如此一来，高、低版本的所有类都分离开了，调用方可以任意使用，不会再有冲突或者缺失情况。

当然，调用方的代码处的 import 包路径也被同步替换。

这里需要注意的是，在a中并不能随意调用c中的方法，如果方法不存在的话编译不会通过【maven 先加载了低版本的guava】。而c是一个独立的模块，所以c中的方法不受编译的限制，只有在运行时才会抛出异常。




2019-12-05 追加


引入新依赖后，要确保传递依赖不能污染了当前项目的依赖，而制作shade的目的在于这个新依赖不会有异常。

当前项目中或者当前项目的依赖中，会有一些调用，如果被传递依赖污染，会导致异常。如果是当前项目的代码显示调用，编译不会通过，但是如果是依赖中调用，编译阶段是检测不出来的，只会在运行调用时抛出异常。

使用上面的例子来说，如果在 `module-a` 中与 `module-b` 中的依赖有相同的，则在 `module-a` 中代码引用使用时，确保使用的是 `module-a` 中的版本对应的类或者方法【即把 `module-b` 中的依赖给排除掉】，否则打包后还是会缺失。

因为代码在编译阶段无法确定调用的是那个依赖里面的类或者方法，必须是执行打包操作后才明确，但是打包过程对于重复的依赖无法确定具体是哪个依赖生效。注意这里虽然在 `module-b` 中对部分依赖做了 `shade`，但是只是对 `module-b` 生效，对 `module-a` 是无效的，所以可能会导致 `module-a` 中的代码引用时找不到类或者方法，编译打包正常，运行时会出现 `NoClassDefFoundError` 异常。



2019-12-09 追加

什么场景下单独创建一个 `module`，没有任何代码，只是为了做影子依赖呢？
最先想到的肯定是传递依赖导致的冲突，例如项目中依赖了 `es-hadoop`，而由此带来的 `guava`、`http` jar 包冲突，我们不可能想着去改 `es-hadoop` 的 `pom.xml` 文件，因为我们不应当变更源码【太麻烦而且不利于管理】，当然也不一定能拿到源码。那么，只能单独创建一个 `module`，使用 `shade` 插件做影子复制。

另外还有一种情况，如果传递依赖过多，例如 `es-hadoop` 中的 `guava`，`hbase` 中的 `commons-lang`，也没有必要为每一个 `jar` 包都单独创建一个 `module`，显得繁琐而且没必要。此时可以只创建一个 `module`，用来解决所有的依赖冲突，如果这些 `jar` 包之间的传递依赖本来就冲突，那还是得为每一个 `jar` 包都创建一个 `module`【此时这种 `Maven` 项目冲突过多，是不健康的，还是升级适配为好】。


