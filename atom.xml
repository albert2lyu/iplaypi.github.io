<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虾丸派</title>
  
  <subtitle>烂笔头</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.playpi.org/"/>
  <updated>2019-01-07T13:57:22.000Z</updated>
  <id>https://www.playpi.org/</id>
  
  <author>
    <name>playpi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Gson 将 = 转为 u003d 的问题</title>
    <link href="https://www.playpi.org/2019010601.html"/>
    <id>https://www.playpi.org/2019010601.html</id>
    <published>2019-01-06T13:57:22.000Z</published>
    <updated>2019-01-07T13:57:22.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>今天遇到一个问题，实现 Web 后台接收 http 请求的一个方法，发现前端传过来的参数值，有一些特殊符号总是使用了 unicode 编码，例如等号 =，后台接收到的就是 \u003d，导致使用这个参数做 JSON 变换的时候就会出错。我看了一下这个参数取值，是前端直接填写的，而填写的人是从其它地方复制过来的，人为没有去改变，前端没有验证转换，导致传入后台的已经是这样了，那么后台只好自己想办法转换。</p><a id="more"></a><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><p> 其实就是字符串还原操作，把 Java 字符串里面的 unicode 编码子串还原为原本的字符，例如把 \u003d 转为 = 这样。</p><p>自己实现一个工具类，做编码字符串和普通字符串的转换，可以解决这个问题。</p><p>单个编码转换，公共方法示例：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * unicode 转字符串 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unicode 全为 Unicode 的字符串 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">unicode2String</span><span class="params">(String unicode)</span> </span>&#123;</span><br><span class="line">    StringBuffer string = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    String[] hex = unicode.split(<span class="string">"\\\\u"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; hex.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 转换出每一个代码点 </span></span><br><span class="line">        <span class="keyword">int</span> data = Integer.parseInt(hex[i], <span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 追加成 string</span></span><br><span class="line">        string.append((<span class="keyword">char</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>整个字符串转换，公共方法示例：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 含有 unicode 的字符串转一般字符串 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unicodeStr 混有 Unicode 的字符串 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">unicodeStr2String</span><span class="params">(String unicodeStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = unicodeStr.length();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 正则匹配条件, 可匹配 \\u 1 到 4 位, 一般是 4 位可直接使用 String regex = "\\\\u[a-f0-9A-F]&#123;4&#125;";</span></span><br><span class="line">    String regex = <span class="string">"\\\\u[a-f0-9A-F]&#123;1,4&#125;"</span>;</span><br><span class="line">    Pattern pattern = Pattern.compile(regex);</span><br><span class="line">    Matcher matcher = pattern.matcher(unicodeStr);</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">        <span class="comment">// 原本的 Unicode 字符 </span></span><br><span class="line">        String oldChar = matcher.group();</span><br><span class="line">        <span class="comment">// 转换为普通字符 </span></span><br><span class="line">        String newChar = unicode2String(oldChar);</span><br><span class="line">        <span class="keyword">int</span> index = matcher.start();</span><br><span class="line">        <span class="comment">// 添加前面不是 unicode 的字符 </span></span><br><span class="line">        sb.append(unicodeStr.substring(count, index));</span><br><span class="line">        <span class="comment">// 添加转换后的字符 </span></span><br><span class="line">        sb.append(newChar);</span><br><span class="line">        <span class="comment">// 统计下标移动的位置 </span></span><br><span class="line">        count = index + oldChar.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加末尾不是 Unicode 的字符 </span></span><br><span class="line">    sb.append(unicodeStr.substring(count, length));</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>调用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"ABCDEFG\\u003d"</span>;</span><br><span class="line">System.out.println(<span class="string">"====unicode2String 工具转换:"</span> + unicodeStr2String(str));</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">====unicode2String 工具转换: ABCDEFG=</span><br></pre></td></tr></table></figure><p>截图示例：</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyyep0kwtgj20yv0kk0ug.jpg" alt="自己转换" title="自己转换"></p><h1 id="问题后续"><a href="# 问题后续" class="headerlink" title="问题后续"></a>问题后续 </h1><p> 后续我又在想，这个字符串到底是怎么来的，为什么填写的人会复制出来这样一个字符串，一般 unicode 编码不会出现在日常生活中的。我接着发现这个字符串是从另外一个系统导出的，导出的时候是一个类似于 Java 实体类的 JSON 格式字符串，从里面复制出来这个值，就是 \u003d 格式的。</p><p>那我觉得肯定是这个系统有问题，做 JSON 序列化的时候没有控制好序列化的方式，导致对于特殊字符就会自动转为 unicode 编码，给他人带来麻烦，当然，我无法得知系统内部做了什么，但是猜测可能是使用 Gson 工具做序列化的时候没有正确使用 Gson 的对象，只是简单的生成 JSON 字符串而已，例如看我下面的代码示例（等号 = 会被转为 \ u003d）。</p><p>使用普通的 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gson gson1 = <span class="keyword">new</span> Gson();</span><br></pre></td></tr></table></figure><p> 会导致后续转换 JSON 字符串的时候出现 unicode 编码子串的情况，而正确生成 Gson 对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gson gson2 = <span class="keyword">new</span> GsonBuilder().disableHtmlEscaping().create();</span><br></pre></td></tr></table></figure><p> 则不会出现这种情况。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyyeompqqcj20zr0k3jt4.jpg" alt="正确使用 Gson" title="正确使用 Gson"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天遇到一个问题，实现 Web 后台接收 http 请求的一个方法，发现前端传过来的参数值，有一些特殊符号总是使用了 unicode 编码，例如等号 =，后台接收到的就是 \u003d，导致使用这个参数做 JSON 变换的时候就会出错。我看了一下这个参数取值，是前端直接填写的，而填写的人是从其它地方复制过来的，人为没有去改变，前端没有验证转换，导致传入后台的已经是这样了，那么后台只好自己想办法转换。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Gson" scheme="https://www.playpi.org/tags/Gson/"/>
    
      <category term="等号编码转换" scheme="https://www.playpi.org/tags/%E7%AD%89%E5%8F%B7%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="u003d" scheme="https://www.playpi.org/tags/u003d/"/>
    
  </entry>
  
  <entry>
    <title>蒸水蛋做法总结</title>
    <link href="https://www.playpi.org/2018122901.html"/>
    <id>https://www.playpi.org/2018122901.html</id>
    <published>2018-12-29T15:21:25.000Z</published>
    <updated>2018-12-29T16:21:25.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>蒸水蛋是一道小吃，有时候就简称为水蛋，可以当菜配饭吃，也可以配包子当做早餐，或者晚上蒸一碗当做宵夜，都非常好。吃起来嫩滑爽口，而且营养也丰富，做法非常简单，本文就记录蒸水蛋的过程。</p><a id="more"></a><h1 id="食材准备"><a href="# 食材准备" class="headerlink" title="食材准备"></a>食材准备 </h1><p>2 人份的材料（1 人份减半即可，但是我觉得 1 人份的太少了，做起来浪费，不值当）：</p><ul><li> 鸡蛋 2 只（1 只做成 1 碗）</li><li>葱花少许 </li><li> 生抽少许 </li><li> 食用盐少许 </li><li> 香油少许 </li></ul><h1 id="制作步骤"><a href="# 制作步骤" class="headerlink" title="制作步骤"></a> 制作步骤 </h1><p>1、准备 2 只小碗（有条件的可以使用带盖子的蒸盅，也就是平时吃快餐盛汤的那种带盖子的小碗），普通的小饭碗即可，一定要是耐热的材料，不要用秸秆环保碗、塑料饭盒、普通玻璃碗等（蒸的时候温度很高，虽然水的沸点是 100 度，但是锅内因为有水蒸气存在，压强变大，同时水蒸气转为液态会放热，锅内实际温度大于 100 度），分别打入 1 只鸡蛋，加少许食用盐，搅拌均匀（下面过程就以 1 份为准，另外 1 份是同样的操作）；</p><p>2、搅拌均匀后开始加温水（最好是温水），温水的量大概是鸡蛋液的 2 倍，即鸡蛋液比温水等于 1:2，注意加温水的量，少了多了都不好（2-3 倍都行，如果碗大一点可能 1 份水蛋就需要放 2 只鸡蛋，不然显得太少了），继续搅拌，此时搅拌完成后表面应该会有一层小泡沫，可以用勺子把小泡沫都盛出去，保证蒸出来的水蛋表面光滑（怕浪费保留也行）；</p><p>3、蒸鸡蛋的时候使用保鲜膜封住碗口（有条件的使用整蛊更方便，盖子一盖即可），或者使用小盘子反盖在碗口，这样做是为了保证密封，一方面为了保证蒸出来的水蛋嫩滑，另一方面为了避免液化的水蒸气滴进去，影响水蛋的质量，先大火烧水，等水开后转为小火（火力很重要），再蒸 8 分钟即可出锅（这个时间很重要，太久了鸡蛋就老了）；</p><p>4、取出后，滴入少许香油、生抽（不加也行，直接吃），撒入一点点葱花，即可食用，入口即化，滑嫩可口；</p><p> 以下这个我认为是做失败的，加太多水，蒸的过程中不断滴入液化的水蒸气，破坏了美感，也没葱花，但是吃起来绝对美味。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyo56bfejij229s29sx6p.jpg" alt="很勉强的蒸水蛋" title="很勉强的蒸水蛋"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1、食用盐是搅拌鸡蛋的时候就加入的，不是蒸好后再放的，这样才能入味而且分布均匀；</p><p>2、加水时一定要加温水，不是冷水，也不是热水，温水才能让蒸出来的水蛋保持嫩滑；</p><p>3、如果使用保鲜膜，一定要用可以蒸的材料，不是随便能用的。如果是 PVC 材料（聚氯乙烯），坚决不行，含有塑化剂释放有毒物质影响健康，如果是 PE 材料（聚乙烯），无毒，但是耐热温度不够，也不行，如果是 PVDC 材料（聚偏氯乙烯），安全温度在 140 度，可以使用。所以还是使用盘子比较好。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;蒸水蛋是一道小吃，有时候就简称为水蛋，可以当菜配饭吃，也可以配包子当做早餐，或者晚上蒸一碗当做宵夜，都非常好。吃起来嫩滑爽口，而且营养也丰富，做法非常简单，本文就记录蒸水蛋的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="蒸水蛋" scheme="https://www.playpi.org/tags/%E8%92%B8%E6%B0%B4%E8%9B%8B/"/>
    
      <category term="水蛋" scheme="https://www.playpi.org/tags/%E6%B0%B4%E8%9B%8B/"/>
    
      <category term="蒸鸡蛋" scheme="https://www.playpi.org/tags/%E8%92%B8%E9%B8%A1%E8%9B%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spark 异常之 java.net.BindException: 地址已在使用</title>
    <link href="https://www.playpi.org/2018122801.html"/>
    <id>https://www.playpi.org/2018122801.html</id>
    <published>2018-12-28T15:49:01.000Z</published>
    <updated>2018-12-28T15:49:01.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>今天查看日志发现，所有的 Spark 程序提交时会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.BindException: 地址已在使用 </span><br></pre></td></tr></table></figure><p>而且不止一次，会连续有多个这种异常，但是 Spark 程序又能正常运行，不会影响到对应的功能。本文就记录发现问题、分析问题的过程。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 在 Driver 端查看日志，发现连续多次相同的异常（省略了业务相关类信息）：</p><p>异常截图 </p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fymxb3zolsj210v0dzabe.jpg" alt="异常截图" title="异常截图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次异常 </span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0:<span class="number">4040</span>: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">425</span>)</span><br><span class="line">at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:<span class="number">223</span>)</span><br><span class="line">at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:<span class="number">74</span>)</span><br><span class="line">at org.spark-project.jetty.server.nio.SelectChannelConnector.open(SelectChannelConnector.java:<span class="number">187</span>)</span><br><span class="line">at org.spark-project.jetty.server.AbstractConnector.doStart(AbstractConnector.java:<span class="number">316</span>)</span><br><span class="line">at org.spark-project.jetty.server.nio.SelectChannelConnector.doStart(SelectChannelConnector.java:<span class="number">265</span>)</span><br><span class="line">at org.spark-project.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:<span class="number">64</span>)</span><br><span class="line">at org.spark-project.jetty.server.Server.doStart(Server.java:<span class="number">293</span>)</span><br><span class="line">at org.spark-project.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:<span class="number">64</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$.org$apache$spark$ui$JettyUtils$$connect$<span class="number">1</span>(JettyUtils.scala:<span class="number">252</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$$anonfun$<span class="number">5</span>.apply(JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$$anonfun$<span class="number">5</span>.apply(JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.util.Utils$$anonfun$startServiceOnPort$<span class="number">1</span>.apply$mcVI$sp(Utils.scala:<span class="number">2024</span>)</span><br><span class="line">at scala.collection.immutable.Range.foreach$mVc$sp(Range.scala:<span class="number">141</span>)</span><br><span class="line">at org.apache.spark.util.Utils$.startServiceOnPort(Utils.scala:<span class="number">2015</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$.startJettyServer(JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.ui.WebUI.bind(WebUI.scala:<span class="number">136</span>)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$<span class="number">13</span>.apply(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$<span class="number">13</span>.apply(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at scala.Option.foreach(Option.scala:<span class="number">236</span>)</span><br><span class="line">at org.apache.spark.SparkContext.&lt;init&gt;(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at org.apache.spark.api.java.JavaSparkContext.&lt;init&gt;(JavaSparkContext.scala:<span class="number">59</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED org.spark-project.jetty.server.Server@<span class="number">33e434</span>c8: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">425</span>)</span><br><span class="line">at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:<span class="number">223</span>)</span><br><span class="line">at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:<span class="number">74</span>)</span><br><span class="line">at org.spark-project.jetty.server.nio.SelectChannelConnector.open(SelectChannelConnector.java:<span class="number">187</span>)</span><br><span class="line">at org.spark-project.jetty.server.AbstractConnector.doStart(AbstractConnector.java:<span class="number">316</span>)</span><br><span class="line">at org.spark-project.jetty.server.nio.SelectChannelConnector.doStart(SelectChannelConnector.java:<span class="number">265</span>)</span><br><span class="line">at org.spark-project.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:<span class="number">64</span>)</span><br><span class="line">at org.spark-project.jetty.server.Server.doStart(Server.java:<span class="number">293</span>)</span><br><span class="line">at org.spark-project.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:<span class="number">64</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$.org$apache$spark$ui$JettyUtils$$connect$<span class="number">1</span>(JettyUtils.scala:<span class="number">252</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$$anonfun$<span class="number">5</span>.apply(JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$$anonfun$<span class="number">5</span>.apply(JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.util.Utils$$anonfun$startServiceOnPort$<span class="number">1</span>.apply$mcVI$sp(Utils.scala:<span class="number">2024</span>)</span><br><span class="line">at scala.collection.immutable.Range.foreach$mVc$sp(Range.scala:<span class="number">141</span>)</span><br><span class="line">at org.apache.spark.util.Utils$.startServiceOnPort(Utils.scala:<span class="number">2015</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$.startJettyServer(JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.ui.WebUI.bind(WebUI.scala:<span class="number">136</span>)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$<span class="number">13</span>.apply(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$<span class="number">13</span>.apply(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at scala.Option.foreach(Option.scala:<span class="number">236</span>)</span><br><span class="line">at org.apache.spark.SparkContext.&lt;init&gt;(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at org.apache.spark.api.java.JavaSparkContext.&lt;init&gt;(JavaSparkContext.scala:<span class="number">59</span>)</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次异常 </span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0:<span class="number">4041</span>: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">425</span>)</span><br><span class="line">...... 其它信息都一样 </span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次异常 </span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0:<span class="number">4042</span>: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">425</span>)</span><br><span class="line">....... 其它信息都一样 </span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次异常 </span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0:<span class="number">4043</span>: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">425</span>)</span><br><span class="line">....... 其它信息都一样 </span><br></pre></td></tr></table></figure><p> 可以轻易发现核心的地方在于：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0: 端口号: java.net.BindException: 地址已在使用 </span><br></pre></td></tr></table></figure><p></p><p>端口号在不断变化，从 4040 一直到 4043，才停止了异常的抛出。</p><h1 id="问题分析"><a href="# 问题分析" class="headerlink" title="问题分析"></a>问题分析 </h1><p> 在 Spark 创建 context 的时候，会使用 4040 端口作为默认的 SparkUI 端口，如果遇到 4040 端口被占用，则会抛出异常。接着会尝试下一个可用的端口，采用累加的方式，则使用 4041 端口，很不巧，这个端口也被占用了，也会抛出异常。接着就是重复上面的过程，直到找到空闲的端口。</p><p>这个异常其实没什么问题，是正常的，原因可能就是在一台机器上面有多个进程都在使用 Spark，创建 context，有的 Spark 任务正在运行着，占用了 4040 端口；或者就是单纯的端口被某些应用程序占用了而已。此时是不能简单地把这些进程杀掉的，会影响别人的业务。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><p> 既然找到了问题，解决办法就很简单了：</p><p>1、这本来就不是问题，直接忽略即可，不会影响 Spark 任务的正常运行；</p><p>2、如果非要不想看到异常日志，那么可以检查机器的 4040 端口被什么进程占用了，看看能不能杀掉，当然这种方法不好了；</p><p>3、可以自己指定端口（使用 spark.ui.port 配置项），确保使用空闲的端口即可（不建议，因为要确认空闲的端口，如果端口不空闲，Spark 的 context 会创建失败，更麻烦，还不如让 Spark 自己去重试）。</p><p>参考：<a href="https://community.hortonworks.com/questions/8257/how-can-i-resolve-it.html" target="_blank" rel="noopener">hortonworks</a></p><p>原文：</p><blockquote><p>When a spark context is created, it starts an application UI on port 4040 by default. When the UI starts, it checks to see if the port is in use, if so it should increment to 4041. Looks like you have something running on port 4040 there. The application should show you the warning, then try to start the UI on 4041.<br>This should not stop your application from running. If you really want to get around the WARNING, you can manually specify which port for the UI to start on, but I would strongly advise against doing so.<br>To manually specify the port, add this to your spark-submit:<br>–conf spark.ui.port=your_port</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天查看日志发现，所有的 Spark 程序提交时会抛出异常：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.net.BindException: 地址已在使用 &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;而且不止一次，会连续有多个这种异常，但是 Spark 程序又能正常运行，不会影响到对应的功能。本文就记录发现问题、分析问题的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="BindException" scheme="https://www.playpi.org/tags/BindException/"/>
    
  </entry>
  
  <entry>
    <title>HDFS 异常之 READ is not supported in state standby</title>
    <link href="https://www.playpi.org/2018122702.html"/>
    <id>https://www.playpi.org/2018122702.html</id>
    <published>2018-12-27T11:06:42.000Z</published>
    <updated>2018-12-27T11:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>今天查看日志发现，以前正常运行的 Spark 程序会不断抛出异常：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby</span><br></pre></td></tr></table></figure><p></p><p>但是却没有影响到功能的正常运行，只不过是抛出了大量的上述异常，而且内容都一样，也都是操作 HDFS 产生的，所以猜测与 HDFS 集群（或者配置）有关系。本文就记录发现问题、解决问题的过程。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 按照日常操作，查看 Spark 任务的 Driver 端的日志，结果发现了大量的重复异常，又看了一下对功能的影响，结果发现没有影响，所有功能均正常运行，产生的结果也是期望的。</p><h2 id="问题分析"><a href="# 问题分析" class="headerlink" title="问题分析"></a>问题分析 </h2><p> 详细来看一下 Driver 端的日志异常信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">2018-12-26_23:25:40 [main] INFO retry.RetryInvocationHandler:140: Exception while invoking getFileInfo of class ClientNamenodeProtocolTranslatorPB over hadoop1/192.168.10.162:8020. Trying to fail over immediately.</span><br><span class="line">org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.ha.StandbyState.checkOperation(StandbyState.java:<span class="number">87</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.NameNode$NameNodeHAContext.checkOperation(NameNode.java:<span class="number">1722</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.checkOperation(FSNamesystem.java:<span class="number">1362</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.getFileInfo(FSNamesystem.java:<span class="number">4414</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.NameNodeRpcServer.getFileInfo(NameNodeRpcServer.java:<span class="number">893</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.protocolPB.ClientNamenodeProtocolServerSideTranslatorPB.getFileInfo(ClientNamenodeProtocolServerSideTranslatorPB.java:<span class="number">835</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos$ClientNamenodeProtocol$<span class="number">2</span>.callBlockingMethod(ClientNamenodeProtocolProtos.java)</span><br><span class="line">at org.apache.hadoop.ipc.ProtobufRpcEngine$Server$ProtoBufRpcInvoker.call(ProtobufRpcEngine.java:<span class="number">619</span>)</span><br><span class="line">at org.apache.hadoop.ipc.RPC$Server.call(RPC.java:<span class="number">962</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Server$Handler$<span class="number">1</span>.run(Server.java:<span class="number">2039</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Server$Handler$<span class="number">1</span>.run(Server.java:<span class="number">2035</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at javax.security.auth.Subject.doAs(Subject.java:<span class="number">422</span>)</span><br><span class="line">at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:<span class="number">1628</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Server$Handler.run(Server.java:<span class="number">2033</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Client.call(Client.java:<span class="number">1468</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Client.call(Client.java:<span class="number">1399</span>)</span><br><span class="line">at org.apache.hadoop.ipc.ProtobufRpcEngine$Invoker.invoke(ProtobufRpcEngine.java:<span class="number">232</span>)</span><br><span class="line">at com.sun.proxy.$Proxy30.getFileInfo(Unknown Source)</span><br><span class="line">at org.apache.hadoop.hdfs.protocolPB.ClientNamenodeProtocolTranslatorPB.getFileInfo(ClientNamenodeProtocolTranslatorPB.java:<span class="number">768</span>)</span><br><span class="line">at sun.reflect.GeneratedMethodAccessor34.invoke(Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">at org.apache.hadoop.io.retry.RetryInvocationHandler.invokeMethod(RetryInvocationHandler.java:<span class="number">187</span>)</span><br><span class="line">at org.apache.hadoop.io.retry.RetryInvocationHandler.invoke(RetryInvocationHandler.java:<span class="number">102</span>)</span><br><span class="line">at com.sun.proxy.$Proxy31.getFileInfo(Unknown Source)</span><br><span class="line">at org.apache.hadoop.hdfs.DFSClient.getFileInfo(DFSClient.java:<span class="number">2007</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DistributedFileSystem$<span class="number">19</span>.doCall(DistributedFileSystem.java:<span class="number">1136</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DistributedFileSystem$<span class="number">19</span>.doCall(DistributedFileSystem.java:<span class="number">1132</span>)</span><br><span class="line">at org.apache.hadoop.fs.FileSystemLinkResolver.resolve(FileSystemLinkResolver.java:<span class="number">81</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DistributedFileSystem.getFileStatus(DistributedFileSystem.java:<span class="number">1132</span>)</span><br><span class="line">at org.apache.hadoop.fs.FileSystem.isFile(FileSystem.java:<span class="number">1426</span>)</span><br></pre></td></tr></table></figure><p>注意一下核心异常所在：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception while invoking getFileInfo of class ClientNamenodeProtocolTranslatorPB over hadoop1/192.168.10.162:8020. Trying to fail over immediately.</span><br><span class="line">org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby</span><br></pre></td></tr></table></figure><p></p><p>当去从 hadoop1/192.168.10.162:8020 这里 getFileInfo 的时候，抛出了异常，而且明确告诉我们这台机器处于 standby 状态，不支持读取操作。此时，可以想到，肯定是 hadoop1/192.168.10.162:8020 这台机器已经处于 standby 状态了，无法提供服务，所以抛出此异常。既然问题找到了，那么问题产生的原因是什么呢，以及为什么对功能没有影响，接下来一一分析。</p><p>首先查看 hdfs-site.xml 配置文件，看看 namenode 相关的配置项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.nameservices<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>r-cluster<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.namenodes.r-cluster<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>nn1,nn2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.r-cluster.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop1:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.r-cluster.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>rocket15:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，namenode 相关配置有 2 台机器：nn1、nn2，而上述产生异常的信息表明连接 nn1 被拒绝，那么我去看一下 HDFS 集群的状态，发现 nn1 果然是 standby 状态的，而 nn2（rocket15） 才是 active 状态。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyluqlzruwj20ln0b6mxq.jpg" alt="nn2 的 active 状态" title="nn2 的 active 状态"></p><p>再仔细查看日志，没有发现连接 nn2 的异常，那就说明是第一次连接 nn1 抛出异常，然后试图连接 nn2，成功连接，没有抛出异常，接下来程序就正常处理数据了，对功能没有任何影响。</p><p>到这里，我们已经分析出了整个过程，现象表明这个异常只是连接了 standby 状态的 namenode，是正常抛出的。然后会再次连接另外一台 active 状态的 namenode，连接成功。</p><h2 id="抛异常的流程细节"><a href="# 抛异常的流程细节" class="headerlink" title="抛异常的流程细节"></a>抛异常的流程细节 </h2><p>1、客户端在连接 HDFS 的时候，会从配置文件 hdfs-site.xml 中，读取 nameservices 的配置，获取机器编号，我这里是 nn1 和 nn2，分别对应着 2 台 namenode 机器；</p><p>2、客户端会首先选择编号较小的 namenode（我这里是 nn1，对应着 hadoop1），试图连接；</p><p>3、如果这台 namenode 是 active 状态，则客户端可以正常处理请求；但是如果这台 namenode 是 standby 状态，则客户端抛出由服务端返回的异常：Operation category READ is not supported in state standby，同时打印 ip 信息，接着会尝试连接另外一台编号较大的 namenode（我这里是 nn2，即 rocket15）；</p><p>4、如果连接成功，则客户端可以正常处理请求；如果 nn2 仍然像 nn1 一样，客户端会抛出一样的异常，此时会继续反复重试 nn1 与 nn2（重试次数有配置项，间隔时间有配置项）；如果有成功的，则客户端可以正常处理请求，如果全部失败，则客户端无法正常处理请求，此时应该要关注解决 namenode 为什么全部都处在 standby 状态。</p><p> 配置参数如下（参考 <a href="https://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml" target="_blank" rel="noopener">Hadoop 官方文档 </a>）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 客户端重试次数, 默认 15 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.max.attempts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>15<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 客户端 2 次重试间隔时间, 默认 500 毫秒 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.sleep.base.millis<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>500<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 客户端 2 次重试间隔时间, 默认 1500 毫秒 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.sleep.max.millis<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1500<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 客户端 1 次连接中重试次数, 默认 0, 在网络不稳定时建议加大此值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.connection.retries<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 客户端 1 次连接中超时重试次数，仅是指超时重试, 默认 0, 在网络不稳定时建议加大此值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.connection.retries.on.timeouts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a> 问题解决 </h1><p> 既然明确了问题，并且分析出了具体原因，解决起来就简单了，对于我这种情况，有 2 种方法：</p><p>1、不用解决，也无需关心，这个异常没有任何影响，会自动重连另外一台 active 状态的 namenode 机器的；</p><p>2、如果就是一心想把异常消除掉，那就更改 hdfs-site.xml 配置文件里面的 nameservices 配置项对应的机器，把编号最小的机器设置成状态为 active 的 namenode（例如我这里把 nn1、nn2 的对应的机器 ip 地址交换一下即可，确保 nn1 是 active 状态的），那么连接 HDFS 的时候第一次就会直接连接这台机器，就不会抛出异常了（但是要注意 namenode 以后可能是会挂的，挂了会自动切换，那么到那个时候还要更改这个配置项）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.r-cluster.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>rocket15:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.r-cluster.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop1:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><p>1、参考：<a href="http://support-it.huawei.com/docs/zh-cn/fusioninsight-all/maintenance-guide/zh-cn_topic_0062904132.html" target="_blank" rel="noopener">http://support-it.huawei.com/docs/zh-cn/fusioninsight-all/maintenance-guide/zh-cn_topic_0062904132.html</a></p><p>2、这个问题其实不是问题，只不过抛出了异常，我看到有点担心而已，但是如果连接所有的机器都抛出这种异常，并且重试了很多次就有影响了，说明所有的 namenode 都挂了，根本无法正常操作 HDFS 系统；</p><p>3、根据 2 进行总结：如果只是在操作 HDFS 的时候打印一次（每次操作都会打印一次），说明第一次连接到了 standby 状态的 namenode，是正常的，不用关心；但是，如果出现了大量的异常（比如连续 10 次，连续 20 次），说明 namenode 出问题了，此时应该关心 namenode 的状态，确保正常服务。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天查看日志发现，以前正常运行的 Spark 程序会不断抛出异常：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是却没有影响到功能的正常运行，只不过是抛出了大量的上述异常，而且内容都一样，也都是操作 HDFS 产生的，所以猜测与 HDFS 集群（或者配置）有关系。本文就记录发现问题、解决问题的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Hadoop 从零基础到入门系列" scheme="https://www.playpi.org/categories/series-of-hadoop/"/>
    
    
      <category term="Hadoop" scheme="https://www.playpi.org/tags/Hadoop/"/>
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="HDFS" scheme="https://www.playpi.org/tags/HDFS/"/>
    
      <category term="nameNode" scheme="https://www.playpi.org/tags/nameNode/"/>
    
      <category term="standby" scheme="https://www.playpi.org/tags/standby/"/>
    
  </entry>
  
  <entry>
    <title>HDFS 异常之 Filesystem closed</title>
    <link href="https://www.playpi.org/2018122701.html"/>
    <id>https://www.playpi.org/2018122701.html</id>
    <published>2018-12-27T09:35:54.000Z</published>
    <updated>2018-12-27T09:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>今天通过 Hadoop 的 api 去操作 HDFS 里面的文件，读取文本内容，但是在代码里面总是抛出以下异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.io.IOException: Filesystem closed</span><br></pre></td></tr></table></figure><p>然而文本内容又是正常读取出来的，但是我隐隐觉得读取的文本内容可能不全，应该只是所有文本内容的一部分。本文就记录这个问题的原因、影响以及解决方法。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 通过查看日志发现，有大量的异常日志打印出来，全部都是操作 HDFS 的时候产生的，有的是使用 Spark 连接 HDFS 读取文本数据，有的是使用 Hadoop 的 Java api 通过文件流来读取数据，每次读取操作都会产生一个如下异常信息（会影响实际读取的内容，多个 DataNode 的内容会漏掉）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">26_23</span>:<span class="number">25</span>:<span class="number">46</span> [SparkListenerBus] ERROR scheduler.LiveListenerBus:<span class="number">95</span>: Listener EventLoggingListener threw an exception</span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">at sun.reflect.GeneratedMethodAccessor33.invoke(Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">at org.apache.spark.scheduler.EventLoggingListener$$anonfun$logEvent$<span class="number">3</span>.apply(EventLoggingListener.scala:<span class="number">150</span>)</span><br><span class="line">at org.apache.spark.scheduler.EventLoggingListener$$anonfun$logEvent$<span class="number">3</span>.apply(EventLoggingListener.scala:<span class="number">150</span>)</span><br><span class="line">at scala.Option.foreach(Option.scala:<span class="number">236</span>)</span><br><span class="line">at org.apache.spark.scheduler.EventLoggingListener.logEvent(EventLoggingListener.scala:<span class="number">150</span>)</span><br><span class="line">at org.apache.spark.scheduler.EventLoggingListener.onJobStart(EventLoggingListener.scala:<span class="number">173</span>)</span><br><span class="line">at org.apache.spark.scheduler.SparkListenerBus$class.onPostEvent(SparkListenerBus.scala:34)</span><br><span class="line">at org.apache.spark.scheduler.LiveListenerBus.onPostEvent(LiveListenerBus.scala:<span class="number">31</span>)</span><br><span class="line">at org.apache.spark.scheduler.LiveListenerBus.onPostEvent(LiveListenerBus.scala:<span class="number">31</span>)</span><br><span class="line">at org.apache.spark.util.ListenerBus$class.postToAll(ListenerBus.scala:55)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus.postToAll(AsynchronousListenerBus.scala:<span class="number">37</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>$$anonfun$run$<span class="number">1</span>$$anonfun$apply$mcV$sp$<span class="number">1</span>.apply$mcV$sp(AsynchronousListenerBus.scala:<span class="number">80</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>$$anonfun$run$<span class="number">1</span>$$anonfun$apply$mcV$sp$<span class="number">1</span>.apply(AsynchronousListenerBus.scala:<span class="number">65</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>$$anonfun$run$<span class="number">1</span>$$anonfun$apply$mcV$sp$<span class="number">1</span>.apply(AsynchronousListenerBus.scala:<span class="number">65</span>)</span><br><span class="line">at scala.util.DynamicVariable.withValue(DynamicVariable.scala:<span class="number">57</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>$$anonfun$run$<span class="number">1</span>.apply$mcV$sp(AsynchronousListenerBus.scala:<span class="number">64</span>)</span><br><span class="line">at org.apache.spark.util.Utils$.tryOrStopSparkContext(Utils.scala:<span class="number">1181</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>.run(AsynchronousListenerBus.scala:<span class="number">63</span>)</span><br><span class="line">Caused by: java.io.IOException: Filesystem closed</span><br><span class="line">at org.apache.hadoop.hdfs.DFSClient.checkOpen(DFSClient.java:<span class="number">795</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DFSOutputStream.flushOrSync(DFSOutputStream.java:<span class="number">1986</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DFSOutputStream.hflush(DFSOutputStream.java:<span class="number">1947</span>)</span><br><span class="line">at org.apache.hadoop.fs.FSDataOutputStream.hflush(FSDataOutputStream.java:<span class="number">130</span>)</span><br><span class="line">... <span class="number">20</span> more</span><br></pre></td></tr></table></figure><p>最直接清晰的描述就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.io.IOException: Filesystem closed</span><br></pre></td></tr></table></figure><p>上述异常信息表明 HDFS 的 Filesystem 被关闭了，但是代码仍旧试图打开文件流读取内容。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><h2 id="分析一下"><a href="# 分析一下" class="headerlink" title="分析一下"></a> 分析一下 </h2><p> 根据上述信息，查看代码，每次操作 HDFS 都是独立的，会先根据统一的 conf 创建 Filesystem，然后根据文件路径创建 Path，打开输入流，读取内容，读取完成后关闭 Filesystem，没有什么异常的地方。</p><p>同时，根据异常信息可以发现，异常的抛出点并不是业务逻辑代码，更像是已经开始开启文件流读取文件，读着读着 Filesystem 就被关闭了，然后引发了异常，而业务逻辑中并没有突然关闭 Filesystem 的地方，也没有多线程操作 Filesystem 的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文件内容 </span></span><br><span class="line"><span class="comment"> * 纯文本, 不做转换 </span></span><br><span class="line"><span class="comment"> * 如果传入目录, 返回空内容 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hdfsFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">getFileContent</span><span class="params">(String hdfsFile)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; dataResult = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    FileSystem fs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 连接 hdfs</span></span><br><span class="line">        fs = FileSystem.get(CONF);</span><br><span class="line">        Path path = <span class="keyword">new</span> Path(hdfsFile);</span><br><span class="line">        <span class="keyword">if</span> (fs.isFile(path)) &#123;</span><br><span class="line">            FSDataInputStream fsDataInputStream = fs.open(path);</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(fsDataInputStream));</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != (line = bufferedReader.readLine())) &#123;</span><br><span class="line">                dataResult.add(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"!!!! 当前输入参数为目录, 不读取内容:&#123;&#125;"</span>, hdfsFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"!!!! 处理 hdfs 出错:"</span> + e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != fs) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"!!!! 关闭文件流出错:"</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查找文档发现，这个异常是 Filesystem 的缓存导致的。</p><p>当任务提交到集群上面以后，多个 datanode 在 getFileSystem 过程中，由于 Configuration 一样，会得到同一个 FileSystem。如果有一个 datanode 在使用完关闭连接，其它的 datanode 在访问时就会出现上述异常，导致数据缺失（如果数据恰好只存在一个 datanode 上面，可能没问题）。</p><h2 id="找到方法"><a href="# 找到方法" class="headerlink" title="找到方法"></a>找到方法 </h2><p> 通过上面的分析，找到了原因所在，那么解决方法有 2 种：</p><p>1、可以在 HDFS 的 core-site.xml 配置文件里面把 fs.hdfs.impl.disable.cache 设置为 true，这样设置会全局生效，所有使用这个配置文件的连接都会使用这种方式，有时候可能不想这样更改，那就使用第 2 种方式；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.hdfs.impl.disable.cache<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、在 HDFS 提供的 Java api 里面更改配置信息，则会只针对使用当前 conf 的连接有效，相当于临时参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存 fs, 避免多 datanode 异常: Caused by: java.io.IOException: Filesystem closed</span></span><br><span class="line">CONF.setBoolean(<span class="string">"fs.hdfs.impl.disable.cache"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>上面 2 种方法的目的都是为了关闭缓存 Filesyetem 实例，这样每次获得的 Filesystem 实例都是独立的，不会产生上述的异常，但是缺点就是会增加网络的 I/O，频繁开启、关闭文件流。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><p>1、参考：<a href="https://stackoverflow.com/questions/23779186/ioexception-filesystem-closed-exception-when-running-oozie-workflow" target="_blank" rel="noopener">https://stackoverflow.com/questions/23779186/ioexception-filesystem-closed-exception-when-running-oozie-workflow</a> ；</p><p>2、保留日志，查看日志很重要；</p><p>3、FileSytem 类内部有一个 static CACHE，用来保存每种文件系统的实例集合，FileSystem 类中可以通过参数 fs.%s.impl.disable.cache 来指定是否禁用缓存 FileSystem 实例（其中 %s 替换为相应的 scheme，比如 hdfs、local、s3、s3n 等）。如果没禁用，一旦创建了相应的 FileSystem 实例，这个实例将会保存在缓存中，此后每次 get 都会获取同一个实例，但是如果被关闭了，则再次用到就会无法获取（多 datanode 读取数据的时候）；</p><p>4、源码分析放在以后，留坑。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天通过 Hadoop 的 api 去操作 HDFS 里面的文件，读取文本内容，但是在代码里面总是抛出以下异常：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Caused by: java.io.IOException: Filesystem closed&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然而文本内容又是正常读取出来的，但是我隐隐觉得读取的文本内容可能不全，应该只是所有文本内容的一部分。本文就记录这个问题的原因、影响以及解决方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Hadoop 从零基础到入门系列" scheme="https://www.playpi.org/categories/series-of-hadoop/"/>
    
    
      <category term="Hadoop" scheme="https://www.playpi.org/tags/Hadoop/"/>
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="Filesystem" scheme="https://www.playpi.org/tags/Filesystem/"/>
    
      <category term="HDFS" scheme="https://www.playpi.org/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>可乐鸡翅做法总结</title>
    <link href="https://www.playpi.org/2018122501.html"/>
    <id>https://www.playpi.org/2018122501.html</id>
    <published>2018-12-24T17:36:37.000Z</published>
    <updated>2018-12-25T17:36:37.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p> 本文简单介绍可乐鸡翅的做法总结，这是一道偏甜的菜。</p><a id="more"></a><p> 待整理。</p><p> 注意不要再放糖了，一罐可乐里面含糖大概 35 克；</p><p> 注意如果放了生抽，也不用放盐了，或者少量放一点点；</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本文简单介绍可乐鸡翅的做法总结，这是一道偏甜的菜。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="可乐鸡翅" scheme="https://www.playpi.org/tags/%E5%8F%AF%E4%B9%90%E9%B8%A1%E7%BF%85/"/>
    
  </entry>
  
  <entry>
    <title>Spark 错误之 JavaSparkContext not serializable</title>
    <link href="https://www.playpi.org/2018122101.html"/>
    <id>https://www.playpi.org/2018122101.html</id>
    <published>2018-12-20T16:43:50.000Z</published>
    <updated>2018-12-20T16:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>今天更新代码，对 Spark 里面的 RDD 随便增加了一个 Function，结果遇到了序列化（Serializable）的问题，这个不是普通的自定义类不能序列化问题，而是 JavaSparkContext 的用法问题，由于小看了这个问题，多花了一点时间解决问题，本文就记录下这一过程。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 针对已有的项目改动了一点点，结果直接出现了这个错误：</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fydoetmx57j21gx0hjgph.jpg" alt="日志报错" title="日志报错"></p><p>一开始疏忽大意了，以为像往常一样，是某些需要传递的对象对应的类没有序列化，由于对代码不敢改动太大，就想着用最简单的方法，把几个自定义类都序列化了，以为就应该可以了。结果，还是不行，此时虽然不会有自定义类的序列化问题了，但是却出现了终极错误：JavaSparkContext not serializable，这是什么意思呢，是说 JavaSparkContext 不能序列化，总不能把 JavaSparkContext 序列化吧，Spark 是不允许这么干的。</p><p>那么问题是什么呢？我首先猜测肯定是 Function 里面用到了 JavaSparkContext 对象，导致启动 Spark 任务的时候，需要序列化 Function 用到的所有对象（当然也需要序列化对象所属类里面的所有属性），而这些 Function 所用到的所有对象里面，就有 JavaSparkContext 对象。于是，我耐心看了一下代码，果然，在创建 Function 对象的时候，竟然把 JavaSparkContext 对象作为参数传进去了，还是因为 JavaSparkContext 不能乱用。</p><p>其实，报错日志里面都已经明显指向说明了，除了自定义的类，错误归结于 <br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at org.apache.spark.api.java.AbstractJavaRDDLike.mapPartitions(JavaRDDLike.scala:<span class="number">46</span>)</span><br></pre></td></tr></table></figure><p></p><p> 而这里的代码，正是我增加的一部分，为了贪图简单方便，直接把 JavaSparkContext 对象传递给了 mapPartitions 对应的 Function。</p><h1 id="解决问题"><a href="# 解决问题" class="headerlink" title="解决问题"></a>解决问题 </h1><p> 既然找到了问题，接下来就好办了。既然 JavaSparkContext 不能乱用，那就不用，把这个传递参数去掉，即可正常运行，但是这样做太简单粗暴，不是解决问题的思路。仔细分析一下，可以有 2 种解决办法（思路就是避免序列化）：</p><p>1、如果在 Function 里面非要用到 JavaSparkContext 对象，那就把 JavaSparkContext 对象设置为全局静态的 Java 属性（使用 static 关键字），那么在哪里都可以调用它了，而无需担心序列化的问题（静态属性可以避免从 Driver 端发送到 Executor 端，从而避免了序列化过程）；</p><p>2、对于 Function 不要使用内部匿名类，这样必然需要序列化 Function 对象，同时也必然需要序列化 Function 对象用到的 JavaSparkContext 对象，其实可以把 Function 类定义为内部静态类，就可以避免序列化了。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结 </h1><p>1、出现这种错误，不要想当然地认为就是某种原因造成的，而要先看详细日志，否则会走弯路，浪费一些时间（虽然最终也能解决问题）；</p><p>2、有时候状态不好，晕乎乎的，找问题又慢又低效，此时应该休息一下，等头脑清醒了再继续找问题，否则可能事倍功半，而且影响心情。</p><p> 参考：<a href="https://stackoverflow.com/questions/27706813/javasparkcontext-not-serializable" target="_blank" rel="noopener">https://stackoverflow.com/questions/27706813/javasparkcontext-not-serializable</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天更新代码，对 Spark 里面的 RDD 随便增加了一个 Function，结果遇到了序列化（Serializable）的问题，这个不是普通的自定义类不能序列化问题，而是 JavaSparkContext 的用法问题，由于小看了这个问题，多花了一点时间解决问题，本文就记录下这一过程。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="Spark序列化" scheme="https://www.playpi.org/tags/Spark%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="serializable" scheme="https://www.playpi.org/tags/serializable/"/>
    
  </entry>
  
  <entry>
    <title>微博 url mid 相互转换算法实现 - Java 版本</title>
    <link href="https://www.playpi.org/2018122001.html"/>
    <id>https://www.playpi.org/2018122001.html</id>
    <published>2018-12-20T15:29:13.000Z</published>
    <updated>2018-12-20T15:29:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p> 对微博数据有了解的人都知道，一条微博内容对应有唯一的微博 url，同时对微博官方来说，又会生成一个 mid，mid 就是一条微博的唯一标识（就像 uid 是微博用户的唯一标识一样），也类似于人的身份证号。其实，微博 url 里面有一串看起来无意义的字符（由字母、数字组成，6-8 个字符长度），可以和 mid 互相转换，本文就根据理论以及 Java 版本的实现，讲解微博 url 与 mid 的互相转换过程。</p><a id="more"></a><p> 待整理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;对微博数据有了解的人都知道，一条微博内容对应有唯一的微博 url，同时对微博官方来说，又会生成一个 mid，mid 就是一条微博的唯一标识（就像 uid 是微博用户的唯一标识一样），也类似于人的身份证号。其实，微博 url 里面有一串看起来无意义的字符（由字母、数字组成，6-8 个字符长度），可以和 mid 互相转换，本文就根据理论以及 Java 版本的实现，讲解微博 url 与 mid 的互相转换过程。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="微博url" scheme="https://www.playpi.org/tags/%E5%BE%AE%E5%8D%9Aurl/"/>
    
      <category term="微博mid" scheme="https://www.playpi.org/tags/%E5%BE%AE%E5%8D%9Amid/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中字符串截取方法总结</title>
    <link href="https://www.playpi.org/2018121901.html"/>
    <id>https://www.playpi.org/2018121901.html</id>
    <published>2018-12-18T16:31:19.000Z</published>
    <updated>2018-12-18T16:31:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>最近在处理数据的时候，用到了 JavaScript 编程语言，通过绕弯路来解决 ETL 处理的逻辑，其中就用到了字符串的截取方法，查 JavaScript 的文档看到了 3 个方法，被绕的有点晕，本文就总结一下 JavaScript 中字符串截取的方法。</p><a id="more"></a><h1 id="开篇"><a href="# 开篇" class="headerlink" title="开篇"></a>开篇 </h1><p> 首先声明，JavaScript 中对方法名字的大小写是敏感的，该是小写就是小写，该是大写就是大写。</p><h1 id="substring- 方法"><a href="#substring- 方法" class="headerlink" title="substring() 方法"></a>substring() 方法 </h1><h2 id="定义和用法"><a href="# 定义和用法" class="headerlink" title="定义和用法"></a> 定义和用法 </h2><blockquote><p>substring() 方法用于截取字符串中介于两个指定下标之间的字符</p></blockquote><h2 id="语法"><a href="# 语法" class="headerlink" title="语法"></a> 语法 </h2><blockquote><p>stringObject.substring(start, stop)</p></blockquote><p> 上述参数解释：</p><table><thead><tr><th style="text-align:center">参数名 </th><th style="text-align:center"> 解释说明 </th></tr></thead><tbody><tr><td style="text-align:center">start</td><td style="text-align:center"> 必须，一个整数（是负数则被自动置为 0），要截取的子串的第一个字符在 stringObject 中的位置 </td></tr><tr><td style="text-align:center">end</td><td style="text-align:center"> 可选（如果省略该参数，则被默认为字符串长度），一个整数（是负数则被自动置为 0），比要截取的子串的最后一个字符在 stringObject 中的位置多 1</td></tr></tbody></table><h2 id="返回值"><a href="# 返回值" class="headerlink" title="返回值"></a>返回值 </h2><p> 一个全新的字符串，其实就是 stringObject 的一个子字符串，其内容是从 start 到 stop-1 的所有字符，其长度为 stop 减 start。</p><h2 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a>注意事项 </h2><p>1、substring() 方法返回的子字符串包括 start 处的字符，但是不包括 stop 处的字符，这一点可能很多人会迷惑，其实很多编程语言都是这个逻辑；</p><p>2、如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串，不是 null，也不是 undefined）；</p><p>3、如果 start 比 stop 大，那么该方法在截取子串之前会先交换这两个参数，这就会导致参数的顺序不影响截取的结果了；</p><p>4、参数理论上不能出现负数（在本方法中无特殊意义，在其它方法中就有特殊意义了），如果有，那么在截取子串之前会被置为 0。</p><h2 id="举例说明"><a href="# 举例说明" class="headerlink" title="举例说明"></a> 举例说明 </h2><p><strong> 例子 1（从下标 3 截取到字符串最后）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substring(<span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 10 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-world!</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 2（从下标 3 截取到下标 8）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substring(<span class="number">3</span>, <span class="number">8</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 5 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 3（从下标 3 截取到下标 8，但是参数位置反了）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substring(<span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 5 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 4（参数为负数，从下标 0 截取到下标 3）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substring(<span class="number">-1</span>, <span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 3 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hel</span><br></pre></td></tr></table></figure><p></p><h1 id="substr- 方法"><a href="#substr- 方法" class="headerlink" title="substr() 方法"></a>substr() 方法 </h1><h2 id="定义和用法 -1"><a href="# 定义和用法 -1" class="headerlink" title="定义和用法"></a> 定义和用法 </h2><blockquote><p>substr() 方法可在字符串中截取从 start 下标开始的指定长度的子串</p></blockquote><h2 id="语法 -1"><a href="# 语法 -1" class="headerlink" title="语法"></a> 语法 </h2><blockquote><p>stringObject.substr(start, length)</p></blockquote><p> 上述参数解释：</p><table><thead><tr><th style="text-align:center">参数名 </th><th style="text-align:center"> 解释说明 </th></tr></thead><tbody><tr><td style="text-align:center">start</td><td style="text-align:center"> 必须，必须是数值（0、正数、负数都可以），表示要截取的子串的起始下标。如果是负数，那么该参数声明的是从字符串的尾部开始计算的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。（参数为负数也可以理解成字符串长度加负数之和即为起始下标）</td></tr><tr><td style="text-align:center">length</td><td style="text-align:center">可选（如果省略该参数，那么默认为从 start 开始一直到 stringObject 的结尾对应的长度），必须是数值（0、正数、负数都可以）。</td></tr></tbody></table><h2 id="返回值 -1"><a href="# 返回值 -1" class="headerlink" title="返回值"></a>返回值 </h2><p> 一个全新的字符串，包含从 stringObject 的 start（包括 start 所指的字符）下标开始的 length 个字符。如果没有指定 length，那么返回的字符串包含从 start 到 stringObject 的结尾的字符。如果 length 指定为负数或者 0，那么返回空串。如果 length 指定为远远大于 stringObject 长度的正数，那么返回的字符串包含从 start 到 stringObject 的结尾的字符。</p><h2 id="注意事项 -1"><a href="# 注意事项 -1" class="headerlink" title="注意事项"></a>注意事项 </h2><p>1、start 参数为负数是有特殊含义的；</p><p>2、如果 length 指定为负数或者 0，那么返回空串（即长度为 0 的字符串，不是 null，也不是 undefined）；</p><p>3、ECMAscript 没有对该方法进行标准化，因此不建议使用它。</p><h2 id="举例说明 -1"><a href="# 举例说明 -1" class="headerlink" title="举例说明"></a> 举例说明 </h2><p><strong> 例子 1（从下标 3 截取到字符串最后）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substr(<span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 9 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-world!</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 2（从下标 3 截取长度为 5 的子串）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substr(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 5 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 3（从下标 3 截取长度为 - 5 的子串，返回空串）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substr(<span class="number">3</span>, <span class="number">-5</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（返回空串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p><strong>例子 4（start 参数为负数，即从字符串倒数第 5 个位置截取长度为 3 的子串）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substr(<span class="number">-5</span>, <span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 3 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orl</span><br></pre></td></tr></table></figure><p></p><h1 id="slice- 方法"><a href="#slice- 方法" class="headerlink" title="slice() 方法"></a>slice() 方法 </h1><h2 id="定义和用法 -2"><a href="# 定义和用法 -2" class="headerlink" title="定义和用法"></a> 定义和用法 </h2><blockquote><p>slice() 方法用于截取字符串中介于两个指定下标之间的字符，与 substring() 方法的功能类似</p></blockquote><h2 id="语法 -2"><a href="# 语法 -2" class="headerlink" title="语法"></a> 语法 </h2><blockquote><p>stringObject.slice(start, end)</p></blockquote><p> 上述参数解释：</p><table><thead><tr><th style="text-align:center">参数名 </th><th style="text-align:center"> 解释说明 </th></tr></thead><tbody><tr><td style="text-align:center">start</td><td style="text-align:center"> 必须，一个整数（0、正数、负数，负数有特殊含义），要截取的子串的第一个字符在 stringObject 中的位置。如果是负数，那么该参数声明的是从字符串的尾部开始计算的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。（参数为负数也可以理解成字符串长度加负数之和即为起始下标）</td></tr><tr><td style="text-align:center">end</td><td style="text-align:center">可选（如果省略该参数，则被默认为字符串长度），一个整数（负数含义与 start 相同），比要截取的子串的最后一个字符在 stringObject 中的位置多 1</td></tr></tbody></table><h2 id="返回值 -2"><a href="# 返回值 -2" class="headerlink" title="返回值"></a>返回值 </h2><p> 一个全新的字符串，其实就是 stringObject 的一个子字符串，其内容是从 start 到 stop-1 的所有字符，其长度为 stop 减 start。</p><h2 id="注意事项 -2"><a href="# 注意事项 -2" class="headerlink" title="注意事项"></a>注意事项 </h2><p>1、slice() 方法返回的子字符串包括 start 处的字符，但是不包括 stop 处的字符，这一点可能很多人会迷惑，其实很多编程语言都是这个逻辑；</p><p>2、如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串，不是 null，也不是 undefined）；</p><p>3、参数可以出现负数（比 substring() 方法灵活多了）。</p><h2 id="举例说明 -2"><a href="# 举例说明 -2" class="headerlink" title="举例说明"></a> 举例说明 </h2><p><strong> 例子 1（从下标 3 截取到字符串最后）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 9 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-world!</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 2（从下标 3 截取到下标 8）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">3</span>, <span class="number">8</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 5 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 3（从下标 3 截取到下标 8，但是参数使用负数，从下标 - 9 截取到下标 - 4）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">-9</span>, <span class="number">-4</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 5 的子串，（-4）-（-9）=5）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 4（从下标 3 截取到下标 2）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出返回空串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近在处理数据的时候，用到了 JavaScript 编程语言，通过绕弯路来解决 ETL 处理的逻辑，其中就用到了字符串的截取方法，查 JavaScript 的文档看到了 3 个方法，被绕的有点晕，本文就总结一下 JavaScript 中字符串截取的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="JavaScript" scheme="https://www.playpi.org/tags/JavaScript/"/>
    
      <category term="字符串截取" scheme="https://www.playpi.org/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>西红柿疙瘩汤做法总结</title>
    <link href="https://www.playpi.org/2018121601.html"/>
    <id>https://www.playpi.org/2018121601.html</id>
    <published>2018-12-15T17:57:00.000Z</published>
    <updated>2018-12-16T17:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>西红柿疙瘩汤，是一道做法非常简单的主食与配菜混为一起的菜品，适合在寒冷的冬天食用，吃一碗热乎乎的，非常暖胃，我知道在中原地区（河南、安徽北部）都有这个做法。本文就讲述西红柿疙瘩汤的做法总结。</p><a id="more"></a><h1 id="食材准备"><a href="# 食材准备" class="headerlink" title="食材准备"></a>食材准备 </h1><p> 以下的食材份量大约 2 人份：</p><ul><li>黄心乌菜一颗（实在没有使用其它青菜也可以）</li><li>西红柿一颗（粉的最好，与脆的对立）</li><li>鸡蛋 2 颗 </li><li> 面粉 100 克 </li><li> 小葱、香菜各 2 棵 </li><li> 调味料（食用盐、芝麻油）</li></ul><h1 id="制作步骤"><a href="# 制作步骤" class="headerlink" title="制作步骤"></a>制作步骤 </h1><p> 从开火到关火预计耗时 15-20 分钟：</p><p>0、葱花香菜段；<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5zv7hnmj229s29s4qq.jpg" alt="葱花香菜段" title="葱花香菜段"></p><p>1、西红柿去皮，划十字刀花，放入热水中烫 1 分钟左右，取出直接去皮，不去皮也行，但是会影响口感，去皮后切丁，切小一点，放入碗中备用；</p><p>粉粉的西红柿 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5kxue8tj229s29se81.jpg" alt="一颗西红柿" title="一颗西红柿"></p><p> 十字花刀 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwaageagj229s29shdt.jpg" alt="十字花刀" title="十字花刀"></p><p> 开水烫 1 分钟（30 秒翻身一次），轻易去皮 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwbgrggsj229s29shdt.jpg" alt="开水烫 1 分钟" title="开水烫 1 分钟"></p><p> 西红柿去皮 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwc37dlbj229s29sb2a.jpg" alt="西红柿去皮" title="西红柿去皮"></p><p> 西红柿切丁 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwcm3w8nj229s29s4qq.jpg" alt="西红柿切丁" title="西红柿切丁"></p><p>2、准备黄心乌菜，洗干净，随便切（手撕也行，无所谓），切成条状或者小块状，别太大就行；<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyp2f1kua2j229s29skjl.jpg" alt="黄心乌长这样" title="黄心乌长这样"></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5m1xtc6j229s29su0x.jpg" alt="黄心乌切碎" title="黄心乌切碎"></p><p>3、面粉放入大碗中，放在水龙头下，让水一滴一滴滴下来，迅速搅拌面粉，很快就可以做成面粒；<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5otcr3mj229s29s7wi.jpg" alt="面粒长这样" title="面粒长这样"></p><p>4、鸡蛋打入碗中，搅拌均匀备用；</p><p>5、锅烧热，倒入油，炒制西红柿丁，中小火炒制 3-5 分钟，此时西红柿的状态就是一半是糊状，一半是小颗粒，混合在一起，倒入开水（注意量的控制，比想象的多倒一点，面粒会吸收大量水分的），大火烧开；</p><p> 西红柿丁炒制 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwi298lzj229s29snpe.jpg" alt="西红柿丁炒制" title="西红柿丁炒制"></p><p> 加开水，煮开 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwinvlclj229s29s4qq.jpg" alt="加开水" title="加开水"></p><p>6、烧开后放入面粒，大火煮 5 分钟，面粒基本熟透，汤变得浓稠，放入青菜，中火继续煮 1 分钟左右，鸡蛋液慢慢淋入锅中，搅拌，放入食用盐，中火继续煮 2 分钟；</p><p> 放入面粒，继续煮 5 分钟 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwjke2u4j229s29s7wi.jpg" alt="放入面粒" title="放入面粒"></p><p>7、开锅，放入芝麻油、香菜段，葱花，搅拌十几秒，关火。</p><p> 一锅 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy94yo4wibj229s29snpd.jpg" alt="一锅" title="一锅"></p><p> 一碗 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5xkeysqj229s29shdt.jpg" alt="一碗" title="一碗"></p><p> 做完顺便又加了 2 个菜：<br>花菜回锅肉 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya60u5iacj229s29se81.jpg" alt="花菜回锅肉" title="花菜回锅肉"></p><p> 辣椒回锅肉 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya61058ppj229s29su0x.jpg" alt="辣椒回锅肉" title="辣椒回锅肉"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项 </h1><p>1、青菜最好选择黄心乌，因为我一直吃的都是这种，黄心乌这种青菜一般在沿淮地区才播种，因为它比较耐寒，在秋季播种，在冬天收割，一般北方的冬天也看不到其它青菜可以生长了；</p><p>2、条件允许的话，可以放一点酱肉之类的肉粒进去，更能增加食欲；</p><p>3、做面粒的时候切记不要直接倒水搅拌，这样是做不成的一粒一粒的效果的，只能用水滴进去然后迅速搅拌，使水滴周围裹上面粉形成一粒，很快就全部都是面粒了，而且很均匀，另外，做好面粒后要立马使用，不要提前做好放那里，因为放久了（10 分钟都不行）面粒会粘连在一起，实在要放的话再多加点面粉进去，让面粒之间隔开；</p><p>4、西红柿最好选择粉的，就是那种吃起来很柔绵的，更容易做成均匀的汤；</p><p>5、如果在煮的过程中发现有点粘锅，那是因为水少了，面太多了，这时候用汤勺试着加 1-2 勺水进去，再搅拌一下，如果还是粘锅再加 1-2 勺，千万不要一下子加很多水，面汤最好的状态就是不粘锅但是又很浓稠；</p><p>6、做回锅肉，肉要煮到什么程度才能回锅，简单的判断方法就是筷子可以轻易穿透肉，一般要煮 20 分钟以上。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya63x2errj229s29snpd.jpg" alt="肉回锅之前" title="肉回锅之前"></p><h1 id="补充说明"><a href="# 补充说明" class="headerlink" title="补充说明"></a> 补充说明</h1><p>2018 年 12 月 23 日，广州突然降温，降到 17 度左右（前一天的冬至还 25 度呢，短袖都穿起来了），天气冷了，于是又煮了一锅。可惜这次没买到香菜，没买到黄心乌菜，也没买到酱肉，凑活着吃。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyiauqznd7j229s29sx6p.jpg" alt="2018 年 12 月 23 日又煮了一锅" title="2018 年 12 月 23 日又煮了一锅"></p><p>2018 年 12 月 30 日，广州的温度降到了个位数，最低 5 度，实在是冷。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwm9ud6ij229s29shdt.jpg" alt="2018 年 12 月 31 日" title="2018 年 12 月 31 日"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;西红柿疙瘩汤，是一道做法非常简单的主食与配菜混为一起的菜品，适合在寒冷的冬天食用，吃一碗热乎乎的，非常暖胃，我知道在中原地区（河南、安徽北部）都有这个做法。本文就讲述西红柿疙瘩汤的做法总结。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="西红柿疙瘩汤" scheme="https://www.playpi.org/tags/%E8%A5%BF%E7%BA%A2%E6%9F%BF%E7%96%99%E7%98%A9%E6%B1%A4/"/>
    
      <category term="疙瘩汤" scheme="https://www.playpi.org/tags/%E7%96%99%E7%98%A9%E6%B1%A4/"/>
    
  </entry>
  
  <entry>
    <title>常用正则表达式列表</title>
    <link href="https://www.playpi.org/2018121401.html"/>
    <id>https://www.playpi.org/2018121401.html</id>
    <published>2018-12-13T18:18:48.000Z</published>
    <updated>2018-12-14T18:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p> 正则表达式是一种表达式语句。本文记录一些常用的正则表达式，以便使用。</p><a id="more"></a><p> 待整理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;正则表达式是一种表达式语句。本文记录一些常用的正则表达式，以便使用。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="正则表达式" scheme="https://www.playpi.org/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>与微博内容分析相关的正则表达式</title>
    <link href="https://www.playpi.org/2018121101.html"/>
    <id>https://www.playpi.org/2018121101.html</id>
    <published>2018-12-11T14:16:19.000Z</published>
    <updated>2018-12-11T14:16:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>在分析微博内容时，常常需要进行特殊内容去除与抽取，例如抽取微博话题、微博昵称、微博表情、微博短链接、网址长链接等等。本文依据实际使用情况，记录下了与微博内容分析相关的正则表达式，以便查用。</p><a id="more"></a><h1 id="微博表情"><a href="# 微博表情" class="headerlink" title="微博表情"></a>微博表情 </h1><p> 表情是使用左右中括号包含的文本（在实际使用时，显示的是 emoji 表情，不是单纯的字符），例如：[爱心]、[微笑]、[笑哭]，分别表示：:heart:、❤️、:smile:、😊、:joy:、😂</p><p>参考：<a href="https://emojipedia.org" target="_blank" rel="noopener">emoji 百科 </a> 。</p><p> 如果在微博内容中抽取表情，使用正则表达式（1-7 个字符，中文和字母，不排除有的新的表情出现，导致字符更长）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[[\u4e00-\u9fa5A-Za-z]&#123;1,7&#125;\]</span><br></pre></td></tr></table></figure><p>不同字符长度的表情举例（我用了 10 分钟把微博表情全部浏览了一遍，发现 [小黄人] 系列、[文明遛狗]是最近刚刚发布出来的）：[耶]、[来]、[跪了]、[ok]、[中国赞]、[紫金草]、[doge]、[文明遛狗]、[给你小心心]、[小黄人微笑]、[弗莱见钱眼开]、[小黄人剪刀手]、[哆啦 A 梦害怕]、[带着微博去旅行]。</p><h1 id="微博昵称"><a href="# 微博昵称" class="headerlink" title="微博昵称"></a>微博昵称 </h1><p> 微博昵称是用户填写的昵称，并且在转发或者提到时，会增加 @ 前缀，例如有一个 playpi 微博用户，在实际微博内容中，会以 @playpi 的形式出现，当然，微博昵称的可用字符是有限制的，不是任意字符都行，长度也是有限制的，最少 4 个字符，最多 30 个字符。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy6r1bwv0xj20mi082dfy.jpg" alt="微博昵称字符限制" title="微博昵称字符限制"></p><p>以及微博客服的回答：<a href="https://www.weibo.com/2016713117/FCf87jJZt?type=comment#_rnd1544860586591" target="_blank" rel="noopener">微博客服微博 </a> 。</p><p> 但是这个规则是针对修改昵称的限制，如果有些帐号是以前注册的，并且昵称在微博官方限制以前没有修改过，那么就有可能是 2 个字符，3 个字符，例如各个明星、作家、自媒体的个人微博：@阑夕、@王力宏、@韩寒 等等。</p><p>如果在微博内容中抽取昵称，使用正则表达式（中文、数字、字母、横线、下划线的组合，2-30 个字符）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@[\u4e00-\u9fa5A-Z0-9a-z_-]&#123;2,30&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="微博话题"><a href="# 微博话题" class="headerlink" title="微博话题"></a>微博话题 </h1><p> 话题是微博定义的一种概念，可以用来标识热门事件、重大新闻、明星、综艺节目等等，发布规则就是使用 2 个 #符号包含话题内容（例如：# 创造 101#），话题即生成，微博还专门有一个实时话题榜单。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy6ro4qztbj20v40q2doc.jpg" alt="微博话题榜" title="微博话题榜"></p><p>如果在微博内容中抽取话题，使用正则表达式（2 个 #号之间，非指定的符号，长度在 1-49 之间）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[^@&lt;&gt;#"&amp;'\r\n\t]&#123;1,49&#125;#</span></span><br></pre></td></tr></table></figure><p></p><p>注意，我找到 2014 年的 <a href="https://iask.sina.com.cn/b/wnINuLfme5.html" target="_blank" rel="noopener">一篇旧帖子 </a>，微博小秘书评论说话题不能包含指定的几个特殊字符，还有内容长度限制，但是我在微博页面试了一下，这些特殊字符都可以使用（但是生成的话题页面，&lt; 字符、&gt; 字符被转成了 html 字符实体，换行符后的内容被截断，@符号、’单引号、” 双引号被自动替换掉，# 符号根本无法发布，空格符可以正常使用），而且长度限制是 1-49 个字符（中英文、标点都算 1 个字符）。但是为了话题内容的传播，还是使用通俗易懂的中文或者字母比较好。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy6s5061rxj20gv03uwei.jpg" alt="话题测试发布" title="话题测试发布"></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy6s42ecfzj20k904l0sq.jpg" alt="话题测试结果" title="话题测试结果"></p><h1 id="微博短链接"><a href="# 微博短链接" class="headerlink" title="微博短链接"></a> 微博短链接 </h1><p> 微博短链接是微博官方提供的网址压缩功能产生的一种只包含少量字符的短网址，例如：<a href="http://finance.sina.com.cn" target="_blank" rel="noopener">http://finance.sina.com.cn</a> ，压缩后为：<a href="http://t.cn/RnM1Uti" target="_blank" rel="noopener">http://t.cn/RnM1Uti</a> 。这样的话，发微博时链接占用更少的字符长度。如果发微博时，内容中带了链接，例如视频地址、淘宝店地址，会被自动压缩为短链接。微博短链接可以直接在浏览器中访问，会被微博的网址解析服务器转换为原来的正常链接再访问。</p><p>如果在微博内容中抽取短链接，使用正则表达式（我这里只是抽取 t.cn 域名的，6-8 个字母、数字）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https&#123;0,1&#125;://t.cn/[A-Z0-9a-z]&#123;6,8&#125;[/]&#123;0,1&#125;#</span></span><br></pre></td></tr></table></figure><p></p><p>参考：<br>微博开放平台说明：<a href="http://open.weibo.com/wiki/2/short_url/shorten" target="_blank" rel="noopener">http://open.weibo.com/wiki/2/short_url/shorten</a> ；<br>免费在线短链接转换工具：<a href="http://dwz.wailian.work" target="_blank" rel="noopener">http://dwz.wailian.work</a> 。</p><h1 id="网址长链接"><a href="# 网址长链接" class="headerlink" title="网址长链接"></a>网址长链接 </h1><p> 网址长链接也就是普通的网址，有多种可能性。</p><p>如果在微博内容中抽取网址长链接，使用正则表达式（我这里只考虑 http、https、ftp、file 协议）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(https?|ftp|file)://[-A-Za-z0-9+&amp;@<span class="comment">#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|]</span></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在分析微博内容时，常常需要进行特殊内容去除与抽取，例如抽取微博话题、微博昵称、微博表情、微博短链接、网址长链接等等。本文依据实际使用情况，记录下了与微博内容分析相关的正则表达式，以便查用。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="正则表达式" scheme="https://www.playpi.org/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="微博内容" scheme="https://www.playpi.org/tags/%E5%BE%AE%E5%8D%9A%E5%86%85%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>Win10 默认程序设置无效</title>
    <link href="https://www.playpi.org/2018120901.html"/>
    <id>https://www.playpi.org/2018120901.html</id>
    <published>2018-12-09T09:21:14.000Z</published>
    <updated>2018-12-09T09:21:14.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>装了 Windows 10 系统（教育版本），用了将近 3 个月了，最近发现一个诡异的现象，我的默认程序设置每次都只是设置后生效一段时间，例如视频播放器、音乐播放器，我分别设置成了迅雷看看、网易云音乐，用了半天之后，发现又变成了 Window 10 系统自带的视频播放器。这个现象也不是重启之后才出现的，而是平时用着用着就会出现，很莫名其妙。后来查阅资料发现这是一个普遍的现象，这个问题的根本原因是 Windows 10 自带的 bug，通常导致这个 bug 出现的原因是开启了系统的自动更新。</p><a id="more"></a><h1 id="现象"><a href="# 现象" class="headerlink" title="现象"></a>现象 </h1><p> 在 Windows 10 系统（没有打对应补丁的）中，如果开启了系统自动更新，就会触发相应的 bug：默认程序会被系统更改回系统自带的程序，例如视频播放器、音乐播放器等等。这个问题的原因用官方标识来指定就是由于 <strong>KB3135173</strong> 所致，同时这个 bug 已经有对应的补丁了。</p><p>按照系统设置，把某些默认程序改为自己需要的，我这里把视频播放器改为迅雷影音，设置特定格式的文件（.mkv，.mp4 等等）使用迅雷影音打开。</p><p>在桌面右下角打开 <strong>所有设置 </strong>选项 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0n2j57csj20bq0ahmz4.jpg" alt="所有设置" title="所有设置"></p><p> 在 Windows 设置中，选择 <strong>应用 </strong>选项 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0nlh83ifj20xc0pwdgf.jpg" alt="选择应用" title="选择应用"></p><p> 选择默认应用，设置视频播放器为 <strong>迅雷影音 </strong><br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0nnjkzdcj20xc0pw445.jpg" alt="设置视频播放器为迅雷影音" title="设置视频播放器为迅雷影音"></p><p> 上述的设置步骤实际上还不够，因为视频类型有很多种，还需要进一步指定每种类型的默认播放器，在默认应用下方有一个 <strong>按文件类型指定默认应用 </strong>选项 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0nqc3hdtj20xc0pw43w.jpg" alt="按文件类型指定默认应用" title="按文件类型指定默认应用"></p><p> 我这里特别关注 <strong>.mkv</strong>、<strong>.mp4</strong> 这 2 种格式的文件，默认应用设置为 <strong>迅雷影音 </strong><br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0nusxmrxj20md0pw0tu.jpg" alt="单独设置 2 种文件类型" title="单独设置 2 种文件类型"></p><p> 上述内容设置完成，就可以使用了，但是用不了多久，系统时不时就弹出提示框，通知默认程序重置，然后又被设置为系统内置的应用了 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0mr10t67j20bh0h977t.jpg" alt="弹出提示框" title="弹出提示框"></p><h1 id="解决方案"><a href="# 解决方案" class="headerlink" title="解决方案"></a> 解决方案 </h1><h2 id="不推荐方案"><a href="# 不推荐方案" class="headerlink" title="不推荐方案"></a> 不推荐方案 </h2><p> 更改注册表、使用命令行卸载系统默认程序，这些方案是可行的，但是对于普通用户来说太麻烦了一点，根本不懂得如何操作，而且解决方法太粗暴了，当然喜欢折腾的人是可以选择的。</p><p>以下给出几个命令行示例（需要在管理员模式下执行，打开 Windows PowerShell 的时候选择有管理员的那个）：</p><p>卸载 “电影和电视” 应用（星号表示通配符，下同）<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-appxpackage *zunevideo* | remove-appxpackage</span><br></pre></td></tr></table></figure><p></p><p>卸载 “Groove 音乐” 应用 <br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-appxpackage *zunemusic* | remove-appxpackage</span><br></pre></td></tr></table></figure><p></p><p> 卸载 “照片” 应用 <br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-appxpackage *photos* | remove-appxpackage</span><br></pre></td></tr></table></figure><p></p><p> 如果还想恢复已经卸载的系统自带应用，可以使用以下命令（重装所有系统内置的应用）<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-AppxPacKage -allusers | foreach &#123;Add-AppxPacKage -register <span class="string">"<span class="variable">$($_.InstallLocation)</span>appxmanifest.xml"</span> -DisableDevelopmentMode&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="推荐直接打补丁（更新系统）"><a href="# 推荐直接打补丁（更新系统）" class="headerlink" title="推荐直接打补丁（更新系统）"></a>推荐直接打补丁（更新系统）</h2><p>这个方法很简单，容易操作，直接在系统更新里面更新即可，确保要能更新到 <strong>KB3135173</strong> 这个补丁才行（或者更高版本的补丁）。</p><p>我这里是已经更新完成的，等待重启，补丁标识是 <strong>KB4469342</strong>。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0n75u4o3j20xc0pw442.jpg" alt="系统更新" title="系统更新"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;装了 Windows 10 系统（教育版本），用了将近 3 个月了，最近发现一个诡异的现象，我的默认程序设置每次都只是设置后生效一段时间，例如视频播放器、音乐播放器，我分别设置成了迅雷看看、网易云音乐，用了半天之后，发现又变成了 Window 10 系统自带的视频播放器。这个现象也不是重启之后才出现的，而是平时用着用着就会出现，很莫名其妙。后来查阅资料发现这是一个普遍的现象，这个问题的根本原因是 Windows 10 自带的 bug，通常导致这个 bug 出现的原因是开启了系统的自动更新。&lt;/p&gt;
    
    </summary>
    
      <category term="知识改变生活" scheme="https://www.playpi.org/categories/knowledge-for-life/"/>
    
    
      <category term="Win10" scheme="https://www.playpi.org/tags/Win10/"/>
    
      <category term="默认程序设置" scheme="https://www.playpi.org/tags/%E9%BB%98%E8%AE%A4%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Spark on Yarn 查看日志</title>
    <link href="https://www.playpi.org/2018120702.html"/>
    <id>https://www.playpi.org/2018120702.html</id>
    <published>2018-12-06T18:06:20.000Z</published>
    <updated>2018-12-06T18:06:20.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p> 一直一来都是直接在 Yarn 的 UI 界面上面查看 Spark 任务的日志的，感觉看少量的内容还勉强可以，但是如果内容很多，浏览器就没法看了，更没法分析。本文讲述如何使用 Yarn 自带的命令在终端查看 Spark 任务的日志，也可以拷贝出日志文件，便于分析。</p><a id="more"></a><p>1、查看某个 Spark 任务的日志，使用 logs 入口：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn logs -applicationId application_1542870632001_26426</span><br></pre></td></tr></table></figure><p></p><p> 如果日志非常多，直接看会导致刷屏，看不到有用的信息，所以可以重定向到文件中，再查看文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn logs -applicationId application_1542870632001_26426 &gt; ./application.log</span><br></pre></td></tr></table></figure><p></p><p>2、查看某个 Spark 任务的状态，使用 application 入口：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn application -status application_1542870632001_26426</span><br></pre></td></tr></table></figure><p></p><p> 同时也可以看到队列、任务类型、日志链接等详细信息 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxxloh9spej20uo0auaas.jpg" alt="查看状态" title="查看状态"></p><p>3、kill 掉某个 Spark 任务，有时候是直接在 Driver 端 kill 掉进程，然后 Yarn 的 Spark 任务也会随之失败，但是这种做法是不妥的。其实 kill 掉 Spark 任务有自己的命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn application -<span class="built_in">kill</span> application_1542870632001_26426</span><br></pre></td></tr></table></figure><p></p><p>4、需要注意的是，步骤 1 中去查看日志，要确保当前 HADOOP_USER_NAME 用户是提交 Spark 任务的用户，否则是看不到日志的，因为日志是放在 HDFS 对应的目录中的，其中路径中会有用户名。此外，步骤 1 中的日志要等 Spark 任务运行完了才能看到，否则日志文件不存在（还没收集到 HDFS 中）。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;一直一来都是直接在 Yarn 的 UI 界面上面查看 Spark 任务的日志的，感觉看少量的内容还勉强可以，但是如果内容很多，浏览器就没法看了，更没法分析。本文讲述如何使用 Yarn 自带的命令在终端查看 Spark 任务的日志，也可以拷贝出日志文件，便于分析。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="Yarn" scheme="https://www.playpi.org/tags/Yarn/"/>
    
      <category term="日志查看" scheme="https://www.playpi.org/tags/%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B/"/>
    
  </entry>
  
  <entry>
    <title>煮鸡蛋做法总结</title>
    <link href="https://www.playpi.org/2018120301.html"/>
    <id>https://www.playpi.org/2018120301.html</id>
    <published>2018-12-02T18:30:45.000Z</published>
    <updated>2018-12-02T18:30:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>本文记录水煮鸡蛋的做法总结。</p><a id="more"></a><h1 id="介绍"><a href="# 介绍" class="headerlink" title="介绍"></a>介绍 </h1><p> 水煮鸡蛋是最常见的吃法之一，做法非常简单，直接将鸡蛋放入开水中煮熟即可。煮熟的鸡蛋营养丰富，水煮鸡蛋的营养可以 100% 被保留，是所有的鸡蛋做法中营养被保留的最好的一种。建议每天食用 1-2 个，因为过量的食用可能会导致营养不良，同时鸡蛋的营养并没有被身体吸收，相当于浪费了。</p><p>在生活当中，大家几乎每天早上都会吃煮鸡蛋，或者茶叶蛋，但是有一些人卖的煮鸡蛋不算成功的煮鸡蛋，因为剥皮的时候发现不好剥，蛋壳与蛋白紧紧粘在一起，吃起来可麻烦了，这是因为煮鸡蛋的做法错误，遗漏了重要的步骤。</p><h1 id="做法步骤"><a href="# 做法步骤" class="headerlink" title="做法步骤"></a>做法步骤 </h1><p>1、简单地清洗一下鸡蛋，因为鸡蛋的表面可能会有一些茅草、粪便之类的污垢，这是因为鸡蛋必须是原生的，存储、运输、销售过程都不能清洗，如果非要清洗，水会破坏表面的保护膜，放不了两天鸡蛋就坏了；</p><p>2、放在冷水中浸泡一会儿，1-2 分钟，这样做的目的是防止沸水煮的时候蛋壳破裂；</p><p>3、放入锅中，水的高度稍微没过鸡蛋，使用中火煮开水，不要使用大火，大火煮的速度太快，鸡蛋容易裂开，另外中火使水沸腾的时间会长一些，预热了鸡蛋，味道更香；</p><p>4、水沸腾后，改为小火，煮 7-8 分钟（如果继续使用中火，5 分钟左右即可）；</p><p>5、如果需要溏心蛋（蛋清凝固，蛋黄成稠液状，软嫩滑润），煮 5 分钟即可；</p><p>6、煮熟后不要立即捞出，等 1-2 分钟，然后才捞出，切记此时需要放入冷水中，浸泡 1-3 分钟，这一步骤的目的是保证鸡蛋容易剥开，避免蛋白和蛋壳粘在一起。</p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项</h1><p>1、煮鸡蛋前最好放入冷水中浸泡 1-2 分钟，防止煮的过程开裂；</p><p>2、注意控制火力和时间，鸡蛋不能煮太久，超过 10 分钟会有化学反应，导致营养流失；</p><p>3、煮熟后不要立即捞出，捞出后也要放在冷水中浸泡，防止蛋白和蛋壳粘在一起；</p><p>4、每天不要吃太多，1-2 个就够了；</p><p>5、如果想要保持蛋黄在中间，煮鸡蛋的过程中要适当搅拌让鸡蛋旋转。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本文记录水煮鸡蛋的做法总结。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="煮鸡蛋" scheme="https://www.playpi.org/tags/%E7%85%AE%E9%B8%A1%E8%9B%8B/"/>
    
  </entry>
  
  <entry>
    <title>一条正则表达式引发的惨案</title>
    <link href="https://www.playpi.org/2018120201.html"/>
    <id>https://www.playpi.org/2018120201.html</id>
    <published>2018-12-01T18:04:13.000Z</published>
    <updated>2018-12-07T18:04:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p> 本文讲述由于正则表达式引发的性能惨案，背景就是使用 Java 编程语言进行正则表达式匹配，由于正则表达式很复杂，再加上 Java 使用的是 NFA（非确定型有穷自动机）匹配引擎，导致匹配一条文本内容使用了十几个小时还没完成，一直卡住，同时线上环境的主机 CPU 使用率也居高不下（我猜的，因为我没有权限看）。</p><a id="more"></a><p> 整理中。</p><p> 参考：<br><a href="http://www.cnblogs.com/study-everyday/p/7426862.html" target="_blank" rel="noopener">http://www.cnblogs.com/study-everyday/p/7426862.html</a><br><a href="https://www.jianshu.com/p/5c2e893b8d5d" target="_blank" rel="noopener">https://www.jianshu.com/p/5c2e893b8d5d</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本文讲述由于正则表达式引发的性能惨案，背景就是使用 Java 编程语言进行正则表达式匹配，由于正则表达式很复杂，再加上 Java 使用的是 NFA（非确定型有穷自动机）匹配引擎，导致匹配一条文本内容使用了十几个小时还没完成，一直卡住，同时线上环境的主机 CPU 使用率也居高不下（我猜的，因为我没有权限看）。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="正则表达式" scheme="https://www.playpi.org/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="Java NFA" scheme="https://www.playpi.org/tags/Java-NFA/"/>
    
      <category term="非确定型有穷自动机" scheme="https://www.playpi.org/tags/%E9%9D%9E%E7%A1%AE%E5%AE%9A%E5%9E%8B%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="正则无限回溯" scheme="https://www.playpi.org/tags/%E6%AD%A3%E5%88%99%E6%97%A0%E9%99%90%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>jackson 包版本低导致 NoSuchMethodError</title>
    <link href="https://www.playpi.org/2018120101.html"/>
    <id>https://www.playpi.org/2018120101.html</id>
    <published>2018-11-30T18:02:03.000Z</published>
    <updated>2018-11-30T18:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>本文讲述 Java 项目由 Maven 包冲突或者版本不合适导致的运行时错误：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: com.fasterxml.jackson.databind.JavaType.isReferenceType()Z</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><h1 id="起因"><a href="# 起因" class="headerlink" title="起因"></a>起因 </h1><p> 今天在升级 Web 项目的相关接口，更新了所依赖的 SDk 版本，删除了一些旧代码，测试时发现某个功能不可用，直接抛出异常，异常是在运行时抛出的，编译、打包、部署都没有任何问题。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqmy8sggbj213t0eyq5s.jpg" alt="NoSuchMethodError 异常" title="NoSuchMethodError 异常"></p><p>我看到第一眼，就知道肯定是 Maven 依赖问题，要么是版本冲突（存在不同版本的 2 个相同依赖），要么是依赖版本不对（太高或者太低），但为了保险起见，我还是先检查了一下 Git 的提交记录，看看有没有对 pom.xml 配置文件做相关改动。检查后发现，除了一些业务逻辑的变动，以及无关 jackson 依赖的版本升级，没有其它对 pom.xml 文件的改动，由此可以断定，某个依赖的升级导致了此问题，问题原因找到了，接下来就是解决问题。</p><h1 id="解决办法"><a href="# 解决办法" class="headerlink" title="解决办法"></a>解决办法 </h1><h2 id="查看项目的 -Maven- 依赖树"><a href="# 查看项目的 -Maven- 依赖树" class="headerlink" title="查看项目的 Maven 依赖树"></a> 查看项目的 Maven 依赖树 </h2><p> 由于依赖太多，使用可视化的插件查看太繁杂，所以选择直接使用 maven 的 dependency 构件来生成文本，然后再搜索查看：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree &gt; tree.txt</span><br></pre></td></tr></table></figure><p></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqnq28eqmj20nb071jrm.jpg" alt="mvn 命令行脚本" title="mvn 命令行脚本"></p><p>在 tree.txt 文件中搜索 jackson，可以找到 jackson-databind 相关的依赖包，还有 jackson-annotations、jackson-core 这 2 个依赖包。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqob296i5j218a0q2whw.jpg" alt="jackson 依赖搜索" title="jackson 依赖搜索"></p><p>jackson-databind 的版本为 2.9.3<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqovrmijgj20vz0gg0ub.jpg" alt="jackson-databind 的版本" title="jackson-databind 的版本"></p><p>确定了使用的版本，接下来可以在 IDEA 里面搜索一下这个类，然后再找调用的方法，直接去查看源码，看看到底有没有这个方法。搜索 JavaType Java 类，注意包的路径，可能会有很多重名的类出现，我是用 Ctrl + Shift + T 的快捷键搜索，各位根据自己的快捷键设置进行搜索。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqoyomz3nj21ha0ketbp.jpg" alt="搜索 JavaType 类" title="JavaType"></p><p>然后进入类的源代码，搜索方法 isReferenceType，报错信息后面的大写的 Z，是 JNI 字段描述符，表示这个方法的返回值类型，Z 表示 Boolean 类型，我们搜索看看有没有这个方法。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqp3posd9j218h0l2dhd.jpg" alt="搜索方法 isReferenceType" title="搜索方法 isReferenceType"></p><p>我们发现连同名的方法都没有，更不用看返回值类型了，但是注意还是要去父类还有接口里面去搜索一下，保证都没有才是最终的没有。经过查找，没发现这个方法（主要原因是父类 ResolvedType 的版本太低，父类所在的 jackson-core 的版本只有 2.3.3，所以找不到这个方法），到这里就要准备升级 jackson-core 或者降级 jackson-databind 依赖了。</p><h2 id="去除多余依赖"><a href="# 去除多余依赖" class="headerlink" title="去除多余依赖"></a>去除多余依赖 </h2><p> 如果是检查到存在依赖冲突的情况，一般是高低版本之间的冲突（最多的情况是多级传递依赖引起的），然后 Maven 编译打包时会全部打进业务的包。</p><p>1、导致运行时程序不知道选择哪一个，于是抛出 NoSuchMethodError 异常，此时根据需要，移除多余的依赖包即可；</p><p>2、步骤 1 操作后，还是一种可能是虽然只存在一个版本，但是由于版本太新或者太旧，无法兼容所有的调用，导致多处需要调用这个依赖包的地方总会有某个地方出现 NoSuchMethodError 异常。此时就比较麻烦，如果能找到一个合适版本的依赖包，兼容所有的调用，当然是好的；或者升级调用处对应的接口版本；如果还是无法解决，就只能通过 Shade 构件解决问题了，此处就不赘述了。</p><p>经过检查，我这里遇到的就是步骤 2 的情况，虽然只剩下一个依赖包，但是版本太低或者太高，导致调用时找不到 isReferenceType 方法，类其实是存在的，所以要采用升级或者降级的方式。</p><h2 id="升级降级依赖"><a href="# 升级降级依赖" class="headerlink" title="升级降级依赖"></a>升级降级依赖 </h2><p> 如果是检查到只有一个依赖，并没有冲突的情况，就容易了，直接找到最稳定的版本或者适合使用的旧版本，提取依赖的坐标，配置到 pom.xml 文件中即可。</p><p>经过检查，我这里遇到的就是这种情况，去 Maven 私服中搜索 jackson，找到合适的版本（自己根据需要选择，我这里选择 jackson-databind 的 2.9.7 版本，然后 jackson-core 也指定 2.9.7 版本，就可以了，然后又查资料也发现这个方法是 2.6.0 版本之后才开始加上的），配置到 pom.xml 文件中即可。</p><p>私服搜索 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqnn8b0rmj219s0nugn4.jpg" alt="jackson 搜索" title="jackson 搜索"></p><p> 配置到 pom.xml<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqq62vwuvj20mw07kdg4.jpg" alt="jackson 配置" title="jackson 配置"></p><p>我这里使用了常量，在 pom.xml 文件的 properties 属性下面配置即可。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqq73kgcsj20oo02o746.jpg" alt="Maven 版本常量" title="Maven 版本常量"></p><h1 id="踩坑总结"><a href="# 踩坑总结" class="headerlink" title="踩坑总结"></a>踩坑总结</h1><p>1、其实 jackson 这个依赖我并没有使用，而是引用的一个第三方依赖内部使用的，但是这个第三方依赖并没有一同打进来，也没有说明需要什么版本的，所以导致我自己在实验，最终找到到底哪一个版本合适。</p><p>2、为了统一，jackson-core 的版本要与 jackson-databind 的版本一致，jackson-databind 里面是已经自带了 jackson-annotations 的，由于 jackson-databind 里面的类继承了 jackson-core 里面的，所以才都要升级并且保持版本一致。</p><p>3、搜索类方法时，注意留意父类和接口里面，不一定非要在当前类里面出现。更改版本后同样也去类里面搜索一下，看看有没有需要调用的方法出现，确定版本用对了再继续做测试。</p><p>4、这种错误在编译、打包、部署阶段是检查不出来的，因为代码并没有实际调用到，属于运行时错误，只有跑起来程序，执行到需要使用该方法的时候，才会报错。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本文讲述 Java 项目由 Maven 包冲突或者版本不合适导致的运行时错误：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.lang.NoSuchMethodError: com.fasterxml.jackson.databind.JavaType.isReferenceType()Z&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="NoSuchMethodError" scheme="https://www.playpi.org/tags/NoSuchMethodError/"/>
    
      <category term="jackson" scheme="https://www.playpi.org/tags/jackson/"/>
    
      <category term="Maven" scheme="https://www.playpi.org/tags/Maven/"/>
    
      <category term="SpringMVC" scheme="https://www.playpi.org/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 个人站点绑定独立的域名</title>
    <link href="https://www.playpi.org/2018112701.html"/>
    <id>https://www.playpi.org/2018112701.html</id>
    <published>2018-11-27T03:55:57.000Z</published>
    <updated>2018-11-27T03:55:57.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p> 随着越来越多的人使用 GitHub，都在里面创建了自己的仓库，或者 clone 了别人的优秀项目，也有很多人想利用 GitHub 自带的 GitHub Pages 来搭建个人博客，此时就可以使用独立的域名 <a href="https://www.username.github.io" target="_blank" rel="noopener">https://www.username.github.io</a> 访问自己的博客，全部的资源都来自于 GitHub，并且是免费的，不需要其它任何配置或者购买，这里面包含域名、流量、带宽、存储空间、Htpps 认证等服务。但是，有的人可能购买了自己的独立域名，例如： <a href="https://www.abc.com" target="_blank" rel="noopener">https://www.abc.com</a> ，并且想把域名直接绑定到 GitHub 免费的域名上面，这样以后访问博客的时候更容易辨识，本文就描述 GitHub Pages 绑定独立域名的操作过程，前提是 GitHub Pages 已经创建完成。</p><a id="more"></a><p> 待整理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;随着越来越多的人使用 GitHub，都在里面创建了自己的仓库，或者 clone 了别人的优秀项目，也有很多人想利用 GitHub 自带的 GitHub Pages 来搭建个人博客，此时就可以使用独立的域名 &lt;a href=&quot;https://www.username.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.username.github.io&lt;/a&gt; 访问自己的博客，全部的资源都来自于 GitHub，并且是免费的，不需要其它任何配置或者购买，这里面包含域名、流量、带宽、存储空间、Htpps 认证等服务。但是，有的人可能购买了自己的独立域名，例如： &lt;a href=&quot;https://www.abc.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.abc.com&lt;/a&gt; ，并且想把域名直接绑定到 GitHub 免费的域名上面，这样以后访问博客的时候更容易辨识，本文就描述 GitHub Pages 绑定独立域名的操作过程，前提是 GitHub Pages 已经创建完成。&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://www.playpi.org/categories/building/"/>
    
    
      <category term="GitHub" scheme="https://www.playpi.org/tags/GitHub/"/>
    
      <category term="个人站点" scheme="https://www.playpi.org/tags/%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"/>
    
      <category term="绑定域名" scheme="https://www.playpi.org/tags/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Win10 输入法简繁体快捷键与 IDEA 冲突</title>
    <link href="https://www.playpi.org/2018112301.html"/>
    <id>https://www.playpi.org/2018112301.html</id>
    <published>2018-11-23T10:26:03.000Z</published>
    <updated>2018-12-09T10:26:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>用了 2 个月的 Windows 10 系统（教育版），又安装了 IDEA 代码集成工具，开发的时候，发现每一次只要我使用快捷键 Ctrl + Shift + F 格式化代码后（主要作用就是代码对齐），不起作用，而且写中文注释时发现输入法的中文就被切换为了繁体，再来一次就被切换为了简体。到这里，我知道 IDEA 的快捷键与输入法的快捷键冲突了。</p><a id="more"></a><h1 id="解决方案"><a href="# 解决方案" class="headerlink" title="解决方案"></a>解决方案 </h1><p>1、如前文描述，在写代码的过程中发现这个问题，并且看出是快捷键冲突的问题，接下来就要解决它。作为一名工程师，IDEA 的快捷键是因为使用习惯设置的，是写代码效率的保证，不可能更改的，任何与它有冲突的快捷键都要让步，那肯定是要更改输入法的快捷键的；</p><p>2、信心满满，打开 <strong> 搜狗输入法 </strong>的 <strong>属性设置 </strong>界面，找到 <strong>高级 </strong>选项，选择，可以看到里面有 <strong>快捷键 </strong>的相关配置；</p><p>配置所有的快捷键 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0oij39bnj20ld0f0dgj.jpg" alt="快捷键配置" title="快捷键配置"></p><p>3、看了半天，也就这么几个快捷键配置，里面根本没有 <strong> 简体 / 繁体 </strong>切换这一个配置选择，去搜索了一下其它资料，发现 <strong>简体 / 繁体 </strong>切换这一个快捷键是 Windows 10 系统内置的，默认就是 Ctrl + Shift + F，默认是给微软输入法使用的，某些版本的 Windows 10 系统有 bug，无法更改，哪怕卸载微软输入法，安装其它输入法也无效；</p><p>4、我看了我的 Windows 10 系统版本，已经是新版本了，不会有那个 bug 出现了，所以要从系统设置入手了，应该有地方设置才对，查看了语言里面的设置信息，没找到，只能又返回到搜狗输入法里面，这时突然看到里面有一个 <strong>系统功能快捷键 </strong>选项；</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0ort48p1j20ld0f03z6.jpg" alt="系统功能快捷键" title="系统功能快捷键"></p><p>5、就是这里了，点进去，把 <strong>简繁切换 </strong>关闭（如果需要保留的话，更改快捷键即可），解决问题。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0oua7u57j20dv09q3ym.jpg" alt="关闭简繁切换" title="关闭简繁切换"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;用了 2 个月的 Windows 10 系统（教育版），又安装了 IDEA 代码集成工具，开发的时候，发现每一次只要我使用快捷键 Ctrl + Shift + F 格式化代码后（主要作用就是代码对齐），不起作用，而且写中文注释时发现输入法的中文就被切换为了繁体，再来一次就被切换为了简体。到这里，我知道 IDEA 的快捷键与输入法的快捷键冲突了。&lt;/p&gt;
    
    </summary>
    
      <category term="知识改变生活" scheme="https://www.playpi.org/categories/knowledge-for-life/"/>
    
    
      <category term="Win10" scheme="https://www.playpi.org/tags/Win10/"/>
    
      <category term="输入法" scheme="https://www.playpi.org/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
      <category term="快捷键冲突" scheme="https://www.playpi.org/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%86%B2%E7%AA%81/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客静态资源压缩优化</title>
    <link href="https://www.playpi.org/2018112101.html"/>
    <id>https://www.playpi.org/2018112101.html</id>
    <published>2018-11-20T16:53:13.000Z</published>
    <updated>2018-11-20T16:53:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --><p>使用 hexo-cli 生成的静态网页 html 文件，使用文本编辑器打开，可以看到内容中有大量的回车换行等空白符。尽管是空白符，但是也占据着空间大小，而且那么多，导致 html 文件偏大，网页加载时不仅浪费流量，而且还影响速度。同时，最重要的是对于手机端来说，静态页面 html 文件太大了的确不友好。所以要做优化，用术语说是压缩，其实目的就是在生成 html 文件时，尽量去除内容中多余的空白符，减小 html 文件的大小。此外，顺便也把 css 文件、js 文件一起压缩了。</p><a id="more"></a><h1 id="当前现象"><a href="# 当前现象" class="headerlink" title="当前现象"></a>当前现象 </h1><p> 为了简单起见，只是列举 html 文件来看现象，目前查看生成的 8 个 html 静态页面（为了具有对比性，不包含当前页面），大小为 314 K。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxg5iuthmbj20sr0guta4.jpg" alt="8 个 html 文件" title="8 个 html 文件"></p><p>打开其中一个 html 文件查看内容，可以看到很多回车换行符。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxg5kn3bz2j20u00iidgy.jpg" alt="连续多个回车换行符" title="连续多个回车换行符"></p><p>接下来就是要想办法消除这些空白符。</p><h1 id="压缩方式选择"><a href="# 压缩方式选择" class="headerlink" title="压缩方式选择"></a>压缩方式选择 </h1><p> 通过查看 hexo 官网（附上插件库：<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">hexo 插件库 </a>），搜索资料了解别人的例子，发现有两种方式：</p><ul><li> 一种是先全局（-g 参数）安装 gulp 模块，根据压缩需求再安装需要的模块，例如 gulp-htmlclean、gulp-htmlmin、gulp-imagemin、gulp-minify-css、gulp-uglify，每个模块都有自己的功能，另外需要单独配置一个 js 脚本（放在站点根目录下），指明使用的模块，文件所在目录或者通配符文件名，然后每次使用 hexo generate 之后再使用 gulp 就可以压缩文件了。这种方式灵活度高，可以自定义，而且 gulp 的功能与 hexo 解耦，如果有其它静态文件，也可以使用 gulp 进行压缩。但是缺点也显而易见，门槛太高了，根据我的折腾经验，如果出了问题肯定要捣鼓半天，对于我这种零基础的人来说不够友好，我不选择；</li><li>另一种是类似于 hexo 的一个插件，像其它插件或者主题一样，直接安装一个模块，在配置文件中配置你想要的压缩内容，在 hexo generate 的时候就可以实现压缩，无需关心具体流程，也不用配置什么脚本，非常容易，我选择这个，目前我看到有两个类似的插件：<a href="https://github.com/rozbo/hexo-neat" target="_blank" rel="noopener">hexo-neat</a>、<a href="https://github.com/mamboer/hexo-filter-cleanup" target="_blank" rel="noopener">hexo-filter-cleanup</a>，用法都差不多，我选择前者，其实这些插件也是依赖于其它插件，把多种插件的功能整合在一起而已。</li></ul><h1 id="安装配置"><a href="# 安装配置" class="headerlink" title="安装配置"></a>安装配置 </h1><p>hexo-neat 插件其实是使用 HTMLMinifier、clean-css、UglifyJS 插件实现。</p><p> 安装（由于网络不稳定因素，可能不是一次就成功，可以多试几次）<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></table></figure><p></p><p>站点配置 <br> 编辑站点的配置文件 &#95;config.yml，开启对应的属性 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件压缩, 设置一些需要跳过的文件 </span></span><br><span class="line"><span class="comment"># hexo-neat</span></span><br><span class="line">neat_enable: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 压缩 html</span></span><br><span class="line">neat_html:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  exclude:</span><br><span class="line"><span class="comment"># 压缩 css</span></span><br><span class="line">neat_css:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  exclude:</span><br><span class="line">    - <span class="string">'**/*.min.css'</span></span><br><span class="line"><span class="comment"># 压缩 js</span></span><br><span class="line">neat_js:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  mangle: <span class="literal">true</span></span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - <span class="string">'**/*.min.js'</span></span><br><span class="line">    - <span class="string">'**/jquery.fancybox.pack.js'</span></span><br><span class="line">    - <span class="string">'**/index.js'</span></span><br></pre></td></tr></table></figure><h1 id="查看效果"><a href="# 查看效果" class="headerlink" title="查看效果"></a> 查看效果 </h1><p> 在执行 hexo generate 的命令行中就可以看到压缩率输出。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxzdwrue7aj20gj0ahdgr.jpg" alt="压缩率输出" title="压缩率输出"></p><p>8 个 html 文件被压缩后，大小只有 206 K，和之前的 314 K 比少了 108 K，虽然只是简单的数字，也可以看到压缩效果不错。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxg6y7u1mej20ro0guq49.jpg" alt="8 个文件压缩后" title="8 个文件压缩后"></p><p>继续打开先前打开的那个 html 文件，可以看到整个 html 文档被合并成为了一行文本内容，不影响浏览器对 html 文件的解析展示，回车换行的空白符内容肯定没有了。但是这样对于 html 文件的可读性变差了，最好还是使用一些回车换行符的，还好这些 html 文件我不会去看，能接受目前的效果。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxg743fu8jj20u00igq3g.jpg" alt="html 文件内容合并为一行" title="html 文件内容合并为一行"></p><h1 id="踩坑记录"><a href="# 踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><p>1、由于牵涉到压缩文件，所以 hexo 生成静态文件的速度会比以前慢一点，但是可以接受。</p><p>2、不要跳过 .md 文件，也不要跳过 .swig 文件，因为是在 hexo generate 阶段进行压缩的，所以这些文件必须交给 hexo-neat 插件处理，才能保证生成的 html 文件纯净。</p><p>3、参考博客：<a href="https://www.huangzz.xyz/hexo-optimized-file-compression.html" target="_blank" rel="noopener">1</a>、<a href="https://blog.csdn.net/lewky_liu/article/details/82432003" target="_blank" rel="noopener">2</a>、<a href="https://www.ecpeng.com/2018/04/02/%E5%85%B3%E4%BA%8Ehexo%E5%8D%9A%E5%AE%A2%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">3</a>、<a href="https://juejin.im/post/5a93c9385188257a84625aad" target="_blank" rel="noopener">4</a>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jan 07 2019 23:26:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;使用 hexo-cli 生成的静态网页 html 文件，使用文本编辑器打开，可以看到内容中有大量的回车换行等空白符。尽管是空白符，但是也占据着空间大小，而且那么多，导致 html 文件偏大，网页加载时不仅浪费流量，而且还影响速度。同时，最重要的是对于手机端来说，静态页面 html 文件太大了的确不友好。所以要做优化，用术语说是压缩，其实目的就是在生成 html 文件时，尽量去除内容中多余的空白符，减小 html 文件的大小。此外，顺便也把 css 文件、js 文件一起压缩了。&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://www.playpi.org/categories/building/"/>
    
    
      <category term="建站" scheme="https://www.playpi.org/tags/building/"/>
    
      <category term="Hexo" scheme="https://www.playpi.org/tags/Hexo/"/>
    
      <category term="代码压缩" scheme="https://www.playpi.org/tags/%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
</feed>
