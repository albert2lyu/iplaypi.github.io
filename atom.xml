<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虾丸派</title>
  
  <subtitle>烂笔头</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.playpi.org/"/>
  <updated>2018-12-28T15:49:01.000Z</updated>
  <id>https://www.playpi.org/</id>
  
  <author>
    <name>playpi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spark 异常之 java.net.BindException: 地址已在使用</title>
    <link href="https://www.playpi.org/2018122801.html"/>
    <id>https://www.playpi.org/2018122801.html</id>
    <published>2018-12-28T15:49:01.000Z</published>
    <updated>2018-12-28T15:49:01.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>今天查看日志发现，所有的 Spark 程序提交时会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.BindException: 地址已在使用 </span><br></pre></td></tr></table></figure><p>而且不止一次，会连续有多个这种异常，但是 Spark 程序又能正常运行，不会影响到对应的功能。本文就记录发现问题、分析问题的过程。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 在 Driver 端查看日志，发现连续多次相同的异常（省略了业务相关类信息）：</p><p>异常截图 </p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fymxb3zolsj210v0dzabe.jpg" alt="异常截图" title="异常截图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次异常 </span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0:<span class="number">4040</span>: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">425</span>)</span><br><span class="line">at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:<span class="number">223</span>)</span><br><span class="line">at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:<span class="number">74</span>)</span><br><span class="line">at org.spark-project.jetty.server.nio.SelectChannelConnector.open(SelectChannelConnector.java:<span class="number">187</span>)</span><br><span class="line">at org.spark-project.jetty.server.AbstractConnector.doStart(AbstractConnector.java:<span class="number">316</span>)</span><br><span class="line">at org.spark-project.jetty.server.nio.SelectChannelConnector.doStart(SelectChannelConnector.java:<span class="number">265</span>)</span><br><span class="line">at org.spark-project.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:<span class="number">64</span>)</span><br><span class="line">at org.spark-project.jetty.server.Server.doStart(Server.java:<span class="number">293</span>)</span><br><span class="line">at org.spark-project.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:<span class="number">64</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$.org$apache$spark$ui$JettyUtils$$connect$<span class="number">1</span>(JettyUtils.scala:<span class="number">252</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$$anonfun$<span class="number">5</span>.apply(JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$$anonfun$<span class="number">5</span>.apply(JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.util.Utils$$anonfun$startServiceOnPort$<span class="number">1</span>.apply$mcVI$sp(Utils.scala:<span class="number">2024</span>)</span><br><span class="line">at scala.collection.immutable.Range.foreach$mVc$sp(Range.scala:<span class="number">141</span>)</span><br><span class="line">at org.apache.spark.util.Utils$.startServiceOnPort(Utils.scala:<span class="number">2015</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$.startJettyServer(JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.ui.WebUI.bind(WebUI.scala:<span class="number">136</span>)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$<span class="number">13</span>.apply(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$<span class="number">13</span>.apply(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at scala.Option.foreach(Option.scala:<span class="number">236</span>)</span><br><span class="line">at org.apache.spark.SparkContext.&lt;init&gt;(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at org.apache.spark.api.java.JavaSparkContext.&lt;init&gt;(JavaSparkContext.scala:<span class="number">59</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED org.spark-project.jetty.server.Server@<span class="number">33e434</span>c8: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">425</span>)</span><br><span class="line">at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:<span class="number">223</span>)</span><br><span class="line">at sun.nio.ch.ServerSocketAdaptor.bind(ServerSocketAdaptor.java:<span class="number">74</span>)</span><br><span class="line">at org.spark-project.jetty.server.nio.SelectChannelConnector.open(SelectChannelConnector.java:<span class="number">187</span>)</span><br><span class="line">at org.spark-project.jetty.server.AbstractConnector.doStart(AbstractConnector.java:<span class="number">316</span>)</span><br><span class="line">at org.spark-project.jetty.server.nio.SelectChannelConnector.doStart(SelectChannelConnector.java:<span class="number">265</span>)</span><br><span class="line">at org.spark-project.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:<span class="number">64</span>)</span><br><span class="line">at org.spark-project.jetty.server.Server.doStart(Server.java:<span class="number">293</span>)</span><br><span class="line">at org.spark-project.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:<span class="number">64</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$.org$apache$spark$ui$JettyUtils$$connect$<span class="number">1</span>(JettyUtils.scala:<span class="number">252</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$$anonfun$<span class="number">5</span>.apply(JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$$anonfun$<span class="number">5</span>.apply(JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.util.Utils$$anonfun$startServiceOnPort$<span class="number">1</span>.apply$mcVI$sp(Utils.scala:<span class="number">2024</span>)</span><br><span class="line">at scala.collection.immutable.Range.foreach$mVc$sp(Range.scala:<span class="number">141</span>)</span><br><span class="line">at org.apache.spark.util.Utils$.startServiceOnPort(Utils.scala:<span class="number">2015</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$.startJettyServer(JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.ui.WebUI.bind(WebUI.scala:<span class="number">136</span>)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$<span class="number">13</span>.apply(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$<span class="number">13</span>.apply(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at scala.Option.foreach(Option.scala:<span class="number">236</span>)</span><br><span class="line">at org.apache.spark.SparkContext.&lt;init&gt;(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at org.apache.spark.api.java.JavaSparkContext.&lt;init&gt;(JavaSparkContext.scala:<span class="number">59</span>)</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次异常 </span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0:<span class="number">4041</span>: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">425</span>)</span><br><span class="line">...... 其它信息都一样 </span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次异常 </span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0:<span class="number">4042</span>: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">425</span>)</span><br><span class="line">....... 其它信息都一样 </span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次异常 </span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0:<span class="number">4043</span>: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0(Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind(Net.java:<span class="number">425</span>)</span><br><span class="line">....... 其它信息都一样 </span><br></pre></td></tr></table></figure><p> 可以轻易发现核心的地方在于：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0: 端口号: java.net.BindException: 地址已在使用 </span><br></pre></td></tr></table></figure><p></p><p>端口号在不断变化，从 4040 一直到 4043，才停止了异常的抛出。</p><h1 id="问题分析"><a href="# 问题分析" class="headerlink" title="问题分析"></a>问题分析 </h1><p> 在 Spark 创建 context 的时候，会使用 4040 端口作为默认的 SparkUI 端口，如果遇到 4040 端口被占用，则会抛出异常。接着会尝试下一个可用的端口，采用累加的方式，则使用 4041 端口，很不巧，这个端口也被占用了，也会抛出异常。接着就是重复上面的过程，直到找到空闲的端口。</p><p>这个异常其实没什么问题，是正常的，原因可能就是在一台机器上面有多个进程都在使用 Spark，创建 context，有的 Spark 任务正在运行着，占用了 4040 端口；或者就是单纯的端口被某些应用程序占用了而已。此时是不能简单地把这些进程杀掉的，会影响别人的业务。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><p> 既然找到了问题，解决办法就很简单了：</p><p>1、这本来就不是问题，直接忽略即可，不会影响 Spark 任务的正常运行；</p><p>2、如果非要不想看到异常日志，那么可以检查机器的 4040 端口被什么进程占用了，看看能不能杀掉，当然这种方法不好了；</p><p>3、可以自己指定端口（使用 spark.ui.port 配置项），确保使用空闲的端口即可（不建议，因为要确认空闲的端口，如果端口不空闲，Spark 的 context 会创建失败，更麻烦，还不如让 Spark 自己去重试）。</p><p>参考：<a href="https://community.hortonworks.com/questions/8257/how-can-i-resolve-it.html" target="_blank" rel="noopener">hortonworks</a></p><p>原文：</p><blockquote><p>When a spark context is created, it starts an application UI on port 4040 by default. When the UI starts, it checks to see if the port is in use, if so it should increment to 4041. Looks like you have something running on port 4040 there. The application should show you the warning, then try to start the UI on 4041.<br>This should not stop your application from running. If you really want to get around the WARNING, you can manually specify which port for the UI to start on, but I would strongly advise against doing so.<br>To manually specify the port, add this to your spark-submit:<br>–conf spark.ui.port=your_port</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天查看日志发现，所有的 Spark 程序提交时会抛出异常：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.net.BindException: 地址已在使用 &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;而且不止一次，会连续有多个这种异常，但是 Spark 程序又能正常运行，不会影响到对应的功能。本文就记录发现问题、分析问题的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="BindException" scheme="https://www.playpi.org/tags/BindException/"/>
    
  </entry>
  
  <entry>
    <title>HDFS 异常之 READ is not supported in state standby</title>
    <link href="https://www.playpi.org/2018122702.html"/>
    <id>https://www.playpi.org/2018122702.html</id>
    <published>2018-12-27T11:06:42.000Z</published>
    <updated>2018-12-27T11:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>今天查看日志发现，以前正常运行的 Spark 程序会不断抛出异常：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby</span><br></pre></td></tr></table></figure><p></p><p>但是却没有影响到功能的正常运行，只不过是抛出了大量的上述异常，而且内容都一样，也都是操作 HDFS 产生的，所以猜测与 HDFS 集群（或者配置）有关系。本文就记录发现问题、解决问题的过程。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 按照日常操作，查看 Spark 任务的 Driver 端的日志，结果发现了大量的重复异常，又看了一下对功能的影响，结果发现没有影响，所有功能均正常运行，产生的结果也是期望的。</p><h2 id="问题分析"><a href="# 问题分析" class="headerlink" title="问题分析"></a>问题分析 </h2><p> 详细来看一下 Driver 端的日志异常信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">2018-12-26_23:25:40 [main] INFO retry.RetryInvocationHandler:140: Exception while invoking getFileInfo of class ClientNamenodeProtocolTranslatorPB over hadoop1/192.168.10.162:8020. Trying to fail over immediately.</span><br><span class="line">org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.ha.StandbyState.checkOperation(StandbyState.java:<span class="number">87</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.NameNode$NameNodeHAContext.checkOperation(NameNode.java:<span class="number">1722</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.checkOperation(FSNamesystem.java:<span class="number">1362</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.getFileInfo(FSNamesystem.java:<span class="number">4414</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.NameNodeRpcServer.getFileInfo(NameNodeRpcServer.java:<span class="number">893</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.protocolPB.ClientNamenodeProtocolServerSideTranslatorPB.getFileInfo(ClientNamenodeProtocolServerSideTranslatorPB.java:<span class="number">835</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos$ClientNamenodeProtocol$<span class="number">2</span>.callBlockingMethod(ClientNamenodeProtocolProtos.java)</span><br><span class="line">at org.apache.hadoop.ipc.ProtobufRpcEngine$Server$ProtoBufRpcInvoker.call(ProtobufRpcEngine.java:<span class="number">619</span>)</span><br><span class="line">at org.apache.hadoop.ipc.RPC$Server.call(RPC.java:<span class="number">962</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Server$Handler$<span class="number">1</span>.run(Server.java:<span class="number">2039</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Server$Handler$<span class="number">1</span>.run(Server.java:<span class="number">2035</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at javax.security.auth.Subject.doAs(Subject.java:<span class="number">422</span>)</span><br><span class="line">at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:<span class="number">1628</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Server$Handler.run(Server.java:<span class="number">2033</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Client.call(Client.java:<span class="number">1468</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Client.call(Client.java:<span class="number">1399</span>)</span><br><span class="line">at org.apache.hadoop.ipc.ProtobufRpcEngine$Invoker.invoke(ProtobufRpcEngine.java:<span class="number">232</span>)</span><br><span class="line">at com.sun.proxy.$Proxy30.getFileInfo(Unknown Source)</span><br><span class="line">at org.apache.hadoop.hdfs.protocolPB.ClientNamenodeProtocolTranslatorPB.getFileInfo(ClientNamenodeProtocolTranslatorPB.java:<span class="number">768</span>)</span><br><span class="line">at sun.reflect.GeneratedMethodAccessor34.invoke(Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">at org.apache.hadoop.io.retry.RetryInvocationHandler.invokeMethod(RetryInvocationHandler.java:<span class="number">187</span>)</span><br><span class="line">at org.apache.hadoop.io.retry.RetryInvocationHandler.invoke(RetryInvocationHandler.java:<span class="number">102</span>)</span><br><span class="line">at com.sun.proxy.$Proxy31.getFileInfo(Unknown Source)</span><br><span class="line">at org.apache.hadoop.hdfs.DFSClient.getFileInfo(DFSClient.java:<span class="number">2007</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DistributedFileSystem$<span class="number">19</span>.doCall(DistributedFileSystem.java:<span class="number">1136</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DistributedFileSystem$<span class="number">19</span>.doCall(DistributedFileSystem.java:<span class="number">1132</span>)</span><br><span class="line">at org.apache.hadoop.fs.FileSystemLinkResolver.resolve(FileSystemLinkResolver.java:<span class="number">81</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DistributedFileSystem.getFileStatus(DistributedFileSystem.java:<span class="number">1132</span>)</span><br><span class="line">at org.apache.hadoop.fs.FileSystem.isFile(FileSystem.java:<span class="number">1426</span>)</span><br></pre></td></tr></table></figure><p>注意一下核心异常所在：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception while invoking getFileInfo of class ClientNamenodeProtocolTranslatorPB over hadoop1/192.168.10.162:8020. Trying to fail over immediately.</span><br><span class="line">org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby</span><br></pre></td></tr></table></figure><p></p><p>当去从 hadoop1/192.168.10.162:8020 这里 getFileInfo 的时候，抛出了异常，而且明确告诉我们这台机器处于 standby 状态，不支持读取操作。此时，可以想到，肯定是 hadoop1/192.168.10.162:8020 这台机器已经处于 standby 状态了，无法提供服务，所以抛出此异常。既然问题找到了，那么问题产生的原因是什么呢，以及为什么对功能没有影响，接下来一一分析。</p><p>首先查看 hdfs-site.xml 配置文件，看看 namenode 相关的配置项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.nameservices<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>r-cluster<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.namenodes.r-cluster<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>nn1,nn2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.r-cluster.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop1:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.r-cluster.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>rocket15:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，namenode 相关配置有 2 台机器：nn1、nn2，而上述产生异常的信息表明连接 nn1 被拒绝，那么我去看一下 HDFS 集群的状态，发现 nn1 果然是 standby 状态的，而 nn2（rocket15） 才是 active 状态。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyluqlzruwj20ln0b6mxq.jpg" alt="nn2 的 active 状态" title="nn2 的 active 状态"></p><p>再仔细查看日志，没有发现连接 nn2 的异常，那就说明是第一次连接 nn1 抛出异常，然后试图连接 nn2，成功连接，没有抛出异常，接下来程序就正常处理数据了，对功能没有任何影响。</p><p>到这里，我们已经分析出了整个过程，现象表明这个异常只是连接了 standby 状态的 namenode，是正常抛出的。然后会再次连接另外一台 active 状态的 namenode，连接成功。</p><h2 id="抛异常的流程细节"><a href="# 抛异常的流程细节" class="headerlink" title="抛异常的流程细节"></a>抛异常的流程细节 </h2><p>1、客户端在连接 HDFS 的时候，会从配置文件 hdfs-site.xml 中，读取 nameservices 的配置，获取机器编号，我这里是 nn1 和 nn2，分别对应着 2 台 namenode 机器；</p><p>2、客户端会首先选择编号较小的 namenode（我这里是 nn1，对应着 hadoop1），试图连接；</p><p>3、如果这台 namenode 是 active 状态，则客户端可以正常处理请求；但是如果这台 namenode 是 standby 状态，则客户端抛出由服务端返回的异常：Operation category READ is not supported in state standby，同时打印 ip 信息，接着会尝试连接另外一台编号较大的 namenode（我这里是 nn2，即 rocket15）；</p><p>4、如果连接成功，则客户端可以正常处理请求；如果 nn2 仍然像 nn1 一样，客户端会抛出一样的异常，此时会继续反复重试 nn1 与 nn2（重试次数有配置项，间隔时间有配置项）；如果有成功的，则客户端可以正常处理请求，如果全部失败，则客户端无法正常处理请求，此时应该要关注解决 namenode 为什么全部都处在 standby 状态。</p><p> 配置参数如下（参考 <a href="https://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml" target="_blank" rel="noopener">Hadoop 官方文档 </a>）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 客户端重试次数, 默认 15 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.max.attempts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>15<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 客户端 2 次重试间隔时间, 默认 500 毫秒 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.sleep.base.millis<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>500<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 客户端 2 次重试间隔时间, 默认 1500 毫秒 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.sleep.max.millis<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1500<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 客户端 1 次连接中重试次数, 默认 0, 在网络不稳定时建议加大此值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.connection.retries<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 客户端 1 次连接中超时重试次数，仅是指超时重试, 默认 0, 在网络不稳定时建议加大此值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.connection.retries.on.timeouts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a> 问题解决 </h1><p> 既然明确了问题，并且分析出了具体原因，解决起来就简单了，对于我这种情况，有 2 种方法：</p><p>1、不用解决，也无需关心，这个异常没有任何影响，会自动重连另外一台 active 状态的 namenode 机器的；</p><p>2、如果就是一心想把异常消除掉，那就更改 hdfs-site.xml 配置文件里面的 nameservices 配置项对应的机器，把编号最小的机器设置成状态为 active 的 namenode（例如我这里把 nn1、nn2 的对应的机器 ip 地址交换一下即可，确保 nn1 是 active 状态的），那么连接 HDFS 的时候第一次就会直接连接这台机器，就不会抛出异常了（但是要注意 namenode 以后可能是会挂的，挂了会自动切换，那么到那个时候还要更改这个配置项）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.r-cluster.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>rocket15:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.r-cluster.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop1:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><p>1、参考：<a href="http://support-it.huawei.com/docs/zh-cn/fusioninsight-all/maintenance-guide/zh-cn_topic_0062904132.html" target="_blank" rel="noopener">http://support-it.huawei.com/docs/zh-cn/fusioninsight-all/maintenance-guide/zh-cn_topic_0062904132.html</a></p><p>2、这个问题其实不是问题，只不过抛出了异常，我看到有点担心而已，但是如果连接所有的机器都抛出这种异常，并且重试了很多次就有影响了，说明所有的 namenode 都挂了，根本无法正常操作 HDFS 系统；</p><p>3、根据 2 进行总结：如果只是在操作 HDFS 的时候打印一次（每次操作都会打印一次），说明第一次连接到了 standby 状态的 namenode，是正常的，不用关心；但是，如果出现了大量的异常（比如连续 10 次，连续 20 次），说明 namenode 出问题了，此时应该关心 namenode 的状态，确保正常服务。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天查看日志发现，以前正常运行的 Spark 程序会不断抛出异常：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是却没有影响到功能的正常运行，只不过是抛出了大量的上述异常，而且内容都一样，也都是操作 HDFS 产生的，所以猜测与 HDFS 集群（或者配置）有关系。本文就记录发现问题、解决问题的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Hadoop 从零基础到入门系列" scheme="https://www.playpi.org/categories/series-of-hadoop/"/>
    
    
      <category term="Hadoop" scheme="https://www.playpi.org/tags/Hadoop/"/>
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="HDFS" scheme="https://www.playpi.org/tags/HDFS/"/>
    
      <category term="nameNode" scheme="https://www.playpi.org/tags/nameNode/"/>
    
      <category term="standby" scheme="https://www.playpi.org/tags/standby/"/>
    
  </entry>
  
  <entry>
    <title>HDFS 异常之 Filesystem closed</title>
    <link href="https://www.playpi.org/2018122701.html"/>
    <id>https://www.playpi.org/2018122701.html</id>
    <published>2018-12-27T09:35:54.000Z</published>
    <updated>2018-12-27T09:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>今天通过 Hadoop 的 api 去操作 HDFS 里面的文件，读取文本内容，但是在代码里面总是抛出以下异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.io.IOException: Filesystem closed</span><br></pre></td></tr></table></figure><p>然而文本内容又是正常读取出来的，但是我隐隐觉得读取的文本内容可能不全，应该只是所有文本内容的一部分。本文就记录这个问题的原因、影响以及解决方法。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 通过查看日志发现，有大量的异常日志打印出来，全部都是操作 HDFS 的时候产生的，有的是使用 Spark 连接 HDFS 读取文本数据，有的是使用 Hadoop 的 Java api 通过文件流来读取数据，每次读取操作都会产生一个如下异常信息（会影响实际读取的内容，多个 DataNode 的内容会漏掉）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">26_23</span>:<span class="number">25</span>:<span class="number">46</span> [SparkListenerBus] ERROR scheduler.LiveListenerBus:<span class="number">95</span>: Listener EventLoggingListener threw an exception</span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">at sun.reflect.GeneratedMethodAccessor33.invoke(Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">at org.apache.spark.scheduler.EventLoggingListener$$anonfun$logEvent$<span class="number">3</span>.apply(EventLoggingListener.scala:<span class="number">150</span>)</span><br><span class="line">at org.apache.spark.scheduler.EventLoggingListener$$anonfun$logEvent$<span class="number">3</span>.apply(EventLoggingListener.scala:<span class="number">150</span>)</span><br><span class="line">at scala.Option.foreach(Option.scala:<span class="number">236</span>)</span><br><span class="line">at org.apache.spark.scheduler.EventLoggingListener.logEvent(EventLoggingListener.scala:<span class="number">150</span>)</span><br><span class="line">at org.apache.spark.scheduler.EventLoggingListener.onJobStart(EventLoggingListener.scala:<span class="number">173</span>)</span><br><span class="line">at org.apache.spark.scheduler.SparkListenerBus$class.onPostEvent(SparkListenerBus.scala:34)</span><br><span class="line">at org.apache.spark.scheduler.LiveListenerBus.onPostEvent(LiveListenerBus.scala:<span class="number">31</span>)</span><br><span class="line">at org.apache.spark.scheduler.LiveListenerBus.onPostEvent(LiveListenerBus.scala:<span class="number">31</span>)</span><br><span class="line">at org.apache.spark.util.ListenerBus$class.postToAll(ListenerBus.scala:55)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus.postToAll(AsynchronousListenerBus.scala:<span class="number">37</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>$$anonfun$run$<span class="number">1</span>$$anonfun$apply$mcV$sp$<span class="number">1</span>.apply$mcV$sp(AsynchronousListenerBus.scala:<span class="number">80</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>$$anonfun$run$<span class="number">1</span>$$anonfun$apply$mcV$sp$<span class="number">1</span>.apply(AsynchronousListenerBus.scala:<span class="number">65</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>$$anonfun$run$<span class="number">1</span>$$anonfun$apply$mcV$sp$<span class="number">1</span>.apply(AsynchronousListenerBus.scala:<span class="number">65</span>)</span><br><span class="line">at scala.util.DynamicVariable.withValue(DynamicVariable.scala:<span class="number">57</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>$$anonfun$run$<span class="number">1</span>.apply$mcV$sp(AsynchronousListenerBus.scala:<span class="number">64</span>)</span><br><span class="line">at org.apache.spark.util.Utils$.tryOrStopSparkContext(Utils.scala:<span class="number">1181</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>.run(AsynchronousListenerBus.scala:<span class="number">63</span>)</span><br><span class="line">Caused by: java.io.IOException: Filesystem closed</span><br><span class="line">at org.apache.hadoop.hdfs.DFSClient.checkOpen(DFSClient.java:<span class="number">795</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DFSOutputStream.flushOrSync(DFSOutputStream.java:<span class="number">1986</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DFSOutputStream.hflush(DFSOutputStream.java:<span class="number">1947</span>)</span><br><span class="line">at org.apache.hadoop.fs.FSDataOutputStream.hflush(FSDataOutputStream.java:<span class="number">130</span>)</span><br><span class="line">... <span class="number">20</span> more</span><br></pre></td></tr></table></figure><p>最直接清晰的描述就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.io.IOException: Filesystem closed</span><br></pre></td></tr></table></figure><p>上述异常信息表明 HDFS 的 Filesystem 被关闭了，但是代码仍旧试图打开文件流读取内容。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><h2 id="分析一下"><a href="# 分析一下" class="headerlink" title="分析一下"></a> 分析一下 </h2><p> 根据上述信息，查看代码，每次操作 HDFS 都是独立的，会先根据统一的 conf 创建 Filesystem，然后根据文件路径创建 Path，打开输入流，读取内容，读取完成后关闭 Filesystem，没有什么异常的地方。</p><p>同时，根据异常信息可以发现，异常的抛出点并不是业务逻辑代码，更像是已经开始开启文件流读取文件，读着读着 Filesystem 就被关闭了，然后引发了异常，而业务逻辑中并没有突然关闭 Filesystem 的地方，也没有多线程操作 Filesystem 的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文件内容 </span></span><br><span class="line"><span class="comment"> * 纯文本, 不做转换 </span></span><br><span class="line"><span class="comment"> * 如果传入目录, 返回空内容 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hdfsFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">getFileContent</span><span class="params">(String hdfsFile)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; dataResult = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    FileSystem fs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 连接 hdfs</span></span><br><span class="line">        fs = FileSystem.get(CONF);</span><br><span class="line">        Path path = <span class="keyword">new</span> Path(hdfsFile);</span><br><span class="line">        <span class="keyword">if</span> (fs.isFile(path)) &#123;</span><br><span class="line">            FSDataInputStream fsDataInputStream = fs.open(path);</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(fsDataInputStream));</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != (line = bufferedReader.readLine())) &#123;</span><br><span class="line">                dataResult.add(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"!!!! 当前输入参数为目录, 不读取内容:&#123;&#125;"</span>, hdfsFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"!!!! 处理 hdfs 出错:"</span> + e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != fs) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"!!!! 关闭文件流出错:"</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查找文档发现，这个异常是 Filesystem 的缓存导致的。</p><p>当任务提交到集群上面以后，多个 datanode 在 getFileSystem 过程中，由于 Configuration 一样，会得到同一个 FileSystem。如果有一个 datanode 在使用完关闭连接，其它的 datanode 在访问时就会出现上述异常，导致数据缺失（如果数据恰好只存在一个 datanode 上面，可能没问题）。</p><h2 id="找到方法"><a href="# 找到方法" class="headerlink" title="找到方法"></a>找到方法 </h2><p> 通过上面的分析，找到了原因所在，那么解决方法有 2 种：</p><p>1、可以在 HDFS 的 core-site.xml 配置文件里面把 fs.hdfs.impl.disable.cache 设置为 true，这样设置会全局生效，所有使用这个配置文件的连接都会使用这种方式，有时候可能不想这样更改，那就使用第 2 种方式；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.hdfs.impl.disable.cache<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、在 HDFS 提供的 Java api 里面更改配置信息，则会只针对使用当前 conf 的连接有效，相当于临时参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存 fs, 避免多 datanode 异常: Caused by: java.io.IOException: Filesystem closed</span></span><br><span class="line">CONF.setBoolean(<span class="string">"fs.hdfs.impl.disable.cache"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>上面 2 种方法的目的都是为了关闭缓存 Filesyetem 实例，这样每次获得的 Filesystem 实例都是独立的，不会产生上述的异常，但是缺点就是会增加网络的 I/O，频繁开启、关闭文件流。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><p>1、参考：<a href="https://stackoverflow.com/questions/23779186/ioexception-filesystem-closed-exception-when-running-oozie-workflow" target="_blank" rel="noopener">https://stackoverflow.com/questions/23779186/ioexception-filesystem-closed-exception-when-running-oozie-workflow</a> ；</p><p>2、保留日志，查看日志很重要；</p><p>3、FileSytem 类内部有一个 static CACHE，用来保存每种文件系统的实例集合，FileSystem 类中可以通过参数 fs.%s.impl.disable.cache 来指定是否禁用缓存 FileSystem 实例（其中 %s 替换为相应的 scheme，比如 hdfs、local、s3、s3n 等）。如果没禁用，一旦创建了相应的 FileSystem 实例，这个实例将会保存在缓存中，此后每次 get 都会获取同一个实例，但是如果被关闭了，则再次用到就会无法获取（多 datanode 读取数据的时候）；</p><p>4、源码分析放在以后，留坑。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天通过 Hadoop 的 api 去操作 HDFS 里面的文件，读取文本内容，但是在代码里面总是抛出以下异常：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Caused by: java.io.IOException: Filesystem closed&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然而文本内容又是正常读取出来的，但是我隐隐觉得读取的文本内容可能不全，应该只是所有文本内容的一部分。本文就记录这个问题的原因、影响以及解决方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Hadoop 从零基础到入门系列" scheme="https://www.playpi.org/categories/series-of-hadoop/"/>
    
    
      <category term="Hadoop" scheme="https://www.playpi.org/tags/Hadoop/"/>
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="Filesystem" scheme="https://www.playpi.org/tags/Filesystem/"/>
    
      <category term="HDFS" scheme="https://www.playpi.org/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>可乐鸡翅做法总结</title>
    <link href="https://www.playpi.org/2018122501.html"/>
    <id>https://www.playpi.org/2018122501.html</id>
    <published>2018-12-24T17:36:37.000Z</published>
    <updated>2018-12-25T17:36:37.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p> 本文简单介绍可乐鸡翅的做法总结，这是一道偏甜的菜。</p><a id="more"></a><p> 待整理。</p><p> 注意不要再放糖了，一罐可乐里面含糖大概 35 克；</p><p> 注意如果放了生抽，也不用放盐了，或者少量放一点点；</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本文简单介绍可乐鸡翅的做法总结，这是一道偏甜的菜。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="可乐鸡翅" scheme="https://www.playpi.org/tags/%E5%8F%AF%E4%B9%90%E9%B8%A1%E7%BF%85/"/>
    
  </entry>
  
  <entry>
    <title>Spark 错误之 JavaSparkContext not serializable</title>
    <link href="https://www.playpi.org/2018122101.html"/>
    <id>https://www.playpi.org/2018122101.html</id>
    <published>2018-12-20T16:43:50.000Z</published>
    <updated>2018-12-20T16:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>今天更新代码，对 Spark 里面的 RDD 随便增加了一个 Function，结果遇到了序列化（Serializable）的问题，这个不是普通的自定义类不能序列化问题，而是 JavaSparkContext 的用法问题，由于小看了这个问题，多花了一点时间解决问题，本文就记录下这一过程。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 针对已有的项目改动了一点点，结果直接出现了这个错误：</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fydoetmx57j21gx0hjgph.jpg" alt="日志报错" title="日志报错"></p><p>一开始疏忽大意了，以为像往常一样，是某些需要传递的对象对应的类没有序列化，由于对代码不敢改动太大，就想着用最简单的方法，把几个自定义类都序列化了，以为就应该可以了。结果，还是不行，此时虽然不会有自定义类的序列化问题了，但是却出现了终极错误：JavaSparkContext not serializable，这是什么意思呢，是说 JavaSparkContext 不能序列化，总不能把 JavaSparkContext 序列化吧，Spark 是不允许这么干的。</p><p>那么问题是什么呢？我首先猜测肯定是 Function 里面用到了 JavaSparkContext 对象，导致启动 Spark 任务的时候，需要序列化 Function 用到的所有对象（当然也需要序列化对象所属类里面的所有属性），而这些 Function 所用到的所有对象里面，就有 JavaSparkContext 对象。于是，我耐心看了一下代码，果然，在创建 Function 对象的时候，竟然把 JavaSparkContext 对象作为参数传进去了，还是因为 JavaSparkContext 不能乱用。</p><p>其实，报错日志里面都已经明显指向说明了，除了自定义的类，错误归结于 <br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at org.apache.spark.api.java.AbstractJavaRDDLike.mapPartitions(JavaRDDLike.scala:<span class="number">46</span>)</span><br></pre></td></tr></table></figure><p></p><p> 而这里的代码，正是我增加的一部分，为了贪图简单方便，直接把 JavaSparkContext 对象传递给了 mapPartitions 对应的 Function。</p><h1 id="解决问题"><a href="# 解决问题" class="headerlink" title="解决问题"></a>解决问题 </h1><p> 既然找到了问题，接下来就好办了。既然 JavaSparkContext 不能乱用，那就不用，把这个传递参数去掉，即可正常运行，但是这样做太简单粗暴，不是解决问题的思路。仔细分析一下，可以有 2 种解决办法（思路就是避免序列化）：</p><p>1、如果在 Function 里面非要用到 JavaSparkContext 对象，那就把 JavaSparkContext 对象设置为全局静态的 Java 属性（使用 static 关键字），那么在哪里都可以调用它了，而无需担心序列化的问题（静态属性可以避免从 Driver 端发送到 Executor 端，从而避免了序列化过程）；</p><p>2、对于 Function 不要使用内部匿名类，这样必然需要序列化 Function 对象，同时也必然需要序列化 Function 对象用到的 JavaSparkContext 对象，其实可以把 Function 类定义为内部静态类，就可以避免序列化了。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结 </h1><p>1、出现这种错误，不要想当然地认为就是某种原因造成的，而要先看详细日志，否则会走弯路，浪费一些时间（虽然最终也能解决问题）；</p><p>2、有时候状态不好，晕乎乎的，找问题又慢又低效，此时应该休息一下，等头脑清醒了再继续找问题，否则可能事倍功半，而且影响心情。</p><p> 参考：<a href="https://stackoverflow.com/questions/27706813/javasparkcontext-not-serializable" target="_blank" rel="noopener">https://stackoverflow.com/questions/27706813/javasparkcontext-not-serializable</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天更新代码，对 Spark 里面的 RDD 随便增加了一个 Function，结果遇到了序列化（Serializable）的问题，这个不是普通的自定义类不能序列化问题，而是 JavaSparkContext 的用法问题，由于小看了这个问题，多花了一点时间解决问题，本文就记录下这一过程。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="Spark序列化" scheme="https://www.playpi.org/tags/Spark%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="serializable" scheme="https://www.playpi.org/tags/serializable/"/>
    
  </entry>
  
  <entry>
    <title>微博 url mid 相互转换算法实现 - Java 版本</title>
    <link href="https://www.playpi.org/2018122001.html"/>
    <id>https://www.playpi.org/2018122001.html</id>
    <published>2018-12-20T15:29:13.000Z</published>
    <updated>2018-12-20T15:29:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p> 对微博数据有了解的人都知道，一条微博内容对应有唯一的微博 url，同时对微博官方来说，又会生成一个 mid，mid 就是一条微博的唯一标识（就像 uid 是微博用户的唯一标识一样），也类似于人的身份证号。其实，微博 url 里面有一串看起来无意义的字符（由字母、数字组成，6-8 个字符长度），可以和 mid 互相转换，本文就根据理论以及 Java 版本的实现，讲解微博 url 与 mid 的互相转换过程。</p><a id="more"></a><p> 待整理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;对微博数据有了解的人都知道，一条微博内容对应有唯一的微博 url，同时对微博官方来说，又会生成一个 mid，mid 就是一条微博的唯一标识（就像 uid 是微博用户的唯一标识一样），也类似于人的身份证号。其实，微博 url 里面有一串看起来无意义的字符（由字母、数字组成，6-8 个字符长度），可以和 mid 互相转换，本文就根据理论以及 Java 版本的实现，讲解微博 url 与 mid 的互相转换过程。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="微博url" scheme="https://www.playpi.org/tags/%E5%BE%AE%E5%8D%9Aurl/"/>
    
      <category term="微博mid" scheme="https://www.playpi.org/tags/%E5%BE%AE%E5%8D%9Amid/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中字符串截取方法总结</title>
    <link href="https://www.playpi.org/2018121901.html"/>
    <id>https://www.playpi.org/2018121901.html</id>
    <published>2018-12-18T16:31:19.000Z</published>
    <updated>2018-12-18T16:31:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>最近在处理数据的时候，用到了 JavaScript 编程语言，通过绕弯路来解决 ETL 处理的逻辑，其中就用到了字符串的截取方法，查 JavaScript 的文档看到了 3 个方法，被绕的有点晕，本文就总结一下 JavaScript 中字符串截取的方法。</p><a id="more"></a><h1 id="开篇"><a href="# 开篇" class="headerlink" title="开篇"></a>开篇 </h1><p> 首先声明，JavaScript 中对方法名字的大小写是敏感的，该是小写就是小写，该是大写就是大写。</p><h1 id="substring- 方法"><a href="#substring- 方法" class="headerlink" title="substring() 方法"></a>substring() 方法 </h1><h2 id="定义和用法"><a href="# 定义和用法" class="headerlink" title="定义和用法"></a> 定义和用法 </h2><blockquote><p>substring() 方法用于截取字符串中介于两个指定下标之间的字符</p></blockquote><h2 id="语法"><a href="# 语法" class="headerlink" title="语法"></a> 语法 </h2><blockquote><p>stringObject.substring(start, stop)</p></blockquote><p> 上述参数解释：</p><table><thead><tr><th style="text-align:center">参数名 </th><th style="text-align:center"> 解释说明 </th></tr></thead><tbody><tr><td style="text-align:center">start</td><td style="text-align:center"> 必须，一个整数（是负数则被自动置为 0），要截取的子串的第一个字符在 stringObject 中的位置 </td></tr><tr><td style="text-align:center">end</td><td style="text-align:center"> 可选（如果省略该参数，则被默认为字符串长度），一个整数（是负数则被自动置为 0），比要截取的子串的最后一个字符在 stringObject 中的位置多 1</td></tr></tbody></table><h2 id="返回值"><a href="# 返回值" class="headerlink" title="返回值"></a>返回值 </h2><p> 一个全新的字符串，其实就是 stringObject 的一个子字符串，其内容是从 start 到 stop-1 的所有字符，其长度为 stop 减 start。</p><h2 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a>注意事项 </h2><p>1、substring() 方法返回的子字符串包括 start 处的字符，但是不包括 stop 处的字符，这一点可能很多人会迷惑，其实很多编程语言都是这个逻辑；</p><p>2、如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串，不是 null，也不是 undefined）；</p><p>3、如果 start 比 stop 大，那么该方法在截取子串之前会先交换这两个参数，这就会导致参数的顺序不影响截取的结果了；</p><p>4、参数理论上不能出现负数（在本方法中无特殊意义，在其它方法中就有特殊意义了），如果有，那么在截取子串之前会被置为 0。</p><h2 id="举例说明"><a href="# 举例说明" class="headerlink" title="举例说明"></a> 举例说明 </h2><p><strong> 例子 1（从下标 3 截取到字符串最后）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substring(<span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 10 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-world!</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 2（从下标 3 截取到下标 8）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substring(<span class="number">3</span>, <span class="number">8</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 5 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 3（从下标 3 截取到下标 8，但是参数位置反了）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substring(<span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 5 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 4（参数为负数，从下标 0 截取到下标 3）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substring(<span class="number">-1</span>, <span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 3 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hel</span><br></pre></td></tr></table></figure><p></p><h1 id="substr- 方法"><a href="#substr- 方法" class="headerlink" title="substr() 方法"></a>substr() 方法 </h1><h2 id="定义和用法 -1"><a href="# 定义和用法 -1" class="headerlink" title="定义和用法"></a> 定义和用法 </h2><blockquote><p>substr() 方法可在字符串中截取从 start 下标开始的指定长度的子串</p></blockquote><h2 id="语法 -1"><a href="# 语法 -1" class="headerlink" title="语法"></a> 语法 </h2><blockquote><p>stringObject.substr(start, length)</p></blockquote><p> 上述参数解释：</p><table><thead><tr><th style="text-align:center">参数名 </th><th style="text-align:center"> 解释说明 </th></tr></thead><tbody><tr><td style="text-align:center">start</td><td style="text-align:center"> 必须，必须是数值（0、正数、负数都可以），表示要截取的子串的起始下标。如果是负数，那么该参数声明的是从字符串的尾部开始计算的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。（参数为负数也可以理解成字符串长度加负数之和即为起始下标）</td></tr><tr><td style="text-align:center">length</td><td style="text-align:center">可选（如果省略该参数，那么默认为从 start 开始一直到 stringObject 的结尾对应的长度），必须是数值（0、正数、负数都可以）。</td></tr></tbody></table><h2 id="返回值 -1"><a href="# 返回值 -1" class="headerlink" title="返回值"></a>返回值 </h2><p> 一个全新的字符串，包含从 stringObject 的 start（包括 start 所指的字符）下标开始的 length 个字符。如果没有指定 length，那么返回的字符串包含从 start 到 stringObject 的结尾的字符。如果 length 指定为负数或者 0，那么返回空串。如果 length 指定为远远大于 stringObject 长度的正数，那么返回的字符串包含从 start 到 stringObject 的结尾的字符。</p><h2 id="注意事项 -1"><a href="# 注意事项 -1" class="headerlink" title="注意事项"></a>注意事项 </h2><p>1、start 参数为负数是有特殊含义的；</p><p>2、如果 length 指定为负数或者 0，那么返回空串（即长度为 0 的字符串，不是 null，也不是 undefined）；</p><p>3、ECMAscript 没有对该方法进行标准化，因此不建议使用它。</p><h2 id="举例说明 -1"><a href="# 举例说明 -1" class="headerlink" title="举例说明"></a> 举例说明 </h2><p><strong> 例子 1（从下标 3 截取到字符串最后）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substr(<span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 9 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-world!</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 2（从下标 3 截取长度为 5 的子串）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substr(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 5 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 3（从下标 3 截取长度为 - 5 的子串，返回空串）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substr(<span class="number">3</span>, <span class="number">-5</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（返回空串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p><strong>例子 4（start 参数为负数，即从字符串倒数第 5 个位置截取长度为 3 的子串）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.substr(<span class="number">-5</span>, <span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 3 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orl</span><br></pre></td></tr></table></figure><p></p><h1 id="slice- 方法"><a href="#slice- 方法" class="headerlink" title="slice() 方法"></a>slice() 方法 </h1><h2 id="定义和用法 -2"><a href="# 定义和用法 -2" class="headerlink" title="定义和用法"></a> 定义和用法 </h2><blockquote><p>slice() 方法用于截取字符串中介于两个指定下标之间的字符，与 substring() 方法的功能类似</p></blockquote><h2 id="语法 -2"><a href="# 语法 -2" class="headerlink" title="语法"></a> 语法 </h2><blockquote><p>stringObject.slice(start, end)</p></blockquote><p> 上述参数解释：</p><table><thead><tr><th style="text-align:center">参数名 </th><th style="text-align:center"> 解释说明 </th></tr></thead><tbody><tr><td style="text-align:center">start</td><td style="text-align:center"> 必须，一个整数（0、正数、负数，负数有特殊含义），要截取的子串的第一个字符在 stringObject 中的位置。如果是负数，那么该参数声明的是从字符串的尾部开始计算的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。（参数为负数也可以理解成字符串长度加负数之和即为起始下标）</td></tr><tr><td style="text-align:center">end</td><td style="text-align:center">可选（如果省略该参数，则被默认为字符串长度），一个整数（负数含义与 start 相同），比要截取的子串的最后一个字符在 stringObject 中的位置多 1</td></tr></tbody></table><h2 id="返回值 -2"><a href="# 返回值 -2" class="headerlink" title="返回值"></a>返回值 </h2><p> 一个全新的字符串，其实就是 stringObject 的一个子字符串，其内容是从 start 到 stop-1 的所有字符，其长度为 stop 减 start。</p><h2 id="注意事项 -2"><a href="# 注意事项 -2" class="headerlink" title="注意事项"></a>注意事项 </h2><p>1、slice() 方法返回的子字符串包括 start 处的字符，但是不包括 stop 处的字符，这一点可能很多人会迷惑，其实很多编程语言都是这个逻辑；</p><p>2、如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串，不是 null，也不是 undefined）；</p><p>3、参数可以出现负数（比 substring() 方法灵活多了）。</p><h2 id="举例说明 -2"><a href="# 举例说明 -2" class="headerlink" title="举例说明"></a> 举例说明 </h2><p><strong> 例子 1（从下标 3 截取到字符串最后）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 9 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-world!</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 2（从下标 3 截取到下标 8）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">3</span>, <span class="number">8</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 5 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 3（从下标 3 截取到下标 8，但是参数使用负数，从下标 - 9 截取到下标 - 4）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">-9</span>, <span class="number">-4</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 5 的子串，（-4）-（-9）=5）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 4（从下标 3 截取到下标 2）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出返回空串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近在处理数据的时候，用到了 JavaScript 编程语言，通过绕弯路来解决 ETL 处理的逻辑，其中就用到了字符串的截取方法，查 JavaScript 的文档看到了 3 个方法，被绕的有点晕，本文就总结一下 JavaScript 中字符串截取的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="JavaScript" scheme="https://www.playpi.org/tags/JavaScript/"/>
    
      <category term="字符串截取" scheme="https://www.playpi.org/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>西红柿疙瘩汤做法总结</title>
    <link href="https://www.playpi.org/2018121601.html"/>
    <id>https://www.playpi.org/2018121601.html</id>
    <published>2018-12-15T17:57:00.000Z</published>
    <updated>2018-12-16T17:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>西红柿疙瘩汤，是一道做法非常简单的主食与配菜混为一起的菜品，适合在寒冷的冬天食用，吃一碗热乎乎的，非常暖胃，我知道的在河南与安徽都有这个做法。本文就讲述西红柿疙瘩汤的做法总结。</p><a id="more"></a><h1 id="食材准备"><a href="# 食材准备" class="headerlink" title="食材准备"></a>食材准备 </h1><p> 以下的食材份量大约 2 人份：</p><ul><li>黄心乌菜一颗（实在没有使用其它青菜也可以）</li><li>西红柿一颗（粉的最好，与脆的对立）</li><li>鸡蛋 2 颗 </li><li> 面粉 100 克 </li><li> 小葱、香菜各 2 棵 </li><li> 调味料（食用盐、芝麻油）</li></ul><h1 id="制作步骤"><a href="# 制作步骤" class="headerlink" title="制作步骤"></a>制作步骤 </h1><p> 从开火到关火预计耗时 15-20 分钟：</p><p>0、葱花香菜段；<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5zv7hnmj229s29s4qq.jpg" alt="葱花香菜段" title="葱花香菜段"></p><p>1、西红柿去皮，划十字刀花，放入热水中烫 1 分钟左右，取出直接去皮，不去皮也行，但是会影响口感，去皮后切丁，切小一点，放入碗中备用；<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5kxue8tj229s29se81.jpg" alt="一颗西红柿" title="一颗西红柿"></p><p>2、准备黄心乌菜，洗干净，随便切（手撕也行，无所谓），切成条状或者小块状，别太大就行；<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5lswpt3j20m80m844i.jpg" alt="黄心乌长这样" title="黄心乌长这样"></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5m1xtc6j229s29su0x.jpg" alt="黄心乌切碎" title="黄心乌切碎"></p><p>3、面粉放入大碗中，放在水龙头下，让水一滴一滴滴下来，迅速搅拌面粉，很快就可以做成面粒；<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5otcr3mj229s29s7wi.jpg" alt="面粒长这样" title="面粒长这样"></p><p>4、鸡蛋打入碗中，搅拌均匀备用；</p><p>5、锅烧热，倒入油，炒制西红柿丁，中小火炒制 3-5 分钟，此时西红柿的状态就是一半是糊状，一半是小颗粒，混合在一起，倒入开水（注意量的控制，比想象的多倒一点，面粒会吸收大量水分的），大火烧开；</p><p>6、烧开后放入面粒，大火煮 5 分钟，面粒基本熟透，汤变得浓稠，放入青菜，中火继续煮 1 分钟左右，鸡蛋液慢慢淋入锅中，搅拌，放入食用盐，中火继续煮 2 分钟；</p><p>7、开锅，放入芝麻油、香菜段，葱花，搅拌十几秒，关火。</p><p>一锅 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy94yo4wibj229s29snpd.jpg" alt="一锅" title="一锅"></p><p> 一碗 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5xkeysqj229s29shdt.jpg" alt="一碗" title="一碗"></p><p> 做完顺便又加了 2 个菜：<br>花菜回锅肉 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya60u5iacj229s29se81.jpg" alt="花菜回锅肉" title="花菜回锅肉"></p><p> 辣椒回锅肉 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya61058ppj229s29su0x.jpg" alt="辣椒回锅肉" title="辣椒回锅肉"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项 </h1><p>1、青菜最好选择黄心乌，因为我一直吃的都是这种，黄心乌这种青菜一般在沿淮地区才播种，因为它比较耐寒，在秋季播种，在冬天收割，一般北方的冬天也看不到其它青菜可以生长了；</p><p>2、条件允许的话，可以放一点酱肉之类的肉粒进去，更能增加食欲；</p><p>3、做面粒的时候切记不要直接倒水搅拌，这样是做不成的一粒一粒的效果的，只能用水滴进去然后迅速搅拌，使水滴周围裹上面粉形成一粒，很快就全部都是面粒了，而且很均匀，另外，做好面粒后要立马使用，不要提前做好放那里，因为放久了（10 分钟都不行）面粒会粘连在一起，实在要放的话再多加点面粉进去，让面粒之间隔开；</p><p>4、西红柿最好选择粉的，就是那种吃起来很柔绵的，更容易做成均匀的汤；</p><p>5、做回锅肉，肉要煮到什么程度才能回锅，简单的判断方法就是筷子可以轻易穿透肉，一半要煮 20 分钟以上。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya63x2errj229s29snpd.jpg" alt="肉回锅之前" title="肉回锅之前"></p><h1 id="补充说明"><a href="# 补充说明" class="headerlink" title="补充说明"></a> 补充说明</h1><p>2018 年 12 月 23 日，广州突然降温，降到 17 度左右（前一天的冬至还 25 度呢，短袖都穿起来了），天气冷了，于是又煮了一锅。可惜这次没买到香菜，没买到黄心乌菜，也没买到酱肉，凑活着吃。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyiauqznd7j229s29sx6p.jpg" alt="2018 年 12 月 23 日又煮了一锅" title="2018 年 12 月 23 日又煮了一锅"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;西红柿疙瘩汤，是一道做法非常简单的主食与配菜混为一起的菜品，适合在寒冷的冬天食用，吃一碗热乎乎的，非常暖胃，我知道的在河南与安徽都有这个做法。本文就讲述西红柿疙瘩汤的做法总结。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="西红柿疙瘩汤" scheme="https://www.playpi.org/tags/%E8%A5%BF%E7%BA%A2%E6%9F%BF%E7%96%99%E7%98%A9%E6%B1%A4/"/>
    
      <category term="疙瘩汤" scheme="https://www.playpi.org/tags/%E7%96%99%E7%98%A9%E6%B1%A4/"/>
    
  </entry>
  
  <entry>
    <title>常用正则表达式列表</title>
    <link href="https://www.playpi.org/2018121401.html"/>
    <id>https://www.playpi.org/2018121401.html</id>
    <published>2018-12-13T18:18:48.000Z</published>
    <updated>2018-12-14T18:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p> 正则表达式是一种表达式语句。本文记录一些常用的正则表达式，以便使用。</p><a id="more"></a><p> 待整理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;正则表达式是一种表达式语句。本文记录一些常用的正则表达式，以便使用。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="正则表达式" scheme="https://www.playpi.org/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>与微博内容分析相关的正则表达式</title>
    <link href="https://www.playpi.org/2018121101.html"/>
    <id>https://www.playpi.org/2018121101.html</id>
    <published>2018-12-11T14:16:19.000Z</published>
    <updated>2018-12-11T14:16:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>在分析微博内容时，常常需要进行特殊内容去除与抽取，例如抽取微博话题、微博昵称、微博表情、微博短链接、网址长链接等等。本文依据实际使用情况，记录下了与微博内容分析相关的正则表达式，以便查用。</p><a id="more"></a><h1 id="微博表情"><a href="# 微博表情" class="headerlink" title="微博表情"></a>微博表情 </h1><p> 表情是使用左右中括号包含的文本（在实际使用时，显示的是 emoji 表情，不是单纯的字符），例如：[爱心]、[微笑]、[笑哭]，分别表示：:heart:、❤️、:smile:、😊、:joy:、😂</p><p>参考：<a href="https://emojipedia.org" target="_blank" rel="noopener">emoji 百科 </a> 。</p><p> 如果在微博内容中抽取表情，使用正则表达式（1-7 个字符，中文和字母，不排除有的新的表情出现，导致字符更长）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[[\u4e00-\u9fa5A-Za-z]&#123;1,7&#125;\]</span><br></pre></td></tr></table></figure><p>不同字符长度的表情举例（我用了 10 分钟把微博表情全部浏览了一遍，发现 [小黄人] 系列、[文明遛狗]是最近刚刚发布出来的）：[耶]、[来]、[跪了]、[ok]、[中国赞]、[紫金草]、[doge]、[文明遛狗]、[给你小心心]、[小黄人微笑]、[弗莱见钱眼开]、[小黄人剪刀手]、[哆啦 A 梦害怕]、[带着微博去旅行]。</p><h1 id="微博昵称"><a href="# 微博昵称" class="headerlink" title="微博昵称"></a>微博昵称 </h1><p> 微博昵称是用户填写的昵称，并且在转发或者提到时，会增加 @ 前缀，例如有一个 playpi 微博用户，在实际微博内容中，会以 @playpi 的形式出现，当然，微博昵称的可用字符是有限制的，不是任意字符都行，长度也是有限制的，最少 4 个字符，最多 30 个字符。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy6r1bwv0xj20mi082dfy.jpg" alt="微博昵称字符限制" title="微博昵称字符限制"></p><p>以及微博客服的回答：<a href="https://www.weibo.com/2016713117/FCf87jJZt?type=comment#_rnd1544860586591" target="_blank" rel="noopener">微博客服微博 </a> 。</p><p> 但是这个规则是针对修改昵称的限制，如果有些帐号是以前注册的，并且昵称在微博官方限制以前没有修改过，那么就有可能是 2 个字符，3 个字符，例如各个明星、作家、自媒体的个人微博：@阑夕、@王力宏、@韩寒 等等。</p><p>如果在微博内容中抽取昵称，使用正则表达式（中文、数字、字母、横线、下划线的组合，2-30 个字符）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@[\u4e00-\u9fa5A-Z0-9a-z_-]&#123;2,30&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="微博话题"><a href="# 微博话题" class="headerlink" title="微博话题"></a>微博话题 </h1><p> 话题是微博定义的一种概念，可以用来标识热门事件、重大新闻、明星、综艺节目等等，发布规则就是使用 2 个 #符号包含话题内容（例如：# 创造 101#），话题即生成，微博还专门有一个实时话题榜单。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy6ro4qztbj20v40q2doc.jpg" alt="微博话题榜" title="微博话题榜"></p><p>如果在微博内容中抽取话题，使用正则表达式（2 个 #号之间，非指定的符号，长度在 1-49 之间）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[^@&lt;&gt;#"&amp;'\r\n\t]&#123;1,49&#125;#</span></span><br></pre></td></tr></table></figure><p></p><p>注意，我找到 2014 年的 <a href="https://iask.sina.com.cn/b/wnINuLfme5.html" target="_blank" rel="noopener">一篇旧帖子 </a>，微博小秘书评论说话题不能包含指定的几个特殊字符，还有内容长度限制，但是我在微博页面试了一下，这些特殊字符都可以使用（但是生成的话题页面，&lt; 字符、&gt; 字符被转成了 html 字符实体，换行符后的内容被截断，@符号、’单引号、” 双引号被自动替换掉，# 符号根本无法发布，空格符可以正常使用），而且长度限制是 1-49 个字符（中英文、标点都算 1 个字符）。但是为了话题内容的传播，还是使用通俗易懂的中文或者字母比较好。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy6s5061rxj20gv03uwei.jpg" alt="话题测试发布" title="话题测试发布"></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy6s42ecfzj20k904l0sq.jpg" alt="话题测试结果" title="话题测试结果"></p><h1 id="微博短链接"><a href="# 微博短链接" class="headerlink" title="微博短链接"></a> 微博短链接 </h1><p> 微博短链接是微博官方提供的网址压缩功能产生的一种只包含少量字符的短网址，例如：<a href="http://finance.sina.com.cn" target="_blank" rel="noopener">http://finance.sina.com.cn</a> ，压缩后为：<a href="http://t.cn/RnM1Uti" target="_blank" rel="noopener">http://t.cn/RnM1Uti</a> 。这样的话，发微博时链接占用更少的字符长度。如果发微博时，内容中带了链接，例如视频地址、淘宝店地址，会被自动压缩为短链接。微博短链接可以直接在浏览器中访问，会被微博的网址解析服务器转换为原来的正常链接再访问。</p><p>如果在微博内容中抽取短链接，使用正则表达式（我这里只是抽取 t.cn 域名的，6-8 个字母、数字）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https&#123;0,1&#125;://t.cn/[A-Z0-9a-z]&#123;6,8&#125;[/]&#123;0,1&#125;#</span></span><br></pre></td></tr></table></figure><p></p><p>参考：<br>微博开放平台说明：<a href="http://open.weibo.com/wiki/2/short_url/shorten" target="_blank" rel="noopener">http://open.weibo.com/wiki/2/short_url/shorten</a> ；<br>免费在线短链接转换工具：<a href="http://dwz.wailian.work" target="_blank" rel="noopener">http://dwz.wailian.work</a> 。</p><h1 id="网址长链接"><a href="# 网址长链接" class="headerlink" title="网址长链接"></a>网址长链接 </h1><p> 网址长链接也就是普通的网址，有多种可能性。</p><p>如果在微博内容中抽取网址长链接，使用正则表达式（我这里只考虑 http、https、ftp、file 协议）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(https?|ftp|file)://[-A-Za-z0-9+&amp;@<span class="comment">#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|]</span></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在分析微博内容时，常常需要进行特殊内容去除与抽取，例如抽取微博话题、微博昵称、微博表情、微博短链接、网址长链接等等。本文依据实际使用情况，记录下了与微博内容分析相关的正则表达式，以便查用。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="正则表达式" scheme="https://www.playpi.org/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="微博内容" scheme="https://www.playpi.org/tags/%E5%BE%AE%E5%8D%9A%E5%86%85%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>Win10 默认程序设置无效</title>
    <link href="https://www.playpi.org/2018120901.html"/>
    <id>https://www.playpi.org/2018120901.html</id>
    <published>2018-12-09T09:21:14.000Z</published>
    <updated>2018-12-09T09:21:14.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>装了 Windows 10 系统（教育版本），用了将近 3 个月了，最近发现一个诡异的现象，我的默认程序设置每次都只是设置后生效一段时间，例如视频播放器、音乐播放器，我分别设置成了迅雷看看、网易云音乐，用了半天之后，发现又变成了 Window 10 系统自带的视频播放器。这个现象也不是重启之后才出现的，而是平时用着用着就会出现，很莫名其妙。后来查阅资料发现这是一个普遍的现象，这个问题的根本原因是 Windows 10 自带的 bug，通常导致这个 bug 出现的原因是开启了系统的自动更新。</p><a id="more"></a><h1 id="现象"><a href="# 现象" class="headerlink" title="现象"></a>现象 </h1><p> 在 Windows 10 系统（没有打对应补丁的）中，如果开启了系统自动更新，就会触发相应的 bug：默认程序会被系统更改回系统自带的程序，例如视频播放器、音乐播放器等等。这个问题的原因用官方标识来指定就是由于 <strong>KB3135173</strong> 所致，同时这个 bug 已经有对应的补丁了。</p><p>按照系统设置，把某些默认程序改为自己需要的，我这里把视频播放器改为迅雷影音，设置特定格式的文件（.mkv，.mp4 等等）使用迅雷影音打开。</p><p>在桌面右下角打开 <strong>所有设置 </strong>选项 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0n2j57csj20bq0ahmz4.jpg" alt="所有设置" title="所有设置"></p><p> 在 Windows 设置中，选择 <strong>应用 </strong>选项 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0nlh83ifj20xc0pwdgf.jpg" alt="选择应用" title="选择应用"></p><p> 选择默认应用，设置视频播放器为 <strong>迅雷影音 </strong><br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0nnjkzdcj20xc0pw445.jpg" alt="设置视频播放器为迅雷影音" title="设置视频播放器为迅雷影音"></p><p> 上述的设置步骤实际上还不够，因为视频类型有很多种，还需要进一步指定每种类型的默认播放器，在默认应用下方有一个 <strong>按文件类型指定默认应用 </strong>选项 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0nqc3hdtj20xc0pw43w.jpg" alt="按文件类型指定默认应用" title="按文件类型指定默认应用"></p><p> 我这里特别关注 <strong>.mkv</strong>、<strong>.mp4</strong> 这 2 种格式的文件，默认应用设置为 <strong>迅雷影音 </strong><br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0nusxmrxj20md0pw0tu.jpg" alt="单独设置 2 种文件类型" title="单独设置 2 种文件类型"></p><p> 上述内容设置完成，就可以使用了，但是用不了多久，系统时不时就弹出提示框，通知默认程序重置，然后又被设置为系统内置的应用了 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0mr10t67j20bh0h977t.jpg" alt="弹出提示框" title="弹出提示框"></p><h1 id="解决方案"><a href="# 解决方案" class="headerlink" title="解决方案"></a> 解决方案 </h1><h2 id="不推荐方案"><a href="# 不推荐方案" class="headerlink" title="不推荐方案"></a> 不推荐方案 </h2><p> 更改注册表、使用命令行卸载系统默认程序，这些方案是可行的，但是对于普通用户来说太麻烦了一点，根本不懂得如何操作，而且解决方法太粗暴了，当然喜欢折腾的人是可以选择的。</p><p>以下给出几个命令行示例（需要在管理员模式下执行，打开 Windows PowerShell 的时候选择有管理员的那个）：</p><p>卸载 “电影和电视” 应用（星号表示通配符，下同）<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-appxpackage *zunevideo* | remove-appxpackage</span><br></pre></td></tr></table></figure><p></p><p>卸载 “Groove 音乐” 应用 <br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-appxpackage *zunemusic* | remove-appxpackage</span><br></pre></td></tr></table></figure><p></p><p> 卸载 “照片” 应用 <br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-appxpackage *photos* | remove-appxpackage</span><br></pre></td></tr></table></figure><p></p><p> 如果还想恢复已经卸载的系统自带应用，可以使用以下命令（重装所有系统内置的应用）<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-AppxPacKage -allusers | foreach &#123;Add-AppxPacKage -register <span class="string">"<span class="variable">$($_.InstallLocation)</span>appxmanifest.xml"</span> -DisableDevelopmentMode&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="推荐直接打补丁（更新系统）"><a href="# 推荐直接打补丁（更新系统）" class="headerlink" title="推荐直接打补丁（更新系统）"></a>推荐直接打补丁（更新系统）</h2><p>这个方法很简单，容易操作，直接在系统更新里面更新即可，确保要能更新到 <strong>KB3135173</strong> 这个补丁才行（或者更高版本的补丁）。</p><p>我这里是已经更新完成的，等待重启，补丁标识是 <strong>KB4469342</strong>。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0n75u4o3j20xc0pw442.jpg" alt="系统更新" title="系统更新"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;装了 Windows 10 系统（教育版本），用了将近 3 个月了，最近发现一个诡异的现象，我的默认程序设置每次都只是设置后生效一段时间，例如视频播放器、音乐播放器，我分别设置成了迅雷看看、网易云音乐，用了半天之后，发现又变成了 Window 10 系统自带的视频播放器。这个现象也不是重启之后才出现的，而是平时用着用着就会出现，很莫名其妙。后来查阅资料发现这是一个普遍的现象，这个问题的根本原因是 Windows 10 自带的 bug，通常导致这个 bug 出现的原因是开启了系统的自动更新。&lt;/p&gt;
    
    </summary>
    
      <category term="知识改变生活" scheme="https://www.playpi.org/categories/knowledge-for-life/"/>
    
    
      <category term="Win10" scheme="https://www.playpi.org/tags/Win10/"/>
    
      <category term="默认程序设置" scheme="https://www.playpi.org/tags/%E9%BB%98%E8%AE%A4%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Spark on Yarn 查看日志</title>
    <link href="https://www.playpi.org/2018120702.html"/>
    <id>https://www.playpi.org/2018120702.html</id>
    <published>2018-12-06T18:06:20.000Z</published>
    <updated>2018-12-06T18:06:20.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p> 一直一来都是直接在 Yarn 的 UI 界面上面查看 Spark 任务的日志的，感觉看少量的内容还勉强可以，但是如果内容很多，浏览器就没法看了，更没法分析。本文讲述如何使用 Yarn 自带的命令在终端查看 Spark 任务的日志，也可以拷贝出日志文件，便于分析。</p><a id="more"></a><p>1、查看某个 Spark 任务的日志，使用 logs 入口：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn logs -applicationId application_1542870632001_26426</span><br></pre></td></tr></table></figure><p></p><p> 如果日志非常多，直接看会导致刷屏，看不到有用的信息，所以可以重定向到文件中，再查看文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn logs -applicationId application_1542870632001_26426 &gt; ./application.log</span><br></pre></td></tr></table></figure><p></p><p>2、查看某个 Spark 任务的状态，使用 application 入口：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn application -status application_1542870632001_26426</span><br></pre></td></tr></table></figure><p></p><p> 同时也可以看到队列、任务类型、日志链接等详细信息 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxxloh9spej20uo0auaas.jpg" alt="查看状态" title="查看状态"></p><p>3、kill 掉某个 Spark 任务，有时候是直接在 Driver 端 kill 掉进程，然后 Yarn 的 Spark 任务也会随之失败，但是这种做法是不妥的。其实 kill 掉 Spark 任务有自己的命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn application -<span class="built_in">kill</span> application_1542870632001_26426</span><br></pre></td></tr></table></figure><p></p><p>4、需要注意的是，步骤 1 中去查看日志，要确保当前 HADOOP_USER_NAME 用户是提交 Spark 任务的用户，否则是看不到日志的，因为日志是放在 HDFS 对应的目录中的，其中路径中会有用户名。此外，步骤 1 中的日志要等 Spark 任务运行完了才能看到，否则日志文件不存在（还没收集到 HDFS 中）。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;一直一来都是直接在 Yarn 的 UI 界面上面查看 Spark 任务的日志的，感觉看少量的内容还勉强可以，但是如果内容很多，浏览器就没法看了，更没法分析。本文讲述如何使用 Yarn 自带的命令在终端查看 Spark 任务的日志，也可以拷贝出日志文件，便于分析。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="Yarn" scheme="https://www.playpi.org/tags/Yarn/"/>
    
      <category term="日志查看" scheme="https://www.playpi.org/tags/%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B/"/>
    
  </entry>
  
  <entry>
    <title>煮鸡蛋做法总结</title>
    <link href="https://www.playpi.org/2018120301.html"/>
    <id>https://www.playpi.org/2018120301.html</id>
    <published>2018-12-02T18:30:45.000Z</published>
    <updated>2018-12-02T18:30:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>本文记录水煮鸡蛋的做法总结。</p><a id="more"></a><h1 id="介绍"><a href="# 介绍" class="headerlink" title="介绍"></a>介绍 </h1><p> 水煮鸡蛋是最常见的吃法之一，做法非常简单，直接将鸡蛋放入开水中煮熟即可。煮熟的鸡蛋营养丰富，水煮鸡蛋的营养可以 100% 被保留，是所有的鸡蛋做法中营养被保留的最好的一种。建议每天食用 1-2 个，因为过量的食用可能会导致营养不良，同时鸡蛋的营养并没有被身体吸收，相当于浪费了。</p><p>在生活当中，大家几乎每天早上都会吃煮鸡蛋，或者茶叶蛋，但是有一些人卖的煮鸡蛋不算成功的煮鸡蛋，因为剥皮的时候发现不好剥，蛋壳与蛋白紧紧粘在一起，吃起来可麻烦了，这是因为煮鸡蛋的做法错误，遗漏了重要的步骤。</p><h1 id="做法步骤"><a href="# 做法步骤" class="headerlink" title="做法步骤"></a>做法步骤 </h1><p>1、简单地清洗一下鸡蛋，因为鸡蛋的表面可能会有一些茅草、粪便之类的污垢，这是因为鸡蛋必须是原生的，存储、运输、销售过程都不能清洗，如果非要清洗，水会破坏表面的保护膜，放不了两天鸡蛋就坏了；</p><p>2、放在冷水中浸泡一会儿，1-2 分钟，这样做的目的是防止沸水煮的时候蛋壳破裂；</p><p>3、放入锅中，水的高度稍微没过鸡蛋，使用中火煮开水，不要使用大火，大火煮的速度太快，鸡蛋容易裂开，另外中火使水沸腾的时间会长一些，预热了鸡蛋，味道更香；</p><p>4、水沸腾后，改为小火，煮 7-8 分钟（如果继续使用中火，5 分钟左右即可）；</p><p>5、如果需要溏心蛋（蛋清凝固，蛋黄成稠液状，软嫩滑润），煮 5 分钟即可；</p><p>6、煮熟后不要立即捞出，等 1-2 分钟，然后才捞出，切记此时需要放入冷水中，浸泡 1-3 分钟，这一步骤的目的是保证鸡蛋容易剥开，避免蛋白和蛋壳粘在一起。</p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项</h1><p>1、煮鸡蛋前最好放入冷水中浸泡 1-2 分钟，防止煮的过程开裂；</p><p>2、注意控制火力和时间，鸡蛋不能煮太久，超过 10 分钟会有化学反应，导致营养流失；</p><p>3、煮熟后不要立即捞出，捞出后也要放在冷水中浸泡，防止蛋白和蛋壳粘在一起；</p><p>4、每天不要吃太多，1-2 个就够了；</p><p>5、如果想要保持蛋黄在中间，煮鸡蛋的过程中要适当搅拌让鸡蛋旋转。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本文记录水煮鸡蛋的做法总结。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="煮鸡蛋" scheme="https://www.playpi.org/tags/%E7%85%AE%E9%B8%A1%E8%9B%8B/"/>
    
  </entry>
  
  <entry>
    <title>一条正则表达式引发的惨案</title>
    <link href="https://www.playpi.org/2018120201.html"/>
    <id>https://www.playpi.org/2018120201.html</id>
    <published>2018-12-01T18:04:13.000Z</published>
    <updated>2018-12-07T18:04:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p> 本文讲述由于正则表达式引发的性能惨案，背景就是使用 Java 编程语言进行正则表达式匹配，由于正则表达式很复杂，再加上 Java 使用的是 NFA（非确定型有穷自动机）匹配引擎，导致匹配一条文本内容使用了十几个小时还没完成，一直卡住，同时线上环境的主机 CPU 使用率也居高不下（我猜的，因为我没有权限看）。</p><a id="more"></a><p> 整理中。</p><p> 参考：<br><a href="http://www.cnblogs.com/study-everyday/p/7426862.html" target="_blank" rel="noopener">http://www.cnblogs.com/study-everyday/p/7426862.html</a><br><a href="https://www.jianshu.com/p/5c2e893b8d5d" target="_blank" rel="noopener">https://www.jianshu.com/p/5c2e893b8d5d</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本文讲述由于正则表达式引发的性能惨案，背景就是使用 Java 编程语言进行正则表达式匹配，由于正则表达式很复杂，再加上 Java 使用的是 NFA（非确定型有穷自动机）匹配引擎，导致匹配一条文本内容使用了十几个小时还没完成，一直卡住，同时线上环境的主机 CPU 使用率也居高不下（我猜的，因为我没有权限看）。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="正则表达式" scheme="https://www.playpi.org/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="Java NFA" scheme="https://www.playpi.org/tags/Java-NFA/"/>
    
      <category term="非确定型有穷自动机" scheme="https://www.playpi.org/tags/%E9%9D%9E%E7%A1%AE%E5%AE%9A%E5%9E%8B%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="正则无限回溯" scheme="https://www.playpi.org/tags/%E6%AD%A3%E5%88%99%E6%97%A0%E9%99%90%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>jackson 包版本低导致 NoSuchMethodError</title>
    <link href="https://www.playpi.org/2018120101.html"/>
    <id>https://www.playpi.org/2018120101.html</id>
    <published>2018-11-30T18:02:03.000Z</published>
    <updated>2018-11-30T18:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>本文讲述 Java 项目由 Maven 包冲突或者版本不合适导致的运行时错误：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: com.fasterxml.jackson.databind.JavaType.isReferenceType()Z</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><h1 id="起因"><a href="# 起因" class="headerlink" title="起因"></a>起因 </h1><p> 今天在升级 Web 项目的相关接口，更新了所依赖的 SDk 版本，删除了一些旧代码，测试时发现某个功能不可用，直接抛出异常，异常是在运行时抛出的，编译、打包、部署都没有任何问题。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqmy8sggbj213t0eyq5s.jpg" alt="NoSuchMethodError 异常" title="NoSuchMethodError 异常"></p><p>我看到第一眼，就知道肯定是 Maven 依赖问题，要么是版本冲突（存在不同版本的 2 个相同依赖），要么是依赖版本不对（太高或者太低），但为了保险起见，我还是先检查了一下 Git 的提交记录，看看有没有对 pom.xml 配置文件做相关改动。检查后发现，除了一些业务逻辑的变动，以及无关 jackson 依赖的版本升级，没有其它对 pom.xml 文件的改动，由此可以断定，某个依赖的升级导致了此问题，问题原因找到了，接下来就是解决问题。</p><h1 id="解决办法"><a href="# 解决办法" class="headerlink" title="解决办法"></a>解决办法 </h1><h2 id="查看项目的 -Maven- 依赖树"><a href="# 查看项目的 -Maven- 依赖树" class="headerlink" title="查看项目的 Maven 依赖树"></a> 查看项目的 Maven 依赖树 </h2><p> 由于依赖太多，使用可视化的插件查看太繁杂，所以选择直接使用 maven 的 dependency 构件来生成文本，然后再搜索查看：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree &gt; tree.txt</span><br></pre></td></tr></table></figure><p></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqnq28eqmj20nb071jrm.jpg" alt="mvn 命令行脚本" title="mvn 命令行脚本"></p><p>在 tree.txt 文件中搜索 jackson，可以找到 jackson-databind 相关的依赖包，还有 jackson-annotations、jackson-core 这 2 个依赖包。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqob296i5j218a0q2whw.jpg" alt="jackson 依赖搜索" title="jackson 依赖搜索"></p><p>jackson-databind 的版本为 2.9.3<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqovrmijgj20vz0gg0ub.jpg" alt="jackson-databind 的版本" title="jackson-databind 的版本"></p><p>确定了使用的版本，接下来可以在 IDEA 里面搜索一下这个类，然后再找调用的方法，直接去查看源码，看看到底有没有这个方法。搜索 JavaType Java 类，注意包的路径，可能会有很多重名的类出现，我是用 Ctrl + Shift + T 的快捷键搜索，各位根据自己的快捷键设置进行搜索。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqoyomz3nj21ha0ketbp.jpg" alt="搜索 JavaType 类" title="JavaType"></p><p>然后进入类的源代码，搜索方法 isReferenceType，报错信息后面的大写的 Z，是 JNI 字段描述符，表示这个方法的返回值类型，Z 表示 Boolean 类型，我们搜索看看有没有这个方法。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqp3posd9j218h0l2dhd.jpg" alt="搜索方法 isReferenceType" title="搜索方法 isReferenceType"></p><p>我们发现连同名的方法都没有，更不用看返回值类型了，但是注意还是要去父类还有接口里面去搜索一下，保证都没有才是最终的没有。经过查找，没发现这个方法（主要原因是父类 ResolvedType 的版本太低，父类所在的 jackson-core 的版本只有 2.3.3，所以找不到这个方法），到这里就要准备升级 jackson-core 或者降级 jackson-databind 依赖了。</p><h2 id="去除多余依赖"><a href="# 去除多余依赖" class="headerlink" title="去除多余依赖"></a>去除多余依赖 </h2><p> 如果是检查到存在依赖冲突的情况，一般是高低版本之间的冲突（最多的情况是多级传递依赖引起的），然后 Maven 编译打包时会全部打进业务的包。</p><p>1、导致运行时程序不知道选择哪一个，于是抛出 NoSuchMethodError 异常，此时根据需要，移除多余的依赖包即可；</p><p>2、步骤 1 操作后，还是一种可能是虽然只存在一个版本，但是由于版本太新或者太旧，无法兼容所有的调用，导致多处需要调用这个依赖包的地方总会有某个地方出现 NoSuchMethodError 异常。此时就比较麻烦，如果能找到一个合适版本的依赖包，兼容所有的调用，当然是好的；或者升级调用处对应的接口版本；如果还是无法解决，就只能通过 Shade 构件解决问题了，此处就不赘述了。</p><p>经过检查，我这里遇到的就是步骤 2 的情况，虽然只剩下一个依赖包，但是版本太低或者太高，导致调用时找不到 isReferenceType 方法，类其实是存在的，所以要采用升级或者降级的方式。</p><h2 id="升级降级依赖"><a href="# 升级降级依赖" class="headerlink" title="升级降级依赖"></a>升级降级依赖 </h2><p> 如果是检查到只有一个依赖，并没有冲突的情况，就容易了，直接找到最稳定的版本或者适合使用的旧版本，提取依赖的坐标，配置到 pom.xml 文件中即可。</p><p>经过检查，我这里遇到的就是这种情况，去 Maven 私服中搜索 jackson，找到合适的版本（自己根据需要选择，我这里选择 jackson-databind 的 2.9.7 版本，然后 jackson-core 也指定 2.9.7 版本，就可以了，然后又查资料也发现这个方法是 2.6.0 版本之后才开始加上的），配置到 pom.xml 文件中即可。</p><p>私服搜索 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqnn8b0rmj219s0nugn4.jpg" alt="jackson 搜索" title="jackson 搜索"></p><p> 配置到 pom.xml<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqq62vwuvj20mw07kdg4.jpg" alt="jackson 配置" title="jackson 配置"></p><p>我这里使用了常量，在 pom.xml 文件的 properties 属性下面配置即可。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxqq73kgcsj20oo02o746.jpg" alt="Maven 版本常量" title="Maven 版本常量"></p><h1 id="踩坑总结"><a href="# 踩坑总结" class="headerlink" title="踩坑总结"></a>踩坑总结</h1><p>1、其实 jackson 这个依赖我并没有使用，而是引用的一个第三方依赖内部使用的，但是这个第三方依赖并没有一同打进来，也没有说明需要什么版本的，所以导致我自己在实验，最终找到到底哪一个版本合适。</p><p>2、为了统一，jackson-core 的版本要与 jackson-databind 的版本一致，jackson-databind 里面是已经自带了 jackson-annotations 的，由于 jackson-databind 里面的类继承了 jackson-core 里面的，所以才都要升级并且保持版本一致。</p><p>3、搜索类方法时，注意留意父类和接口里面，不一定非要在当前类里面出现。更改版本后同样也去类里面搜索一下，看看有没有需要调用的方法出现，确定版本用对了再继续做测试。</p><p>4、这种错误在编译、打包、部署阶段是检查不出来的，因为代码并没有实际调用到，属于运行时错误，只有跑起来程序，执行到需要使用该方法的时候，才会报错。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本文讲述 Java 项目由 Maven 包冲突或者版本不合适导致的运行时错误：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.lang.NoSuchMethodError: com.fasterxml.jackson.databind.JavaType.isReferenceType()Z&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="NoSuchMethodError" scheme="https://www.playpi.org/tags/NoSuchMethodError/"/>
    
      <category term="jackson" scheme="https://www.playpi.org/tags/jackson/"/>
    
      <category term="Maven" scheme="https://www.playpi.org/tags/Maven/"/>
    
      <category term="SpringMVC" scheme="https://www.playpi.org/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 个人站点绑定独立的域名</title>
    <link href="https://www.playpi.org/2018112701.html"/>
    <id>https://www.playpi.org/2018112701.html</id>
    <published>2018-11-27T03:55:57.000Z</published>
    <updated>2018-11-27T03:55:57.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p> 随着越来越多的人使用 GitHub，都在里面创建了自己的仓库，或者 clone 了别人的优秀项目，也有很多人想利用 GitHub 自带的 GitHub Pages 来搭建个人博客，此时就可以使用独立的域名 <a href="https://www.username.github.io" target="_blank" rel="noopener">https://www.username.github.io</a> 访问自己的博客，全部的资源都来自于 GitHub，并且是免费的，不需要其它任何配置或者购买，这里面包含域名、流量、带宽、存储空间、Htpps 认证等服务。但是，有的人可能购买了自己的独立域名，例如： <a href="https://www.abc.com" target="_blank" rel="noopener">https://www.abc.com</a> ，并且想把域名直接绑定到 GitHub 免费的域名上面，这样以后访问博客的时候更容易辨识，本文就描述 GitHub Pages 绑定独立域名的操作过程，前提是 GitHub Pages 已经创建完成。</p><a id="more"></a><p> 待整理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;随着越来越多的人使用 GitHub，都在里面创建了自己的仓库，或者 clone 了别人的优秀项目，也有很多人想利用 GitHub 自带的 GitHub Pages 来搭建个人博客，此时就可以使用独立的域名 &lt;a href=&quot;https://www.username.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.username.github.io&lt;/a&gt; 访问自己的博客，全部的资源都来自于 GitHub，并且是免费的，不需要其它任何配置或者购买，这里面包含域名、流量、带宽、存储空间、Htpps 认证等服务。但是，有的人可能购买了自己的独立域名，例如： &lt;a href=&quot;https://www.abc.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.abc.com&lt;/a&gt; ，并且想把域名直接绑定到 GitHub 免费的域名上面，这样以后访问博客的时候更容易辨识，本文就描述 GitHub Pages 绑定独立域名的操作过程，前提是 GitHub Pages 已经创建完成。&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://www.playpi.org/categories/building/"/>
    
    
      <category term="GitHub" scheme="https://www.playpi.org/tags/GitHub/"/>
    
      <category term="个人站点" scheme="https://www.playpi.org/tags/%E4%B8%AA%E4%BA%BA%E7%AB%99%E7%82%B9/"/>
    
      <category term="绑定域名" scheme="https://www.playpi.org/tags/%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Win10 输入法简繁体快捷键与 IDEA 冲突</title>
    <link href="https://www.playpi.org/2018112301.html"/>
    <id>https://www.playpi.org/2018112301.html</id>
    <published>2018-11-23T10:26:03.000Z</published>
    <updated>2018-12-09T10:26:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>用了 2 个月的 Windows 10 系统（教育版），又安装了 IDEA 代码集成工具，开发的时候，发现每一次只要我使用快捷键 Ctrl + Shift + F 格式化代码后（主要作用就是代码对齐），不起作用，而且写中文注释时发现输入法的中文就被切换为了繁体，再来一次就被切换为了简体。到这里，我知道 IDEA 的快捷键与输入法的快捷键冲突了。</p><a id="more"></a><h1 id="解决方案"><a href="# 解决方案" class="headerlink" title="解决方案"></a>解决方案 </h1><p>1、如前文描述，在写代码的过程中发现这个问题，并且看出是快捷键冲突的问题，接下来就要解决它。作为一名工程师，IDEA 的快捷键是因为使用习惯设置的，是写代码效率的保证，不可能更改的，任何与它有冲突的快捷键都要让步，那肯定是要更改输入法的快捷键的；</p><p>2、信心满满，打开 <strong> 搜狗输入法 </strong>的 <strong>属性设置 </strong>界面，找到 <strong>高级 </strong>选项，选择，可以看到里面有 <strong>快捷键 </strong>的相关配置；</p><p>配置所有的快捷键 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0oij39bnj20ld0f0dgj.jpg" alt="快捷键配置" title="快捷键配置"></p><p>3、看了半天，也就这么几个快捷键配置，里面根本没有 <strong> 简体 / 繁体 </strong>切换这一个配置选择，去搜索了一下其它资料，发现 <strong>简体 / 繁体 </strong>切换这一个快捷键是 Windows 10 系统内置的，默认就是 Ctrl + Shift + F，默认是给微软输入法使用的，某些版本的 Windows 10 系统有 bug，无法更改，哪怕卸载微软输入法，安装其它输入法也无效；</p><p>4、我看了我的 Windows 10 系统版本，已经是新版本了，不会有那个 bug 出现了，所以要从系统设置入手了，应该有地方设置才对，查看了语言里面的设置信息，没找到，只能又返回到搜狗输入法里面，这时突然看到里面有一个 <strong>系统功能快捷键 </strong>选项；</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0ort48p1j20ld0f03z6.jpg" alt="系统功能快捷键" title="系统功能快捷键"></p><p>5、就是这里了，点进去，把 <strong>简繁切换 </strong>关闭（如果需要保留的话，更改快捷键即可），解决问题。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0oua7u57j20dv09q3ym.jpg" alt="关闭简繁切换" title="关闭简繁切换"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;用了 2 个月的 Windows 10 系统（教育版），又安装了 IDEA 代码集成工具，开发的时候，发现每一次只要我使用快捷键 Ctrl + Shift + F 格式化代码后（主要作用就是代码对齐），不起作用，而且写中文注释时发现输入法的中文就被切换为了繁体，再来一次就被切换为了简体。到这里，我知道 IDEA 的快捷键与输入法的快捷键冲突了。&lt;/p&gt;
    
    </summary>
    
      <category term="知识改变生活" scheme="https://www.playpi.org/categories/knowledge-for-life/"/>
    
    
      <category term="Win10" scheme="https://www.playpi.org/tags/Win10/"/>
    
      <category term="输入法" scheme="https://www.playpi.org/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
      <category term="快捷键冲突" scheme="https://www.playpi.org/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%86%B2%E7%AA%81/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客静态资源压缩优化</title>
    <link href="https://www.playpi.org/2018112101.html"/>
    <id>https://www.playpi.org/2018112101.html</id>
    <published>2018-11-20T16:53:13.000Z</published>
    <updated>2018-11-20T16:53:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>使用 hexo-cli 生成的静态网页 html 文件，使用文本编辑器打开，可以看到内容中有大量的回车换行等空白符。尽管是空白符，但是也占据着空间大小，而且那么多，导致 html 文件偏大，网页加载时不仅浪费流量，而且还影响速度。同时，最重要的是对于手机端来说，静态页面 html 文件太大了的确不友好。所以要做优化，用术语说是压缩，其实目的就是在生成 html 文件时，尽量去除内容中多余的空白符，减小 html 文件的大小。此外，顺便也把 css 文件、js 文件一起压缩了。</p><a id="more"></a><h1 id="当前现象"><a href="# 当前现象" class="headerlink" title="当前现象"></a>当前现象 </h1><p> 为了简单起见，只是列举 html 文件来看现象，目前查看生成的 8 个 html 静态页面（为了具有对比性，不包含当前页面），大小为 314 K。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxg5iuthmbj20sr0guta4.jpg" alt="8 个 html 文件" title="8 个 html 文件"></p><p>打开其中一个 html 文件查看内容，可以看到很多回车换行符。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxg5kn3bz2j20u00iidgy.jpg" alt="连续多个回车换行符" title="连续多个回车换行符"></p><p>接下来就是要想办法消除这些空白符。</p><h1 id="压缩方式选择"><a href="# 压缩方式选择" class="headerlink" title="压缩方式选择"></a>压缩方式选择 </h1><p> 通过查看 hexo 官网（附上插件库：<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">hexo 插件库 </a>），搜索资料了解别人的例子，发现有两种方式：</p><ul><li> 一种是先全局（-g 参数）安装 gulp 模块，根据压缩需求再安装需要的模块，例如 gulp-htmlclean、gulp-htmlmin、gulp-imagemin、gulp-minify-css、gulp-uglify，每个模块都有自己的功能，另外需要单独配置一个 js 脚本（放在站点根目录下），指明使用的模块，文件所在目录或者通配符文件名，然后每次使用 hexo generate 之后再使用 gulp 就可以压缩文件了。这种方式灵活度高，可以自定义，而且 gulp 的功能与 hexo 解耦，如果有其它静态文件，也可以使用 gulp 进行压缩。但是缺点也显而易见，门槛太高了，根据我的折腾经验，如果出了问题肯定要捣鼓半天，对于我这种零基础的人来说不够友好，我不选择；</li><li>另一种是类似于 hexo 的一个插件，像其它插件或者主题一样，直接安装一个模块，在配置文件中配置你想要的压缩内容，在 hexo generate 的时候就可以实现压缩，无需关心具体流程，也不用配置什么脚本，非常容易，我选择这个，目前我看到有两个类似的插件：<a href="https://github.com/rozbo/hexo-neat" target="_blank" rel="noopener">hexo-neat</a>、<a href="https://github.com/mamboer/hexo-filter-cleanup" target="_blank" rel="noopener">hexo-filter-cleanup</a>，用法都差不多，我选择前者，其实这些插件也是依赖于其它插件，把多种插件的功能整合在一起而已。</li></ul><h1 id="安装配置"><a href="# 安装配置" class="headerlink" title="安装配置"></a>安装配置 </h1><p>hexo-neat 插件其实是使用 HTMLMinifier、clean-css、UglifyJS 插件实现。</p><p> 安装（由于网络不稳定因素，可能不是一次就成功，可以多试几次）<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></table></figure><p></p><p>站点配置 <br> 编辑站点的配置文件 &#95;config.yml，开启对应的属性 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件压缩, 设置一些需要跳过的文件 </span></span><br><span class="line"><span class="comment"># hexo-neat</span></span><br><span class="line">neat_enable: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 压缩 html</span></span><br><span class="line">neat_html:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  exclude:</span><br><span class="line"><span class="comment"># 压缩 css</span></span><br><span class="line">neat_css:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  exclude:</span><br><span class="line">    - <span class="string">'**/*.min.css'</span></span><br><span class="line"><span class="comment"># 压缩 js</span></span><br><span class="line">neat_js:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  mangle: <span class="literal">true</span></span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - <span class="string">'**/*.min.js'</span></span><br><span class="line">    - <span class="string">'**/jquery.fancybox.pack.js'</span></span><br><span class="line">    - <span class="string">'**/index.js'</span></span><br></pre></td></tr></table></figure><h1 id="查看效果"><a href="# 查看效果" class="headerlink" title="查看效果"></a> 查看效果 </h1><p> 在执行 hexo generate 的命令行中就可以看到压缩率输出。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxzdwrue7aj20gj0ahdgr.jpg" alt="压缩率输出" title="压缩率输出"></p><p>8 个 html 文件被压缩后，大小只有 206 K，和之前的 314 K 比少了 108 K，虽然只是简单的数字，也可以看到压缩效果不错。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxg6y7u1mej20ro0guq49.jpg" alt="8 个文件压缩后" title="8 个文件压缩后"></p><p>继续打开先前打开的那个 html 文件，可以看到整个 html 文档被合并成为了一行文本内容，不影响浏览器对 html 文件的解析展示，回车换行的空白符内容肯定没有了。但是这样对于 html 文件的可读性变差了，最好还是使用一些回车换行符的，还好这些 html 文件我不会去看，能接受目前的效果。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxg743fu8jj20u00igq3g.jpg" alt="html 文件内容合并为一行" title="html 文件内容合并为一行"></p><h1 id="踩坑记录"><a href="# 踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><p>1、由于牵涉到压缩文件，所以 hexo 生成静态文件的速度会比以前慢一点，但是可以接受。</p><p>2、不要跳过 .md 文件，也不要跳过 .swig 文件，因为是在 hexo generate 阶段进行压缩的，所以这些文件必须交给 hexo-neat 插件处理，才能保证生成的 html 文件纯净。</p><p>3、参考博客：<a href="https://www.huangzz.xyz/hexo-optimized-file-compression.html" target="_blank" rel="noopener">1</a>、<a href="https://blog.csdn.net/lewky_liu/article/details/82432003" target="_blank" rel="noopener">2</a>、<a href="https://www.ecpeng.com/2018/04/02/%E5%85%B3%E4%BA%8Ehexo%E5%8D%9A%E5%AE%A2%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">3</a>、<a href="https://juejin.im/post/5a93c9385188257a84625aad" target="_blank" rel="noopener">4</a>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;使用 hexo-cli 生成的静态网页 html 文件，使用文本编辑器打开，可以看到内容中有大量的回车换行等空白符。尽管是空白符，但是也占据着空间大小，而且那么多，导致 html 文件偏大，网页加载时不仅浪费流量，而且还影响速度。同时，最重要的是对于手机端来说，静态页面 html 文件太大了的确不友好。所以要做优化，用术语说是压缩，其实目的就是在生成 html 文件时，尽量去除内容中多余的空白符，减小 html 文件的大小。此外，顺便也把 css 文件、js 文件一起压缩了。&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://www.playpi.org/categories/building/"/>
    
    
      <category term="建站" scheme="https://www.playpi.org/tags/building/"/>
    
      <category term="Hexo" scheme="https://www.playpi.org/tags/Hexo/"/>
    
      <category term="代码压缩" scheme="https://www.playpi.org/tags/%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>Google 账号开启两步验证与应用专用密码</title>
    <link href="https://www.playpi.org/2018111901.html"/>
    <id>https://www.playpi.org/2018111901.html</id>
    <published>2018-11-19T13:17:59.000Z</published>
    <updated>2018-11-19T13:17:59.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>使用 Google 账号的都知道，带来了很多方便，不仅有强大的免费搜索服务，还有 Google 文档、云主机、云存储等各种服务，但是唯一的缺点是需要翻墙，让一些人望而却步，把很多人挡在了便利门外。本文是针对已经实现翻墙愿望，并在日常工作中会使用到 Google 账号的人，说不定可以给你带来一些冷知识，解决一些小问题。</p><a id="more"></a><h1 id="Google- 账号的便利性"><a href="#Google- 账号的便利性" class="headerlink" title="Google 账号的便利性"></a>Google 账号的便利性 </h1><p> 目前在日常工作与生活中，查找资料时，基本使用的都是 Google 搜索，并且使用非常好用的 Chrome 浏览器。其中我用的最多就是标签收藏，平时偶尔搜到什么有用的知识点或者需要反复查看的网页，来不及看完整理，就先把网页分类收藏了，以便日后查漏补缺。</p><p>此时，利用 Chrome 浏览器的标签收藏功能，可以很方便地把一切网页收藏起来，并且可以很好地分类存放，清晰明了。可能有人说也有很多其它的工具可以做到这一点，不久收藏吗？但是我觉得还是利用 Chrome 浏览器自带的这个功能比较好，再配合 Google 账号，就可以达到同步更新的效果了，公司的电脑、家里的电脑，只要都登录了 Google 账号，所有收藏的标签都可以实时同步。而且，所有的浏览记录、搜索历史、记住的账号密码等等，都可以同步，跨机器使用也很方便。再配合 Chrome 浏览器的插件，对收藏的网页搜索起来非常方便。</p><h1 id="Google- 账号开启两步验证"><a href="#Google- 账号开启两步验证" class="headerlink" title="Google 账号开启两步验证"></a>Google 账号开启两步验证 </h1><p> 为了安全起见，最好给 Google 账号开启两步验证，可以选择绑定手机号、启用身份验证器、安全密钥等方式，为了方便，我选择了绑定手机号。开启两步验证后，在陌生的设备上登录 Google 账号（包括 Google 自家的各种应用，例如邮件、YouTube 等）需要验证码的二次验证，当然，如果把设备设置为可信任的设备，则不需要每次都重复输入验证码。</p><p>开启的方式非常简单，登录 Google 账号，在”登录与安全 “中有” 两步验证“的开启选项，选择自己需要的方式，继续即可。</p><p>启两步验证 1<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxdpircndxj21hc0q2ac6.jpg" alt="开启两步验证 1" title="开启两步验证 1"></p><p>启两步验证 2<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxdpjdxg23j21hc0q20u8.jpg" alt="开启两步验证 2" title="开启两步验证 2"></p><p>如果使用”身份验证器 “的方式，还需要在手机上安装一个” 身份验证器 “应用，校准时间后，每隔 30 秒更新验证码，登录账号时需要使用当前的验证码，并且在有效期内完成登录的操作，否则验证码过期，需要使用新的验证码，类似于手机收到的验证码只有 1 分钟一样。同时，如果使用 Google 邮箱账号注册了其它平台的账号，例如注册了 Twitter，注册了 Facebook，为了安全起见也可以使用” 身份验证器“的方式，一种验证方式管理着多种账号的安全。</p><h1 id="开启两步验证后带来的问题"><a href="# 开启两步验证后带来的问题" class="headerlink" title="开启两步验证后带来的问题"></a>开启两步验证后带来的问题 </h1><p> 我遇到的问题之一就是自己手机的邮件客户端无法登录 Google 邮箱了，我使用的时第三方邮件客户端，总是提示我密码错误，其实密码没有错误，是因为 Google 账号开启两步验证后，邮箱的登录也需要对应方式的验证，但是第三方邮件应用并没有做这个验证，所以无法登录。</p><p>本来是想着单独把 Google 邮箱的两步验证关闭，但是找了半天设置选项也没有找到，看来 Google 账号已经是一个大统一的账号，不允许单独设置涉及安全性的信息，可以理解。</p><p>同理，使用其它应用客户端也会遇到相同的问题，当然，Google 官方解释说明也解释了有部分设备不需要关注这个问题，其它大部分设备或者应用还是要受到影响的。</p><p>见：<a href="https://support.google.com/mail/answer/185833?hl=zh-Hans&amp;visit_id=636782289170925112-3791602481&amp;rd=1" target="_blank" rel="noopener">使用应用专用密码登录 </a><br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxdpwpmmroj20ru0oimyf.jpg" alt="解释说明" title="解释说明"></p><p> 此时，需要使用”应用专用密码 “或者在手机上开发一个” 具有账号访问权限的应用“用来代理整个 Google 的账号访问。</p><h1 id="问题的解决方法"><a href="# 问题的解决方法" class="headerlink" title="问题的解决方法"></a>问题的解决方法 </h1><h2 id="应用专用密码方式的使用"><a href="# 应用专用密码方式的使用" class="headerlink" title="应用专用密码方式的使用"></a> 应用专用密码方式的使用 </h2><h3 id="1、在 -Google- 账号的登录和安全中，可以找到”应用专用密码“这个选项："><a href="#1、在 -Google- 账号的登录和安全中，可以找到”应用专用密码“这个选项：" class="headerlink" title="1、在 Google 账号的登录和安全中，可以找到”应用专用密码“这个选项："></a>1、在 Google 账号的登录和安全中，可以找到”应用专用密码“这个选项：</h3><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxdq2531orj21hc0q2wgl.jpg" alt="应用专用密码" title="应用专用密码"></p><h3 id="2、点击进入后，可以看到选择应用与选择设备，由于我使用的是一种不知名的 -Android- 手机，所以官方选项中没有可以选择的，只好自定义一种，随便起一个名字标识即可。"><a href="#2、点击进入后，可以看到选择应用与选择设备，由于我使用的是一种不知名的 -Android- 手机，所以官方选项中没有可以选择的，只好自定义一种，随便起一个名字标识即可。" class="headerlink" title="2、点击进入后，可以看到选择应用与选择设备，由于我使用的是一种不知名的 Android 手机，所以官方选项中没有可以选择的，只好自定义一种，随便起一个名字标识即可。"></a>2、点击进入后，可以看到选择应用与选择设备，由于我使用的是一种不知名的 Android 手机，所以官方选项中没有可以选择的，只好自定义一种，随便起一个名字标识即可。</h3><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxdq4j220pj21hc0q2wfb.jpg" alt="应用设备选择" title="应用设备选择"></p><h3 id="3、选择完成后，会生成一串 -16- 位的密码，这个密码就可以在其它设备上登录的时候使用，不需要使用原来的密码，也不需要使用 -Google- 验证码。"><a href="#3、选择完成后，会生成一串 -16- 位的密码，这个密码就可以在其它设备上登录的时候使用，不需要使用原来的密码，也不需要使用 -Google- 验证码。" class="headerlink" title="3、选择完成后，会生成一串 16 位的密码，这个密码就可以在其它设备上登录的时候使用，不需要使用原来的密码，也不需要使用 Google 验证码。"></a>3、选择完成后，会生成一串 16 位的密码，这个密码就可以在其它设备上登录的时候使用，不需要使用原来的密码，也不需要使用 Google 验证码。</h3><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxdq6klijxj21hc0q2ta4.jpg" alt="生成专用密码" title="生成专用密码"></p><h3 id="4、在使用过程中还可以看到设备的情况。"><a href="#4、在使用过程中还可以看到设备的情况。" class="headerlink" title="4、在使用过程中还可以看到设备的情况。"></a>4、在使用过程中还可以看到设备的情况。</h3><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxdqasrztdj21hc0q20ud.jpg" alt="设备活动和安全事件" title="设备活动和安全事件"></p><h2 id="具有账号访问权限的应用的使用"><a href="# 具有账号访问权限的应用的使用" class="headerlink" title="具有账号访问权限的应用的使用"></a> 具有账号访问权限的应用的使用 </h2><p> 这种方式就是手机本身有一个后台应用，代理了 Google 账号的一切请求，把信息转发到本地应用（比如 Chrome 浏览器就是这样一个应用，只不过是官方开发的，只要登录了 Google 账号，邮件、YouTube、搜索、Play、相册、日历等等这些应用同步一起使用，不需要额外再登录，这也是我使用 Chrome 浏览器的原因。），所以后台应用如果知道了 Google 账号的用户名、密码，就可以代理所有 Google 应用的请求，无需关心 应用专用密码了。</p><p>我发现锤子手机的 Smartisan OS 系统（v6.0.3，Android 版本 7.1.1）对邮件就做了这个后台应用 Smartisan Mail，所以在使用内置的邮件客户端时，即使开启了两步验证，也无需关心验证码的问题（第一次登录还是需要验证的）。</p><p>下面截图则是一步一步设置：</p><h3 id="1、在邮件客户端设置中添加 -Google- 邮箱"><a href="#1、在邮件客户端设置中添加 -Google- 邮箱" class="headerlink" title="1、在邮件客户端设置中添加 Google 邮箱"></a>1、在邮件客户端设置中添加 Google 邮箱</h3><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxdqs7cpoqj20u01meq6k.jpg" alt="添加 Google 邮箱 1" title="添加 Google 邮箱 1"></p><h3 id="2、输入 -Google- 账号密码（也是邮箱密码）"><a href="#2、输入 -Google- 账号密码（也是邮箱密码）" class="headerlink" title="2、输入 Google 账号密码（也是邮箱密码）"></a>2、输入 Google 账号密码（也是邮箱密码）</h3><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxdqt5xsawj20u01mf0vr.jpg" alt="添加 Google 邮箱 2" title="添加 Google 邮箱 2"></p><h3 id="3、输入验证码（由于开启了两步验证，一定需要），此时切记勾选”在此计算机上不再询问“，才能保证邮件客户端正常收发 -Goole- 邮件，否则不行。"><a href="#3、输入验证码（由于开启了两步验证，一定需要），此时切记勾选”在此计算机上不再询问“，才能保证邮件客户端正常收发 -Goole- 邮件，否则不行。" class="headerlink" title="3、输入验证码（由于开启了两步验证，一定需要），此时切记勾选”在此计算机上不再询问“，才能保证邮件客户端正常收发 Goole 邮件，否则不行。"></a>3、输入验证码（由于开启了两步验证，一定需要），此时切记勾选”在此计算机上不再询问“，才能保证邮件客户端正常收发 Goole 邮件，否则不行。</h3><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxdqto569aj20u01mcjvf.jpg" alt="添加 Google 邮箱 3" title="添加 Google 邮箱 3"></p><h3 id="4、允许，可以看到 -Smartisan-Mail- 想要访问 -Google- 账号"><a href="#4、允许，可以看到 -Smartisan-Mail- 想要访问 -Google- 账号" class="headerlink" title="4、允许，可以看到 Smartisan Mail 想要访问 Google 账号"></a>4、允许，可以看到 Smartisan Mail 想要访问 Google 账号</h3><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxdqtv52cej20u01mejz8.jpg" alt="添加 Google 邮箱 4" title="添加 Google 邮箱 4"></p><h3 id="5、点开 -Smartisan-Mail，可以看到开发者信息，里面其实设置了代理转发"><a href="#5、点开 -Smartisan-Mail，可以看到开发者信息，里面其实设置了代理转发" class="headerlink" title="5、点开 Smartisan Mail，可以看到开发者信息，里面其实设置了代理转发"></a>5、点开 Smartisan Mail，可以看到开发者信息，里面其实设置了代理转发</h3><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxdqtysi1cj20u01matef.jpg" alt="添加 Google 邮箱 5" title="添加 Google 邮箱 5"></p><h3 id="6、此外，在登录成功后，在 -Google- 账号的登录和安全中，可以看到具有账号访问权限的应用："><a href="#6、此外，在登录成功后，在 -Google- 账号的登录和安全中，可以看到具有账号访问权限的应用：" class="headerlink" title="6、此外，在登录成功后，在 Google 账号的登录和安全中，可以看到具有账号访问权限的应用："></a>6、此外，在登录成功后，在 Google 账号的登录和安全中，可以看到具有账号访问权限的应用：</h3><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxdqoifycuj21hc0q2myw.jpg" alt="Smartisan Mail" title="Smartisan Mail"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;使用 Google 账号的都知道，带来了很多方便，不仅有强大的免费搜索服务，还有 Google 文档、云主机、云存储等各种服务，但是唯一的缺点是需要翻墙，让一些人望而却步，把很多人挡在了便利门外。本文是针对已经实现翻墙愿望，并在日常工作中会使用到 Google 账号的人，说不定可以给你带来一些冷知识，解决一些小问题。&lt;/p&gt;
    
    </summary>
    
      <category term="知识改变生活" scheme="https://www.playpi.org/categories/knowledge-for-life/"/>
    
    
      <category term="Google 账号" scheme="https://www.playpi.org/tags/Google-%E8%B4%A6%E5%8F%B7/"/>
    
      <category term="两步验证" scheme="https://www.playpi.org/tags/%E4%B8%A4%E6%AD%A5%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>使用 Vultr 搭建 Shadowsocks（VPS 搭建 SS）</title>
    <link href="https://www.playpi.org/2018111601.html"/>
    <id>https://www.playpi.org/2018111601.html</id>
    <published>2018-11-16T11:25:52.000Z</published>
    <updated>2018-11-16T11:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --><p>本文讲述通过 Vultr 云主机搭建 Shadowsocks 的过程，非常不详细。当然，关于云主机很多 VPS 都可以选择，根据价格、配置、地区等可以自由选择。</p><a id="more"></a><h1 id="主机购买"><a href="# 主机购买" class="headerlink" title="主机购买"></a>主机购买 </h1><p> 使用 Vultr 的云主机，选择洛杉矶地区的或者日本的，我的推广链接：<a href="https://www.vultr.com/?ref=7443790" target="_blank" rel="noopener">我的推广链接 </a>，官网：<a href="https://my.vultr.com" target="_blank" rel="noopener">Vultr</a>。</p><p> 价格有 &#36;2.5 / 月（只有 IP6 地址）、&#36;3.5 / 月、&#36;5 / 月等等，更贵的也有，一般选择这三个中的一个就够用了，但是要注意便宜的经常售罄，而且最便宜的只支持 IP6，慎用。</p><h1 id="Shadowsocks- 服务安装"><a href="#Shadowsocks- 服务安装" class="headerlink" title="Shadowsocks 服务安装"></a>Shadowsocks 服务安装 </h1><p> 云主机选择 CentOS 7 x64 版本，全程操作使用 Linux 命令（注意，如果选择其它系统命令会不一致，请自己查询，例如：Debian/Ubuntu 系统的安装命令更简洁，先 apt-get install python-pip，再 pip install shadowsocks 即可）。</p><p>注意如果安装了防火墙（更安全），需要的端口一定要开启，否则启动 Shandowsocks 会失败。</p><p>安装组件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install m2crypto python-setuptools</span><br><span class="line">easy_install pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><p>过程如图：</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxa31ivc8mj21hc0mhdh5.jpg" alt="python-setuptools 安装" title="python-setuptools 安装"></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxa3g9phq7j21hc0jb405.jpg" alt="pip 安装" title="pip 安装"></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxa3h3eeyaj210k04edfx.jpg" alt="ss 安装" title="ss 安装"></p><p>配置服务器参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi  /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><p>如下列出主要参数解释说明 </p><table><thead><tr><th style="text-align:center"> 参数名称 </th><th style="text-align:center"> 解释说明 </th></tr></thead><tbody><tr><td style="text-align:center">server</td><td style="text-align:center"> 服务器地址，填 ip 或域名 </td></tr><tr><td style="text-align:center">local_address</td><td style="text-align:center"> 本地地址 </td></tr><tr><td style="text-align:center">local_port</td><td style="text-align:center"> 本地端口，一般 1080，可任意 </td></tr><tr><td style="text-align:center">server_port</td><td style="text-align:center"> 服务器对外开的端口 </td></tr><tr><td style="text-align:center">password</td><td style="text-align:center"> 密码，每个端口可以设置不同的密码 </td></tr><tr><td style="text-align:center">port_password</td><td style="text-align:center">server_port + password ，服务器端口加密码的组合</td></tr><tr><td style="text-align:center">timeout</td><td style="text-align:center"> 超时重连 </td></tr><tr><td style="text-align:center">method</td><td style="text-align:center"> 加密方法，默认：“aes-256-cfb”</td></tr><tr><td style="text-align:center">fast_open</td><td style="text-align:center">开启或关闭 <a href="https://github.com/shadowsocks/shadowsocks/wiki/TCP-Fast-Open" target="_blank" rel="noopener">TCP_FASTOPEN</a>，填 true / false，需要服务端支持 </td></tr></tbody></table><p> 配置多端口信息（多个帐号，多人也可用）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>: <span class="string">"你的 IP 地址"</span>（例如：<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>）,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>（默认值）,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>（默认值）,</span><br><span class="line">    "port_password"（开启的端口和密码，自己按需配置，确保端口打开并不被其它程序占用）: &#123;</span><br><span class="line">        "1227": "pengfeivpn1227",</span><br><span class="line">        "1226": "pengfeivpn1226",</span><br><span class="line">        "1225": "pengfeivpn"</span><br><span class="line">    &#125;,</span><br><span class="line">    "timeout":300（超时时间，默认值）,</span><br><span class="line">    "method":"aes-256-cfb"（加密方法，默认值）,</span><br><span class="line">    "fast_open": false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置多端口信息（纯净版本，更改 ip、端口等信息直接复制使用）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>: <span class="string">"x.x.x.x"</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"port_password"</span>: &#123;</span><br><span class="line">        <span class="attr">"1227"</span>: <span class="string">"vpn1227"</span>,</span><br><span class="line">        <span class="attr">"1226"</span>: <span class="string">"vpn1226"</span>,</span><br><span class="line">        <span class="attr">"1225"</span>: <span class="string">"vpn"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置一个端口信息（只有一个帐号，多人也可用）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"你的 IP 地址"</span>（例如：<span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span>）,  </span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">1225</span>（唯一的端口）,</span><br><span class="line">    <span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"pengfeivpn"</span>（唯一的密码）,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置一个端口信息（纯净版本，更改 ip、端口等信息直接复制使用）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"x.x.x.x"</span>,  </span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">1225</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"vpn"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shadowsocks 性能优化：</p><p>另外还有很多参数可以优化性能，例如设置连接数、字节大小等，比较复杂，在此略过。</p><p>防火墙安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装防火墙 </span></span><br><span class="line">yum install firewalld</span><br><span class="line"><span class="comment"># 启动防火墙 </span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"><span class="comment"># 端口号是你自己设置的端口 </span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=1225/tcp</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=1226/tcp</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=1227/tcp</span><br><span class="line"><span class="comment"># 重载更新的端口信息 </span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>过程如图：</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxa3il37mlj20ka074dfy.jpg" alt="安装启动防火墙" title="安装启动防火墙"></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxa3hxmaftj20jd04zmx6.jpg" alt="开启端口重载" title="开启端口重载"></p><p>启动 Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后台运行    </span></span><br><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line"><span class="comment"># 调试时使用下面命令，实时查看日志 </span></span><br><span class="line">ssserver -c /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><p>过程如图：</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxa3j16ymwj20hf03eglj.jpg" alt="启动 ss" title="启动 ss"></p><h1 id="客户端使用"><a href="# 客户端使用" class="headerlink" title="客户端使用"></a>客户端使用 </h1><h2 id="Windows- 平台使用"><a href="#Windows- 平台使用" class="headerlink" title="Windows 平台使用"></a>Windows 平台使用</h2><p> 下载 Windows 平台的客户端，下载地址：<a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener">shadowsocks-windows GitHub</a>，<a href="http://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">shadowsocks 官网 </a>，直接解压放入文件夹即可使用，不需要安装。</p><p> 但是注意配置内容（端口、密码、加密协议等等），另外注意有些 Windows 系统缺失 Shadowsocks 必要的组件（.NET Framework），需要安装，官网也有说明。</p><p>配置示例：</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxa3pjtymuj20g60dp75k.jpg" alt="ss 配置" title="ss 配置"></p><p>实际上下载程序后，无需安装，直接解压即可，解压后只有一个 exe 文件，双击即可运行（最好放入指定文件夹中，便于程序管理和升级）。第一次启动，需要设置参数，如上图所示，至少配置一台机器，另外还可以设置开机启动，以后不用重新打开。此外，如果有更新版本的程序，会放在 ss_win_temp 文件夹下，直接解压后复制替换掉当前的 exe 文件即可；如果文件夹中有 gui-config.json、statistics-config.json 这 2 个文本文件，它们是程序的配置以及前面设置的翻墙配置，不能删掉；如果使用系统代理的 PAC 模式（推荐使用），会生成 pac.txt 文本文件，存放从 GFWList 获取的被墙的网址，必要时才会通过翻墙代理访问，其它正常的网址则直接访问，这样可以节约流量。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3ly1fxbhx6e12jj20h004qgln.jpg" alt="ss 文件夹" title="ss 文件夹"></p><p>如果有切换代理的需求，搭配浏览器的插件来完成，例如 <a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=zh-CN" target="_blank" rel="noopener">Proxy SwitchyOmega</a> 就可以。</p><p>关于启动系统代理并使用 PAC 模式（根据条件过滤，不满足的直连），如果是入门级别使用，直接设置完就可以用了，不用再管其它设置，切记要定时更新 GFWList 列表，因为如果某些网站最近刚刚被屏蔽，不在以前的 HFWList 列表里面，就会导致无法连接，只有及时更新才能正常连接。但是还有一种极端情况，就是某些网站 GFWList 迟迟没有收录，怎么更新都不会起作用，别着急，此时可以使用用户自定义规则，模仿 GFWList 填写自己的过滤规则，即可实现灵活的切换，使用用户自定义规则后会在安装文件夹中生成 user-rule.txt 文本文件。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxbo5moanxj20cj0a5dga.jpg" alt="开启系统代理并使用 PAC 模式" title="开启系统代理并使用 PAC 模式"></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxbo6rej96j20ip0axjs7.jpg" alt="PAC 模式下更新 GFWList 内容" title="PAC 模式下更新 GFWList 内容"></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxbo7ifow9j20j80apt9k.jpg" alt="PAC 模式下自定义过滤规则" title="PAC 模式下自定义过滤规则"></p><p>其实，PAC 模式的原理就是根据公共的过滤规则（收集被屏蔽的网站列表），自动生成了一个脚本文件，把脚本文件绑定到浏览器的代理设置中，使浏览器访问网站前都会运行这个脚本，根据脚本的结果决定是直接访问还是通过本地代理访问，脚本在 Shadowsocks 的 PAC 设置中可以看到，浏览器的设置信息可以在代理设置中看到（浏览器在 Shadowsocks 开启系统代理的时候会自动设置代理，无需人工干预）。由此可以得知，通过本机访问网络，决定是直接连接还是通过 Shadowsocks 代理连接的是 PAC 脚本，并不是 Shadowsocks 本身，所以如果使用系统的 Ping 命令访问 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 仍然是不能访问的，因为直接 Ping 没有经过 PAC 脚本，还是直接连接了，不可能访问成功。除了浏览器之外，如果其它程序也想访问被屏蔽的网站（例如 Git、Maven 仓库），只能通过程序自己的代理设置进行配置，完成访问的目的。（如果放弃 PAC 模式，直接使用全局模式，则不需要配置任何信息，本机所有的网络请求会全部经过翻墙代理，当然这样做会导致流量消耗过大，并且国内的正常网站访问速度也会很慢）</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxbof33m9dj20ij0aa0tl.jpg" alt="获取 PAC 的脚本地址" title="获取 PAC 的脚本地址"></p><p>获取到的 PAC 脚本地址为：<br><a href="http://127.0.0.1:1080/pac?t=20181118030355597&amp;secret=qZKsW49fDFezR4jJQtRDhUVPRqnFu6JC3Nc+vtXDb0g=" target="_blank" rel="noopener">http://127.0.0.1:1080/pac?t=20181118030355597&amp;secret=qZKsW49fDFezR4jJQtRDhUVPRqnFu6JC3Nc+vtXDb0g=</a></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxboiacqtbj20se0kojse.jpg" alt="浏览器代理配置" title="浏览器代理配置"></p><p>以上是查看 Chrome 浏览器和 IE 浏览器的代理设置信息，对于 Microsoft Edge（Windows 10 自带）浏览器来说，界面有点不一样，在设置 -&gt; 高级 -&gt; 代理设置里面。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxbooa2ikvj20xc0pwq93.jpg" alt="Edge 浏览器设置代理脚本" title="Edge 浏览器设置代理脚本"></p><p>此外，如果在浏览器中有更灵活的需求应用， 例如在设置多个代理的情况下，针对公司内网是一套，针对指定的几个网站是一套，针对被屏蔽的网站是一套，剩余的直接连接。在这种情况下仅仅使用代理脚本就不能完成需求了，显得场景很单一，当然也可以把脚本写的复杂一点，但是成本太高，而且不方便维护更新。这个时候就需要浏览器的插件出场了，例如在 Chrome 下我选择了 <a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=zh-CN" target="_blank" rel="noopener">SwitchyOmega</a> 这个插件，可以设置多种情景模式，根据实际情况自由切换，非常方便。我设置了三种情景模式：hdpProxy（公司内网）、shadowSocks（翻墙代理）、auto switch（根据条件自动切换），前面两种情景模式直接设置完成即可，最后的 auto switch 需要配置得复杂一点，根据正则表达式或者通配符指定某些网站的访问方式必须使用 hdpProxy 代理，另外其它的根据规则列表 <br>（<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> ，和 Shadowsocks 的 GFWList 列表类似）必须通过翻墙代理，剩余的才是直接连接。当然，此时就不需要把 Shadowsocks 设置为系统代理了，保持 Shadowsocks 后台运行就可以了。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxbp79ywuej21hc0q20v7.jpg" alt="SwitchyOmega 插件配置" title="SwitchyOmega 插件配置"></p><h2 id="Android- 平台使用"><a href="#Android- 平台使用" class="headerlink" title="Android 平台使用"></a>Android 平台使用</h2><p> 下载 Android 平台的客户端，下载地址：<a href="http://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">shadowsocks 官网 </a>。</p><h1 id="踩坑记录"><a href="# 踩坑记录" class="headerlink" title="踩坑记录"></a> 踩坑记录 </h1><p>1、在云主机安装服务端后，又安装了防火墙，但是没有开启 Shadowsocks 需要的端口，导致启动 Shadowsocks 总是失败，但是报错信息又是 Python 和 Linux 的，看不懂，搜索资料也搜不到，后来重装，并且想清楚每一步骤是干什么的，会造成什么影响，通过排除法找到了根本原因。</p><p>2、在 Windows 平台使用的时候，安装了客户端，也安装了 .NET Framework 组件，配置信息确认无误，但是就是上不了外网，同样的操作使用 Android 客户端却可以，所以有理由怀疑是自己的主机问题。后来，重启系统，检查网络，关闭杀毒软件，还是不行，后来，依靠搜索，找到了是杀毒软件 Avast 的问题，扫描 SSL 连接被开启了，大坑，关闭即可。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxa0mkrws7j20pc0nkglz.jpg" alt="Avast 截图"></p><p>3、参考：<a href="https://github.com/sirzdy/shadowsocks" target="_blank" rel="noopener"> 梯子搭建</a></p><p>4、本来以为 Shadowsocks 的系统代理中的 PAC 模式会在接收到网络请求的基础上进行过滤，即 Shadowsocks 能控制所有的网络请求进行过滤判断，然后该翻墙的翻墙，该直连的直连，后来发现不是的，浏览器插件 SwitchyOmega 设置代理规则后，PAC 脚本就不会生效了，全部使用 Shadowsocks 代理的网站都直接翻墙，不会有任何判断了，导致优酷视频消耗了大量的流量，而且速度还很慢。另外，为了保证国内的网站不是经过翻墙代理，能直接连接，就不能使用全局模式。</p><p>5、使用插件 SwitchyOmega 的过程中，一开始是自己整理一些规则，而没有使用<br><a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> 列表规则，导致配置信息很多，而且自己看着头都大，不好维护与查看，后来就发现了列表规则，解放了劳动力。</p><p>6、解决了 Chrome 浏览器的收藏跨平台自动更新同步的问题，以前在三台电脑之间添加取消收藏，总是不能更新同步，需要手动开启系统代理设置全局模式（Chrome 浏览器的收藏同步功能被屏蔽了，我又不知道 url 是什么），等一会更新同步之后再关闭（防止其它场景也翻墙了）。目前使用规则列表，收藏可以自动更新同步了，不需要手动来回切换了，也不用担忘记同步的情况了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Dec 29 2018 00:31:44 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本文讲述通过 Vultr 云主机搭建 Shadowsocks 的过程，非常不详细。当然，关于云主机很多 VPS 都可以选择，根据价格、配置、地区等可以自由选择。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Shadowsocks" scheme="https://www.playpi.org/tags/Shadowsocks/"/>
    
      <category term="Vultr" scheme="https://www.playpi.org/tags/Vultr/"/>
    
      <category term="Avast" scheme="https://www.playpi.org/tags/Avast/"/>
    
      <category term="VPS" scheme="https://www.playpi.org/tags/VPS/"/>
    
  </entry>
  
</feed>
