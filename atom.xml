<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虾丸派</title>
  
  <subtitle>烂笔头</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.playpi.org/"/>
  <updated>2019-05-04T17:45:06.000Z</updated>
  <id>https://www.playpi.org/</id>
  
  <author>
    <name>虾丸派</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>指南页面的自动收集</title>
    <link href="https://www.playpi.org/2019050401.html"/>
    <id>https://www.playpi.org/2019050401.html</id>
    <published>2019-05-03T17:45:06.000Z</published>
    <updated>2019-05-04T17:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --><p>最近给博客站点增加了一个独立的页面：<strong> 指南 </strong>，用来记录本站点的所有文章，包括发表时间与文章链接，并按照发表时间倒序排列，仅供快速查找以及核对使用。其中，还会有一个文章编号，就是 url 的数字部分，由日期与编号组成，例如 2019050201 表示 2019 年 05 月 02 日发表的第 1 篇文章，这个文章编号对我来说很有用，用来核对查重。但是，为了简化这个页面的整理工作以及后续的自动生成，我需要把这个流程自动化，本文记录实现思路与实现方式。</p><a id="more"></a><h1 id="实现思路"><a href="# 实现思路" class="headerlink" title="实现思路"></a>实现思路 </h1><p> 为了简化难度，我准备使用 Shell 解决这个问题。大概思路：遍历目录的文件、解析 id 与 title、搜索匹配指南 index 文件、替换或者追加。</p><p>1、遍历指定目录【_post 目录】中的所有 markdown 文件，对每个文件执行 2。</p><p>2、对单个文件，使用 <strong>grep</strong> 正则搜索： <strong>^id: [0-9]{10}</strong>，使用 <strong>awk</strong> 获取 id 值，判断 id 值是否在 index 文件中，在则跳过，否则执行 3。</p><p>3、再使用 <strong>grep</strong> 正则搜索： <strong>^title: </strong>，使用 <strong>awk</strong> 获取 title 值，执行 4，把 id 值和 title 值追加到 index 文件中。</p><p>4、先使用 <strong>grep id 值 index 文件 </strong>搜索 3 中的 id 是否已经在 index 文件中，不在才能追加进去。追加 index 文件时，先重命名 index 文件为 index_bak，逐行读取。对每一行数据使用 <strong>grep</strong> 正则搜索：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $line | grep -E &apos;^- [0-9]&#123;10&#125;，\[&apos; | awk -F&apos;，&apos; &apos;&#123;print $1;&#125;&apos; | awk -F&apos; &apos; &apos;&#123;print $2;&#125;&apos;</span><br></pre></td></tr></table></figure><p>如果搜索无内容的直接将当前行写入新文件，命名为 index。再结合使用 <strong>awk</strong> 获取当前行的 id 值，只要 3 中的 id 值大于此 id 值并且年份一致，则将 3 中的 id 值和 title 值写入新文件【构造特定格式的数据行】，接着再将当前行写入新文件。如果年份一致且 3 中的 id 值最小，则按照 5 写入当年的数据最后一行。</p><p>5、相同年份作一个标记，是否已经写入新文件作一个标记，如果遇到读取的下一行已经不是当年的数据【正则搜索无结果】，则把构造的特定格式的数据行写入新文件，再把当前行写入新文件。</p><p>6、4 中的文件逐行读取完成后，把 4 中一开始重命名的文件 index_bak 删除，只保留新文件 index，此时 index 文件中已经增加了一行新内容。</p><h1 id="具体实现"><a href="# 具体实现" class="headerlink" title="具体实现"></a>具体实现 </h1><p>Shell 脚本内容参考如下，注释都已经标明处理逻辑，通俗易懂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># index 文件 </span><br><span class="line">index=./source/guide/index.md</span><br><span class="line">index_bak=./source/guide/index_bak.md</span><br><span class="line"># 文本格式 </span><br><span class="line">content_pattern=&apos;- id，[title](https://www.playpi.org/id.html)&apos;</span><br><span class="line"># 遍历文件夹内的所有文件 </span><br><span class="line">for file in ./source/_posts/*.md</span><br><span class="line">do</span><br><span class="line">  if [-f $file]; then</span><br><span class="line">    # 获取单个文件的 id【在第 3 行】 和 title【在第 2 行】</span><br><span class="line">    echo &apos;================================================================&apos;</span><br><span class="line">    # echo &apos;====read file:&apos; $file</span><br><span class="line">    var1=$(grep -nE &apos;^id: [0-9]&#123;10&#125;&apos; $file | grep -E &apos;^3:id: [0-9]&#123;10&#125;&apos; | awk -F&apos;: &apos; &apos;&#123;print $2;&#125;&apos;)</span><br><span class="line">    # echo &apos;====read id:&apos; $var1</span><br><span class="line">    var2=$(grep -n &apos;^title: &apos; $file | grep &apos;^2:title: &apos; | awk -F&apos;: &apos; &apos;&#123;print $2;&#125;&apos;)</span><br><span class="line">    # echo &apos;====read title:&apos; $var2</span><br><span class="line">    # 判断非空必须使用双引号，否则逻辑错误 </span><br><span class="line">    if [-n &quot;$var1&quot;] &amp;&amp; [-n &quot;$var2&quot;]; then</span><br><span class="line">      has=$(grep $var1 $index)</span><br><span class="line">      # 为空，表示 id 不在 index 文件中，has 变量切记使用双引号 </span><br><span class="line">      if [-z &quot;$has&quot;]; then</span><br><span class="line">        # 字符串搜索替换，待搜索字符串是变量，不是字符串本身，// 表示替换所有 </span><br><span class="line">        content=$&#123;content_pattern//id/$var1&#125;</span><br><span class="line">        content=$&#123;content/title/$var2&#125;</span><br><span class="line">        # 追加到 index 文件中 </span><br><span class="line">        echo &apos;====prepare append to index:&apos; $content</span><br><span class="line">        # 重命名 index 文件 </span><br><span class="line">        mv $index $index_bak</span><br><span class="line">        # 标记是否写入 / 是否同一年份 </span><br><span class="line">        has_write=&apos;&apos;</span><br><span class="line">        is_same_year=&apos;&apos;</span><br><span class="line">        while read line</span><br><span class="line">        do</span><br><span class="line">          match_id=$(echo $line | grep -E &apos;^- [0-9]&#123;10&#125;，\[&apos; | awk -F&apos;，&apos; &apos;&#123;print $1;&#125;&apos; | awk -F&apos; &apos; &apos;&#123;print $2;&#125;&apos;)</span><br><span class="line">          # 搜索到匹配内容并且还没写入 </span><br><span class="line">          if [-n &quot;$match_id&quot;] &amp;&amp; [-z &quot;$has_write&quot;]; then</span><br><span class="line">            # echo &apos;====compare,match_id:&apos; $match_id</span><br><span class="line">            # 判断是否相同年份 </span><br><span class="line">            if [$&#123;var1:0:4&#125; == $&#123;match_id:0:4&#125;]; then</span><br><span class="line">              is_same_year=&apos;1&apos;</span><br><span class="line">              # 比较大小 </span><br><span class="line">              if [$var1 -gt $match_id]; then</span><br><span class="line">                echo &apos;====gt match_id append to index:&apos; $content</span><br><span class="line">                echo $content &gt;&gt; $index</span><br><span class="line">                echo $line &gt;&gt; $index</span><br><span class="line">                has_write=&apos;1&apos;</span><br><span class="line">              else</span><br><span class="line">                echo $line &gt;&gt; $index</span><br><span class="line">              fi</span><br><span class="line">            else</span><br><span class="line">              echo $line &gt;&gt; $index</span><br><span class="line">            fi</span><br><span class="line">          elif [-n &quot;$is_same_year&quot;] &amp;&amp; [-z &quot;$has_write&quot;]; then</span><br><span class="line">            # 当前行没有搜索到匹配内容，并且同一年份，并且还没写入，说明已经是当前年份的最后一行了，直接写入即可 </span><br><span class="line">            echo &apos;====last append to index:&apos; $content</span><br><span class="line">            echo $content &gt;&gt; $index</span><br><span class="line">            echo $line &gt;&gt; $index</span><br><span class="line">            has_write=&apos;1&apos;</span><br><span class="line">          else</span><br><span class="line">            # 没有搜索到匹配内容，或者不同年份，或者已经写入，直接写入即可 </span><br><span class="line">            echo $line &gt;&gt; $index</span><br><span class="line">          fi</span><br><span class="line">        done &lt; $index_bak</span><br><span class="line">        # 删除 index_bak 文件，此时只有最新的 index 文件 </span><br><span class="line">        rm $index_bak</span><br><span class="line">      else</span><br><span class="line">      # 在 index 文件中已经存在，无需处理 </span><br><span class="line">      echo &apos;====index has:&apos; $var1</span><br><span class="line">      fi</span><br><span class="line">    else</span><br><span class="line">    echo &apos;!!!!invalid var:&apos; $var1 $var2</span><br><span class="line">    fi</span><br><span class="line">  else</span><br><span class="line">  echo &apos;!!!!invalid file:&apos; $file</span><br><span class="line">  fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p> 执行脚本时会打印解析出来的每条 id 与 title，以及写入的原因【比较后写入、最后一条写入】，第一次执行脚本耗时久一点，后续执行会自动跳过已经收集过的，耗时可以忽略。</p><p>由于实现思路简化了，所以要求 index 文件在每一年都至少已经有一个完整的记录，否则没法对比写入。</p><p>注意，正则搜索时在必要情况下使用 <strong>-E</strong> 选项开启扩展模式，否则正则无效，仍旧是普通的字符串。</p><p>日期格式的字符串比较大小，由于格式规范，都是十位数字，可以直接转为数字比较，大的就代表日期最新。</p><p>当然，日期格式的字符串比较大小，也可以先转为时间戳数字，再进行比较，示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date +% s -d &apos;2019010101&apos;</span><br></pre></td></tr></table></figure><p>虽然这种格式得到的结果不是真正的时间戳，但是只要是数字就可以比较了。另外，经过查找帮助手册，没有发现可以指定格式的参数选项，也就是无法把 <strong>YYMMddHH</strong> 格式的日期字符串转为对应的真实时间戳。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近给博客站点增加了一个独立的页面：&lt;strong&gt; 指南 &lt;/strong&gt;，用来记录本站点的所有文章，包括发表时间与文章链接，并按照发表时间倒序排列，仅供快速查找以及核对使用。其中，还会有一个文章编号，就是 url 的数字部分，由日期与编号组成，例如 2019050201 表示 2019 年 05 月 02 日发表的第 1 篇文章，这个文章编号对我来说很有用，用来核对查重。但是，为了简化这个页面的整理工作以及后续的自动生成，我需要把这个流程自动化，本文记录实现思路与实现方式。&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://www.playpi.org/categories/building/"/>
    
    
      <category term="guide" scheme="https://www.playpi.org/tags/guide/"/>
    
      <category term="Shell" scheme="https://www.playpi.org/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>使用 Java 代码迁移微博图床到 GitHub 图床</title>
    <link href="https://www.playpi.org/2019050201.html"/>
    <id>https://www.playpi.org/2019050201.html</id>
    <published>2019-05-01T18:12:24.000Z</published>
    <updated>2019-05-02T18:12:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --><p>由于微博图床开启了防盗链，导致我的博客里面的图片全部不可见，因此要切换图床。当然，一开始我使用的是极其简单的方法，直接设置博客页面的 <strong>referer</strong> 属性即可【设置为 noreferrer】，这样微博图床就检测不到引用来源，也就不会拒绝访问了。但是后续又遇到了其它问题，这些内容我在前几天的博客里面都记录了：<a href="https://www.playpi.org/2019042701.html">解决微博图床防盗链的问题 </a> 。后来我实在找不到更为恰当的解决方案，于是决定直接迁移图床。本来一开始准备使用 PicGo 这个工具，但是发现有问题，在我比较着急的情况下，决定自己写一写代码，完成迁移操作。本文就记录这些代码的逻辑。</p><a id="more"></a><h1 id="依赖构件"><a href="# 依赖构件" class="headerlink" title="依赖构件"></a> 依赖构件 </h1><p> 为了减少代码量，精简代码，需要引入几个第三方 jar 包，当然不引入也行，如果不引入有一些繁琐而又简单的业务逻辑需要自己实现，有点浪费时间了。</p><p>主要要依赖几个 jar 包：处理文件的 io 包、处理网络请求的 httpclient 包、处理 git 的 jgit 包，pom.xml 配置文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.5.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.8.0.201706111038-r&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="代码结构"><a href="# 代码结构" class="headerlink" title="代码结构"></a>代码结构 </h1><p> 写代码也比较简单，主要有四个步骤：读取 markdown 文件内容并利用正则抽取微博图床的图片链接、下载所有图片并上传至 GitHub、替换内容中抽取出的所有图片链接为 GitHub 的图片链接、内容写回新文件。</p><p>使用 Java 处理不需要多少代码，大概有不到 200 行代码，真正的业务逻辑代码更少，当然，关于网络请求的部分还是不够精简，目前我觉得能用就行。代码放在 GitHub 上面，仅供参考：<a href="https://github.com/iplaypi/startcore.git" target="_blank" rel="noopener">https://github.com/iplaypi/startcore.git</a> ，搜索 <strong>MigratePic</strong> 类即可。</p><p>代码主体调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main (String [] args) &#123;</span><br><span class="line">    //        String dir = &quot;e:\baktest&quot;;</span><br><span class="line">    //        String outDir = &quot;e:\baktest-out&quot;;</span><br><span class="line">    String dir = &quot;e:\bak&quot;;</span><br><span class="line">    String outDir = &quot;e:\bak-out&quot;;</span><br><span class="line">    Set&lt;File&gt; fileSet = getAllFiles (dir);</span><br><span class="line">    LOGGER.info (&quot;==== 文件个数:&quot; + fileSet.size ());</span><br><span class="line">    for (File file : fileSet) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 1 - 读取文件，抽取微博图床的链接与图片名称 </span><br><span class="line">            String content = FileUtils.readFileToString (file, &quot;utf-8&quot;);</span><br><span class="line">            Map&lt;String, String&gt; imgMap = extractImg (content);</span><br><span class="line">            // 2 - 下载图片并上传至 GitHub</span><br><span class="line">            Map&lt;String, String&gt; urlMap = uploadGithub (imgMap);</span><br><span class="line">            // 3 - 替换所有链接 </span><br><span class="line">            content = replaceUrl (content, urlMap);</span><br><span class="line">            // 4 - 内容写回新文件 </span><br><span class="line">            String outFile = outDir + File.separator + file.getName ();</span><br><span class="line">            FileUtils.writeStringToFile (new File (outFile), content, &quot;utf-8&quot;);</span><br><span class="line">            LOGGER.info (&quot;==== 处理文件完成:&#123;&#125;, 获取新浪图床链接个数:&#123;&#125;, 上传 GitHub 个数:&#123;&#125;&quot;, file.getAbsolutePath (), imgMap.size (), urlMap.size ());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要指定输入、输出目录。</p><p>截图如下：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190504004133.png" alt="代码主体调用" title="代码主体调用"></p><p>其中，<strong>getAllFiles</strong> 方法是获取指定目录的所有文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 获取指定文件夹内的所有文件 </span><br><span class="line">     *</span><br><span class="line">     * @param dir</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">private static Set&lt;File&gt; getAllFiles (String dir) &#123;</span><br><span class="line">    Set&lt;File&gt; fileSet = new HashSet&lt;&gt;();</span><br><span class="line">    File file = new File (dir + File.separator);</span><br><span class="line">    for (File textFile : file.listFiles ()) &#123;</span><br><span class="line">        fileSet.add (textFile.getAbsoluteFile ());</span><br><span class="line">    &#125;</span><br><span class="line">    return fileSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码的细节中，可以看到我是每个文件单独处理的，比较耗时间的就是下载图片、上传到 GitHub 这两个过程，而且由于我是文件分开处理，所以总的时间更长了。如果想节约点时间，可以一次性把所有的图片全部下载完成，最后一次提交到 GitHub 即可，这样就节约了多次频繁地与 GitHub 建立连接、断开连接所消耗的时间，如果是几次提交无所谓，但是几十次提交就多消耗很多时间了。例如按照我这个量，78 个文件，500-600 张图片，运行程序消耗了十几分钟，但是我估计如果一次性处理完成，时间应该在 5 分钟以内。</p><p>接下来分别描述四个步骤。</p><h2 id="读取文件抽取图片链接"><a href="# 读取文件抽取图片链接" class="headerlink" title="读取文件抽取图片链接"></a>读取文件抽取图片链接 </h2><p>markdown 文件其实也就是普通的文本文件，没有特殊的格式，这就给程序处理带来了极大方便，直接使用工具包读取就行。此外，抽取微博图床的图片链接需要使用正则表达式，代码内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static Pattern PATTERN = Pattern.compile (&quot;https://[0-9a-zA-Z]&#123;3&#125;\.sinaimg\.cn/large/[0-9a-zA-Z]&#123;8,50&#125;\.jpg&quot;);</span><br><span class="line">/**</span><br><span class="line">     * 抽取微博图床的图片链接与图片文件名 </span><br><span class="line">     *</span><br><span class="line">     * @param string</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">private static Map&lt;String, String&gt; extractImg (String string) &#123;</span><br><span class="line">    Map&lt;String, String&gt; imgMap = new HashMap&lt;&gt;();</span><br><span class="line">    Matcher matcher = PATTERN.matcher (string);</span><br><span class="line">    while (matcher.find ()) &#123;</span><br><span class="line">        String oldUrl = matcher.group ();</span><br><span class="line">        int index = oldUrl.lastIndexOf (&quot;/&quot;);</span><br><span class="line">        if (0 &lt; index) &#123;</span><br><span class="line">            String imgName = oldUrl.substring (index + 1);</span><br><span class="line">            imgMap.put (oldUrl, imgName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return imgMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里列举一个图片链接的例子：<br><a href="https://ws1.sinaimg.cn/large/b7f2e3a3gy1g2hlkwnfm9j214a0hr75v.jpg" target="_blank" rel="noopener">https://ws1.sinaimg.cn/large/b7f2e3a3gy1g2hlkwnfm9j214a0hr75v.jpg</a> 。</p><h2 id="下载图片并上传新图床"><a href="# 下载图片并上传新图床" class="headerlink" title="下载图片并上传新图床"></a>下载图片并上传新图床 </h2><p> 这是一个很重要的步骤，需要把上一个步骤完成后获取到的图片下载下来，并且提交到 GitHub 上面去【提交可以不使用代码，直接手动提交也行】，然后获取新图片链接。</p><p>为了完成这个步骤，需要先在 GitHub 上面新建一个项目，专门用来存放图片，然后把这个项目 clone 到本地，用来存放下载的图片，最后直接提交即可。</p><p>下载图片并提交到 GitHub：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static String githubUrl = &quot;https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/&quot;;</span><br><span class="line">/**</span><br><span class="line">     * 提交本地的图片到 GitHub, 并拼接新的图片链接 </span><br><span class="line">     *</span><br><span class="line">     * @param imgMap</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">private static Map&lt;String, String&gt; uploadGithub (Map&lt;String, String&gt; imgMap) &#123;</span><br><span class="line">    String imgDir = &quot;E:\img\img-playpi\img\old\&quot;;</span><br><span class="line">        Map&lt;String, String&gt; urlMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : imgMap.entrySet ()) &#123;</span><br><span class="line">            String oldUrl = entry.getKey ();</span><br><span class="line">            String imgName = entry.getValue ();</span><br><span class="line">            boolean isSuc = downloadImg (oldUrl, imgDir, imgName);</span><br><span class="line">            if (isSuc) &#123;</span><br><span class="line">                String newUrl = githubUrl + imgName;</span><br><span class="line">                urlMap.put (oldUrl, newUrl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info (&quot;==== 开始上传文件到 GitHub, size: &#123;&#125;&quot;, urlMap.size ());</span><br><span class="line">        // 统一上传到 GitHub, 这一步骤可以省略，留到最后手动提交即可 </span><br><span class="line">        boolean gitSuc = JGitUtil.commitAndPush (&quot;add and commit by Java client,img size: &quot; + urlMap.size ());</span><br><span class="line">        if (!gitSuc) &#123;</span><br><span class="line">            urlMap.clear ();</span><br><span class="line">        &#125;</span><br><span class="line">        return urlMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意下载图片需要指定本地项目的路径，方便提交到 GitHub，例如我这里是 <strong>E:\img\img-playpi\img\old\</strong>，拼接 GitHub 的图片链接时需要指定固定的域名部分、用户名、分支名、子目录，例如我这里是：<br><strong><a href="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/" target="_blank" rel="noopener">https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/</a> </strong>。</p><p>这里列举一个 GitHub 图片链接的例子：<br><a href="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/20190502183444.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/20190502183444.png</a> 。</p><p>下载图片的详细逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 下载图片到指定的文件目录 </span><br><span class="line">     */</span><br><span class="line">public static Boolean downloadImg (String url, String dir, String fileName) &#123;</span><br><span class="line">    Boolean isSuc = false;</span><br><span class="line">    HttpClient httpclient = null;</span><br><span class="line">    int retry = 5;</span><br><span class="line">    while (0 &lt; retry--) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            httpclient = new DefaultHttpClient ();</span><br><span class="line">            HttpGet httpget = new HttpGet (url);</span><br><span class="line">            httpget.setHeader (&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.79 Safari/537.1&quot;);</span><br><span class="line">            httpget.setHeader (&quot;Accept&quot;, &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;);</span><br><span class="line">            HttpResponse resp = httpclient.execute (httpget);</span><br><span class="line">            if (HttpStatus.SC_OK == resp.getStatusLine ().getStatusCode ()) &#123;</span><br><span class="line">                HttpEntity entity = resp.getEntity ();</span><br><span class="line">                InputStream in = entity.getContent ();</span><br><span class="line">                isSuc = savePicToDisk (in, dir, fileName);</span><br><span class="line">                return isSuc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">            LOGGER.error (&quot;!!!! 下载失败，重试一次 & quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            httpclient.getConnectionManager ().shutdown ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isSuc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 根据输入流，保存内容到指定的目录文件 </span><br><span class="line">     *</span><br><span class="line">     * @param in</span><br><span class="line">     * @param dirPath</span><br><span class="line">     * @param filePath</span><br><span class="line">     */</span><br><span class="line">private static Boolean savePicToDisk (InputStream in, String dirPath, String filePath) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        File dir = new File (dirPath);</span><br><span class="line">        if (dir == null || !dir.exists ()) &#123;</span><br><span class="line">            dir.mkdirs ();</span><br><span class="line">        &#125;</span><br><span class="line">        // 拼接文件完整路径 </span><br><span class="line">        String realPath = dirPath.concat (filePath);</span><br><span class="line">        File file = new File (realPath);</span><br><span class="line">        if (file == null || !file.exists ()) &#123;</span><br><span class="line">            file.createNewFile ();</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream fos = new FileOutputStream (file);</span><br><span class="line">        byte [] buf = new byte [1024];</span><br><span class="line">        int len = 0;</span><br><span class="line">        while ((len = in.read (buf)) != -1) &#123;</span><br><span class="line">            fos.write (buf, 0, len);</span><br><span class="line">        &#125;</span><br><span class="line">        fos.flush ();</span><br><span class="line">        fos.close ();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace ();</span><br><span class="line">        LOGGER.error (&quot;!!!! 写入文件失败 & quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            in.close ();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交图片到 GitHub 的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 提交并推送代码至远程服务器 </span><br><span class="line"> *</span><br><span class="line"> * @param desc 提交描述 </span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static boolean commitAndPush (String desc) &#123;</span><br><span class="line">    boolean commitAndPushFlag = false;</span><br><span class="line">    try (Git git = Git.open (new File (LOCAL_REPOGIT_CONFIG))) &#123;</span><br><span class="line">        UsernamePasswordCredentialsProvider provider = new UsernamePasswordCredentialsProvider (GIT_USERNAME, GIT_PASSWORD);</span><br><span class="line">        git.add ().addFilepattern (&quot;.&quot;).call ();</span><br><span class="line">        // 提交 </span><br><span class="line">        git.commit ().setMessage (desc).call ();</span><br><span class="line">        // 推送到远程，不报错默认为成功 </span><br><span class="line">        git.push ().setCredentialsProvider (provider).call ();</span><br><span class="line">        commitAndPushFlag = true;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace ();</span><br><span class="line">        LOGGER.error (&quot;Commit And Push error!&quot; + e.getMessage ());</span><br><span class="line">    &#125;</span><br><span class="line">    return commitAndPushFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里需要指定本地项目的配置文件路径，例如我的是 <strong>E:\img\img-playpi\.git</strong>，与前面的下载路径是在同一个父目录，另外还需要指定用户名密码。</p><h2 id="使用新链接替换旧链接"><a href="# 使用新链接替换旧链接" class="headerlink" title="使用新链接替换旧链接"></a>使用新链接替换旧链接 </h2><p> 如果前面的步骤完成，就说明图片已经被成功迁移到 GitHub 上面，并且获取到了新的图片链接，接着直接替换掉旧链接即可。</p><p>代码逻辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 替换所有的图片链接 </span><br><span class="line"> *</span><br><span class="line"> * @param string</span><br><span class="line"> * @param urlMap</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static String replaceUrl (String string, Map&lt;String, String&gt; urlMap) &#123;</span><br><span class="line">    for (Map.Entry&lt;String, String&gt; entry : urlMap.entrySet ()) &#123;</span><br><span class="line">        String oldUrl = entry.getKey ();</span><br><span class="line">        String newUrl = entry.getValue ();</span><br><span class="line">        string = string.replaceAll (oldUrl, newUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换后内容写回新文件"><a href="# 替换后内容写回新文件" class="headerlink" title="替换后内容写回新文件"></a>替换后内容写回新文件 </h2><p> 写入新文件是很简单的，直接调用 io 包即可完成，但是为了安全起见，文件放在新的目录中，不要直接替换掉原来的文件，否则程序出现意外就麻烦了。</p><h1 id="迁移结果"><a href="# 迁移结果" class="headerlink" title="迁移结果"></a>迁移结果 </h1><p> 随意打开一篇博客，使用文件对比工具查看替换前后的区别，可以看到除了图片链接被替换掉，其它内容没有任何变化。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190504004204.png" alt="替换文件对比" title="替换文件对比"></p><p>在本地仓库查看，图片已经全部下载。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190504004224.png" alt="在本地仓库查看" title="在本地仓库查看"></p><p>在 GitHub 的仓库中查看，图片全部推送。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190504004216.png" alt="在 GitHub 的仓库中查看" title="在 GitHub 的仓库中查看"></p><p>任意打开一篇博客，里面的图片已经可以全部正常显示，只不过有一些太大的图片【超过 1MB 的】加载速度有点慢，还可以接受。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;由于微博图床开启了防盗链，导致我的博客里面的图片全部不可见，因此要切换图床。当然，一开始我使用的是极其简单的方法，直接设置博客页面的 &lt;strong&gt;referer&lt;/strong&gt; 属性即可【设置为 noreferrer】，这样微博图床就检测不到引用来源，也就不会拒绝访问了。但是后续又遇到了其它问题，这些内容我在前几天的博客里面都记录了：&lt;a href=&quot;https://www.playpi.org/2019042701.html&quot;&gt;解决微博图床防盗链的问题&lt;/a&gt; 。后来我实在找不到更为恰当的解决方案，于是决定直接迁移图床。本来一开始准备使用 PicGo 这个工具，但是发现有问题，在我比较着急的情况下，决定自己写一写代码，完成迁移操作。本文就记录这些代码的逻辑。&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://www.playpi.org/categories/building/"/>
    
    
      <category term="GitHub" scheme="https://www.playpi.org/tags/GitHub/"/>
    
      <category term="weibo" scheme="https://www.playpi.org/tags/weibo/"/>
    
      <category term="image" scheme="https://www.playpi.org/tags/image/"/>
    
  </entry>
  
  <entry>
    <title>解决微博图床防盗链的问题</title>
    <link href="https://www.playpi.org/2019042701.html"/>
    <id>https://www.playpi.org/2019042701.html</id>
    <published>2019-04-27T08:57:20.000Z</published>
    <updated>2019-04-27T08:57:20.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --><p>对于不少自己搭建博客的人来说，图床的选择可真是一个大难点，以前还有各种免费好用的图床工具，例如七牛云、又拍云、SM.MS、Imgur、GitHub、微博图床等，当然还有腾讯云、阿里云的云存储服务，但是免费的意味着不稳定，说不定哪天图片就没有了，有一些国外的访问速度又不行，国内的云存储服务商收费又比较高，还有的必须绑定认证的域名才能使用。本来搭建一个小小的博客，只为了记录知识，传播技术，遇到耗财或者耗精力的这种问题，都比较头疼。</p><p>后来纠结了好几天，最终决定使用免费的 <strong>微博图床 </strong>，一是因为新浪微博这家厂商体量大，微博图床短期内应该不会出问题，二是看到好多网友说他们已经稳定使用微博图床 3-5 年了，没有出过问题。我大概使用的时间还没有一年，以前都是本地化的，没有整理成完整的文章，后来开始慢慢整理并部署上线。没想到最近【2019 年 4 月 24 日左右发现】微博图床出问题了，访问图片链接全部是返回 403 状态码，表示拒绝访问，其实是微博图床开启了防盗链，本文就记录这个现象以及可行的解决方案。</p><a id="more"></a><h1 id="微博图床防盗链开启"><a href="# 微博图床防盗链开启" class="headerlink" title="微博图床防盗链开启"></a>微博图床防盗链开启 </h1><h2 id="初始现象"><a href="# 初始现象" class="headerlink" title="初始现象"></a> 初始现象 </h2><p> 在 2019 年 4 月 24 日的时候，我发现一个严重的问题，我的博客里面的图片显示不出来了，并不是被封了，如果被封也会显示图片的，只不过是马赛克图片。发现这个问题的缘由是新写了一篇博客，本地生成测试的时候，发现图片全部不显示了，一开始还以为是网络问题。</p><p>博客里面的图片全部无法正常显示 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hfpnoi01j20lc0i00tr.jpg" alt="图片全部无法正常显示" title="图片全部无法正常显示"></p><p> 接着我随机抽了一些图片链接在浏览器中直接打开看，发现是可以看到图片的，然后在博客中还是看不到图片，如果在博客中选择图片链接，使用右键 <strong>在新标签页中打开 </strong>，也是不能看到。这就说明微博图床开始检测请求的合法性了，对于不正常的请求统统拒绝。</p><p>当然，如果直接使用图片的链接在浏览器中单独打开，是可以看到图片的，紧接着在博客中就可以看到对应的图片了，但是这并不是说明图片可以使用了，其实是浏览器的缓存作用，如果及时清除浏览器的缓存，发现又不能使用了。</p><p>复制图片地址在浏览器中打开，图片可以正常显示 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hfpvew8yj212p0k2q3i.jpg" alt="在浏览器中打开图片可以正常显示" title="在浏览器中打开图片可以正常显示"></p><h2 id="分析现象"><a href="# 分析现象" class="headerlink" title="分析现象"></a> 分析现象 </h2><p> 接着使用浏览器的调试工具查看详细的请求信息，按 <strong>F12</strong> 按键，调出调试工具，刷新网页，使用 <strong>jpg</strong> 过滤无效内容，可以看到所有的图片访问请求结果都是 403，也就是拒绝访问。</p><p>随便点开一个链接的请求信息，查看 Status Code 为 403，也就是拒绝访问，注意查看请求头的 <strong>Referer</strong> 参数，值是一个链接，表示当前请求所属的页面，即 <strong>引用来源 </strong>，而新浪微博恰好会检测这个参数，拒绝所有的外链请求，即不是从新浪的站点发送的图片请求。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hfqpbdc6j20rd0g1abk.jpg" alt="403 拒绝访问" title="403 拒绝访问"></p><p>原来，近期微博图床对图片 CDN 添加了引用来源【Referer】检测，非微博站内引用将会返回 403 错误码，即拒绝访问。那能不能伪造或者清除这个参数呢，其实是可以的，只不过伪造、清除都需要增加一些 Javascript 动态脚本来处理，需要一些技术支持。</p><p>如果选择清除 Referer 参数，可以先验证一下，把图片的链接直接复制到浏览器中访问，就不会有这个参数，发现可以正常访问，没有 403 错误。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hfroxnhfj20oa0ijq3w.jpg" alt="单独在浏览器中访问" title="单独在浏览器中访问"></p><p>注意，一开始我发现使用浏览器能直接访问，紧着着博客里面的图片也能访问了，我还以为是需要单独访问一次图片，然后就可以任意访问了，后来发现其实是浏览器缓存的作用，空欢喜一场。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hfsl0troj20ph0dujsl.jpg" alt="缓存欺骗了我" title="缓存欺骗了我"></p><p>也看到有说法是，微博图床仅仅针对开启 SSL 的链接【即 HTTPS】实行站外禁止访问，而普通的 HTTP 链接仍旧安然无恙，这种说法是错误的【但是确实有这种现象出现】。我测试了一下，的确是有这样的现象，前提是来源页面开启了 SSL，而图床链接使用基本的 HTTP，这样的话由于 <strong>Referer</strong> 的特性，请求图片链接时不会传输 <strong>Referer</strong> 这个参数的值【即来源页面的信息不会传递给请求页面】，微博图床自然也就无法检测了。所以最简单的方案就是把所有微博图床的链接全部由 HTTPS 替换为 HTTP，但是由于我的博客全面开启了 SSL，为了加绿锁，因此不引用普通的 HTTP 链接，这种简单的方案我就无法采用了，只能遗憾舍弃。</p><h1 id="解决方案"><a href="# 解决方案" class="headerlink" title="解决方案"></a>解决方案 </h1><p> 考虑切换图床，免费的已经基本没有了，收费的比较贵，或者找到方案先临时使用，不然会给查看博客的人带来很大困扰，毕竟没有图片的博客怎么能看，这也影响博客的质量与声誉。</p><h2 id="尝试清除来源引用"><a href="# 尝试清除来源引用" class="headerlink" title="尝试清除来源引用"></a>尝试清除来源引用 </h2><p> 在静态网页的 <strong>头部 </strong>代码中【即 head 标记】添加如下配置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</span><br></pre></td></tr></table></figure><p>它的作用就是阻止浏览器发送 <strong>Referer</strong> 信息，对整个页面的所有链接生效【当然也有针对单个链接设置的方法：&lt;a rel=”noreferrer” href=”your-website-url” /&gt;，这里不采用】，这样一来微博图床就不知道请求的引用来源了，可以达到和直接在浏览器中访问一样的效果。<strong> 但是要注意，不是每种浏览器都支持这种语法的，此设置对有的浏览器来说无效。</strong></p><p>那么在 Hexo 框架中怎么增加呢，显然不会有相关配置项，只能更改源代码，而且使用了 Next 主题，应该要更改主题的源代码，以保证 Hexo 在渲染静态页面为每个页面都增加这个配置。查阅文档，了解了渲染模板所在位置，打开 <strong>themes/next/layout/_partials/head.swig</strong> 文件，在里面添加 meta 标记就行。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hit3tj2sj20nn07eq3f.jpg" alt="修改 head.swig 文件" title="修改 head.swig 文件"></p><p>修改完成后查看页面的源代码，已经有这个属性了，并且所有的图片都可以正常访问了，完美。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hiusk7jqj20tu091gmn.jpg" alt="查看页面的源代码" title="查看页面的源代码"></p><p>但是我觉得这肯定不是长久之计，以后说不定还会有幺蛾子出现，所以要随时准备着。</p><h2 id="尝试其他方案"><a href="# 尝试其他方案" class="headerlink" title="尝试其他方案"></a>尝试其他方案 </h2><p> 先观察一段时间，这段时间要考虑其他方案的可行性和成本。</p><h2 id="建议"><a href="# 建议" class="headerlink" title="建议"></a>建议 </h2><p> 微博图床开启防盗链，个人博客对于新浪图床的依赖时代基本要告别了，虽然有其他免费图床可以使用，但稳定性和可持续性上显然无法与大企业维护的图床相比。为了博客内容稳定考虑，还是考虑后续逐渐把图片迁移到其他云存储空间，费用方面能承受就行。</p><h1 id="其他知识点"><a href="# 其他知识点" class="headerlink" title="其他知识点"></a>其他知识点 </h1><h2 id="微博图床简单介绍"><a href="# 微博图床简单介绍" class="headerlink" title="微博图床简单介绍"></a> 微博图床简单介绍 </h2><p> 对于大多数个人博客维护者而言，免费的图床既节省成本，也能够提升页面访问的速度，而新浪微博图床则成了首选。</p><p>新浪微博由于本身体量大，其图床免费无限容量，只需要有一个微博账号就可使用。同时具备全网 CDN 加速，支持 HTTPS，无论是国内还是国外网络访问，速度都很不错。而且新浪如此企业，不会像其他个人或者团队经营的免费图床一样随时可能会关掉。</p><p>基于这些优势，不少人会优先选择新浪微博图床作为网站提供图片服务。毕竟直接挂 CDN 或者自建图床的话，也是一个持久的付费维护，如果一旦被攻击，更是造成费用暴增。</p><h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><p><strong>Referer</strong> 首部包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 <strong>Referer</strong> 首部识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。同时也让服务器能够发现过时的和错误的链接并及时维护。</p><p>需要注意的是 <strong>referer</strong> 实际上是 <strong>referrer</strong> 的误拼写，它可能是 HTTP 协议中第一个被拼写错误的标准头，为保持向下兼容就将错就错了。可以参见 RFC 文档的 Referer 的介绍：<br><a href="https://tools.ietf.org/html/rfc2616#section-14.36" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616#section-14.36</a> ，原文有这样的描述：</p><blockquote><p>the “referrer”, although the header field is misspelled.</p></blockquote><p>此外还可以参考维基百科的相关介绍：<br><a href="https://zh.wikipedia.org/wiki/HTTP% E5%8F%83% E7%85% A7% E4% BD%8D% E5%9D%80" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/HTTP% E5%8F%83% E7%85% A7% E4% BD%8D% E5%9D%80</a> 。</p><p>在以下几种情况下，<strong>Referer</strong> 不会被发送 </p><ul><li> 来源页面采用的协议为表示本地文件的 file 或者 data URI</li><li>当前请求页面采用的是非安全协议，而来源页面采用的是安全协议【HTTPS】</li><li>为整个页面设置 &lt;meta name=”referrer” content=”no-referrer” /&gt;</li><li>为单个链接设置 &lt;a rel=”noreferrer” href=”your-website-url” /&gt;</li></ul><p>注意第二种情况，如果你的博客开启了 SSL，可以使用 HTTP 的图片链接，就可以正常访问了。但是要牺牲你的博客的安全性，因为浏览器会检测到你的博客内容里面有普通的 HTTP 链接，就会导致不可信【尽管存在有效的证书，也没有用】，小绿锁会消失，并给出警告。</p><p>例如我的博客，为了测试，使用了一个 HTTP 图片链接，其它的图片都是 HTTPS 链接，可以发现 HTTP 的图片可以正常访问，其它的图片仍旧被拒绝访问了。此时，发现博客的小绿锁已经没有了，并且给出了警告提示。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hlkwnfm9j214a0hr75v.jpg" alt="不安全的方案" title="不安全的方案"></p><h1 id="后记"><a href="# 后记" class="headerlink" title="后记"></a>后记 </h1><p> 使用上述的解决方案后，我又发现了一个严重的问题，由于清除了引用来源 referer，博客文章的地址就不会发送出去，导致我的 <strong>不蒜子 </strong>统计失效，也就是每篇文章的阅读数、整个站点的访问量【pv】、整个站点的访客数【uv】都会停止统计。这会导致整个博客的动态流量不可见，对于写博客的我来说内心会有一点点失落，所以我要想办法解决这个问题。</p><p>已经知道问题的根源了，解决起来也是很容易的，直接开启引用来源 referer 即可，但是由于和微博图床的图片防盗链冲突，不能同时开启。也就是说除了微博图床的防盗链要关闭 referer，其它的链接仍旧正常开启，看看能不能想办法只把微博图床的链接关闭 referer。</p><p>标记 a 可以增加 ref=”noreferrer” 属性，但是在 Hexo 中我无法找到合适的方式来完成这个操作。本来准备在 <strong>_macro/post.swig</strong> 中对渲染后的标记属性进行替换，示例 swig 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; post.content|replace (&apos;group&apos;, &apos;noreferrer&apos;, &apos;g&apos;) &#125;&#125;</span><br></pre></td></tr></table></figure><p>把 <strong>ref=”group”</strong> 替换为 <strong>ref=”noreferrer”</strong>，但是测试后发现行不通，传递过来的 <strong>content</strong> 只包含 p 标记，并没有 a 标记，也就是说明 a 标记是在其它地方渲染的。</p><p>而如果直接在渲染标记 a 的地方进行选择性替换，发现微博图床的图片链接，就把 ref 属性替换掉，需要去更改 Hexo 的源代码，其中有一个 <strong>markdown (str)</strong> 方法，显然这种临时方案不合理，也很麻烦。</p><p>为了稳定地解决这个问题，我还是决定更换图床，然后使用第三方工具进行图片迁移。</p><h2 id="更换图床"><a href="# 更换图床" class="headerlink" title="更换图床"></a>更换图床 </h2><p> 和以前一样，挑选了一圈，也是很纠结，最终还是下定决心直接使用 GitHub 了，稳定又方便。其实就是新建一个仓库，专门用来存放图片，只不过需要考虑一下图片过多、图片过大会不会被 GitHub 限制。</p><p>去 GitHub 搜索帮助文档，<a href="https://help.github.com/en/articles/what-is-my-disk-quota" target="_blank" rel="noopener">帮助文档信息 </a> ，可以得知仓库最大为 100GB，但是官方建议保持在 1GB 以下，单个文件低于 100MB，因此用来存放文件绰绰有余。另外需要注意，仓库文件超过 1GB 时会收到 GitHub 的提醒邮件，超过 75GB 时，每次在提交时都会收到警告。</p><p> 原文描述如下：</p><blockquote><p>We recommend repositories be kept under 1GB each. Repositories have a hard limit of 100GB. If you reach 75GB you’ll receive a warning from Git in your terminal when you push. This limit is easy to stay within if large files are kept out of the repository. If your repository exceeds 1GB, you might receive a polite email from GitHub Support requesting that you reduce the size of the repository to bring it back down.</p></blockquote><blockquote><p>In addition, we place a strict limit of files exceeding 100 MB in size.</p></blockquote><p>既然有这种限制，最好还是把图片压缩一下，推荐使用图片压缩工具：<a href="https://github.com/meowtec/Imagine" target="_blank" rel="noopener">Imagine</a> ，这个工具可以实时看到压缩效果，而且压缩率还不错，能到 50%。但是，如果想要保持图片的色彩度、还原度，压缩效果肯定是不行的，甚至有时候压缩后的图片比压缩前的还大。</p><p>压缩图片示例 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/20190502183444.png" alt="压缩图片示例" title="压缩图片示例"></p><h2 id="迁移图片"><a href="# 迁移图片" class="headerlink" title="迁移图片"></a> 迁移图片 </h2><p> 迁移图片本来是个很麻烦的事情，要把图片迁移、博客文章里面的链接替换掉，但是还好有现成的工具可以使用，在这里推荐：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a> ，这个工具本来不是做图片迁移的，仅仅是图片上传生成链接而已，但是有人开发了插件，专门用来迁移 markdown 文件里面的图片，会自动迁移图片并且更新 markdown 里面的图片链接。这个插件是：<a href="https://github.com/PicGo/picgo-plugin-pic-migrater" target="_blank" rel="noopener">picgo-plugin-pic-migrater</a> ，而且，还可以支持批量迁移，指定一个文件夹，直接迁移文件夹里面的所有 markdown 文件。</p><h2 id="迁移过程"><a href="# 迁移过程" class="headerlink" title="迁移过程"></a>迁移过程 </h2><p> 详细的迁移步骤就不再记录，几个重要的步骤：在 GitHub 建立仓库、使用 PicGo 工具迁移图片，重新整理 markdown 文件。操作前切记备份好自己的 markdown 文件，以免迁移出现问题导致文件丢失。</p><p>在使用 PicGo 的过程中，发现总是迁移失败，重试了多次之后确定是因为在 markdown 语法中增加了注释，相当于给图片链接增加了 alt 属性【生成时图片会有一个 img 标记】，导致 PicGo 的插件识别不了，迁移失败。我已经在 GitHub 的项目中提了 issue：<a href="https://github.com/PicGo/picgo-plugin-pic-migrater/issues/1" target="_blank" rel="noopener">https://github.com/PicGo/picgo-plugin-pic-migrater/issues/1</a> ，作者也回复了，后续会修复。而我比较着急，等不了，又不可能把这些注释全部清除，也不好，所以我决定自己迁移，通过 Java 写代码解决。</p><p>写代码也比较简单，主要有四个步骤：读取 markdown 文件内容并利用正则抽取微博图床的图片链接、下载所有图片并上传至 GitHub、替换内容中抽取出的所有图片链接为 GitHub 的图片链接、内容写回新文件。</p><p>使用 Java 处理不需要多少代码，主要要依赖几个 jar 包：处理文件的 io 包、处理网络请求的 httpclient 包、处理 git 的 jgit 包。详细内容可以参考我的另外一篇博客：<a href="https://www.playpi.org/2019050201.html">使用 Java 代码迁移微博图床到 GitHub 图床 </a> 。</p><h2 id="小细节"><a href="# 小细节" class="headerlink" title="小细节"></a> 小细节 </h2><p> 针对 PicGo 的使用还有一些小细节可以注意一下：自定义域名、子文件夹路径、图片压缩【不压缩针对 GitHub 速度会很慢，能压缩到 200KB 最好】、文件重命名。</p><h2 id="未来考虑"><a href="# 未来考虑" class="headerlink" title="未来考虑"></a>未来考虑 </h2><p> 迁移完成之后，以后新的图片就直接使用 PicGo 上传到 GitHub 图床了，同时需要注意区分子文件夹。在 GitHub 仓库中，暂时每年新建一个文件夹，以年份数字为名称。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;对于不少自己搭建博客的人来说，图床的选择可真是一个大难点，以前还有各种免费好用的图床工具，例如七牛云、又拍云、SM.MS、Imgur、GitHub、微博图床等，当然还有腾讯云、阿里云的云存储服务，但是免费的意味着不稳定，说不定哪天图片就没有了，有一些国外的访问速度又不行，国内的云存储服务商收费又比较高，还有的必须绑定认证的域名才能使用。本来搭建一个小小的博客，只为了记录知识，传播技术，遇到耗财或者耗精力的这种问题，都比较头疼。&lt;/p&gt;&lt;p&gt;后来纠结了好几天，最终决定使用免费的 &lt;strong&gt;微博图床 &lt;/strong&gt;，一是因为新浪微博这家厂商体量大，微博图床短期内应该不会出问题，二是看到好多网友说他们已经稳定使用微博图床 3-5 年了，没有出过问题。我大概使用的时间还没有一年，以前都是本地化的，没有整理成完整的文章，后来开始慢慢整理并部署上线。没想到最近【2019 年 4 月 24 日左右发现】微博图床出问题了，访问图片链接全部是返回 403 状态码，表示拒绝访问，其实是微博图床开启了防盗链，本文就记录这个现象以及可行的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://www.playpi.org/categories/building/"/>
    
    
      <category term="https" scheme="https://www.playpi.org/tags/https/"/>
    
      <category term="weibo" scheme="https://www.playpi.org/tags/weibo/"/>
    
      <category term="referer" scheme="https://www.playpi.org/tags/referer/"/>
    
  </entry>
  
  <entry>
    <title>mapreduce 错误之 bin bash-line 0-fg-no job control</title>
    <link href="https://www.playpi.org/2019042401.html"/>
    <id>https://www.playpi.org/2019042401.html</id>
    <published>2019-04-24T14:50:17.000Z</published>
    <updated>2019-04-24T14:50:17.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --><p>今天在开发 mapreduce 程序的过程中，为了快速开发，程序的整体框架是从别的业务复制过来的，自己增加一些数据处理逻辑以及环境的参数配置。接着就遇到问题，在本地本机测试的时候，Job 作业无法启动，总是抛出异常，然后进程退出。本机系统为 Windows 7 X64。</p><p>异常错误信息简略如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exit code: 1</span><br><span class="line">Exception message: /bin/bash: line 0: fg: no job control</span><br></pre></td></tr></table></figure><p>本文记录这个现象以及解决方案。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 在本地本机启动 Job 时无法正常运行作业，直接抛出异常后退出进程，完整错误信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Diagnostics: Exception from container-launch.</span><br><span class="line">Container id: container_e18_1550055564059_0152_02_000001</span><br><span class="line">Exit code: 1</span><br><span class="line">Exception message: /bin/bash: line 0: fg: no job control</span><br><span class="line"></span><br><span class="line">Stack trace: ExitCodeException exitCode=1: /bin/bash: line 0: fg: no job control</span><br><span class="line"></span><br><span class="line">at org.apache.hadoop.util.Shell.runCommand (Shell.java:576)</span><br><span class="line">at org.apache.hadoop.util.Shell.run (Shell.java:487)</span><br><span class="line">at org.apache.hadoop.util.Shell$ShellCommandExecutor.execute (Shell.java:753)</span><br><span class="line">at org.apache.hadoop.yarn.server.nodemanager.DefaultContainerExecutor.launchContainer (DefaultContainerExecutor.java:212)</span><br><span class="line">at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call (ContainerLaunch.java:303)</span><br><span class="line">at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call (ContainerLaunch.java:82)</span><br><span class="line">at java.util.concurrent.FutureTask.run (FutureTask.java:266)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run (Thread.java:748)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Container exited with a non-zero exit code 1</span><br><span class="line">Failing this attempt. Failing the application.</span><br><span class="line">2019-04-22_22:46:04 [main] INFO mapreduce.Job:1385: Counters: 0</span><br></pre></td></tr></table></figure><p>其中的重点在于：<strong>Exception message: /bin/bash: line 0: fg: no job control</strong>，由于我不了解这种错误，只能靠搜索引擎解决了。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><p> 问题解决很容易，在 Job 的配置中增加一项：mapreduce.app-submission.cross-platform，取值为 true，截取代码片段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Configuration conf = job.getConfiguration ();</span><br><span class="line">conf.set (&quot;mapreduce.job.running.map.limit&quot;, &quot;50&quot;);</span><br><span class="line">// 本机环境测试加上配置，否则会抛出异常退出：ExitCodeException: /bin/bash: line 0: fg: no job control</span><br><span class="line">conf.set (&quot;mapreduce.app-submission.cross-platform&quot;, &quot;true&quot;);</span><br></pre></td></tr></table></figure><p>这个配置的含义就是跨平台，保障 Job 作业可以在 Windows 平台顺利运行。</p><h1 id="备注"><a href="# 备注" class="headerlink" title="备注"></a>备注 </h1><p> 参考：<a href="https://stackoverflow.com/questions/24075669/mapreduce-job-fail-when-submitted-from-windows-machine" target="_blank" rel="noopener">stackoverflow 讨论一例</a> 。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天在开发 mapreduce 程序的过程中，为了快速开发，程序的整体框架是从别的业务复制过来的，自己增加一些数据处理逻辑以及环境的参数配置。接着就遇到问题，在本地本机测试的时候，Job 作业无法启动，总是抛出异常，然后进程退出。本机系统为 Windows 7 X64。&lt;/p&gt;&lt;p&gt;异常错误信息简略如下：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Exit code: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Exception message: /bin/bash: line 0: fg: no job control&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;本文记录这个现象以及解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑系列" scheme="https://www.playpi.org/categories/series-of-fixbug/"/>
    
    
      <category term="mapreduce" scheme="https://www.playpi.org/tags/mapreduce/"/>
    
  </entry>
  
  <entry>
    <title>关于  httpcore 的 Maven 依赖冲突问题解决</title>
    <link href="https://www.playpi.org/2019042201.html"/>
    <id>https://www.playpi.org/2019042201.html</id>
    <published>2019-04-22T12:17:45.000Z</published>
    <updated>2019-04-22T12:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --><p>今天，又遇到一个 Maven 冲突的问题，这种问题我遇到的多了，每次都是因为项目依赖管理混乱或者为新功能增加依赖之后影响了旧功能，这次就是因为后者，新增加的依赖的传递依赖覆盖了原有的依赖，导致了问题的产生。大家如果搜索我的博客，搜索关键词 maven 或者 mvn，应该可以看到好几篇类似的文章，每次的情况都略有不同，每次解决问题的过程也是很崩溃。不过，每次崩溃之后都是一阵喜悦，毕竟感觉自己的经验又扩充了一些，以后遇到此类问题可以迅速解决。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 写了一个 mapReduce 程序从 HBase 读取数据，写入到 Elasticsearch 中，整体的框架是从别的项目复制过来的，自己重写了处理逻辑以及环境相关的参数，但是跑起来的时候，map 过程很顺利，几百个 task 全部成功完成，但是 reduce 过程直接挂了，几十个 task 全部失败，重试了还是失败。</p><p>我只能去查看日志，去 Hadoop 监控界面，看到对应任务的报错日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">2019-04-22 16:01:30,469 ERROR [main] com.datastory.banyan.spark.ScanFlushESMRV2$FlushESReducer: org/apache/http/message/TokenParser</span><br><span class="line">java.lang.NoClassDefFoundError: org/apache/http/message/TokenParser</span><br><span class="line">at org.apache.http.client.utils.URLEncodedUtils.parse (URLEncodedUtils.java:280)</span><br><span class="line">at org.apache.http.client.utils.URLEncodedUtils.parse (URLEncodedUtils.java:237)</span><br><span class="line">at org.apache.http.client.utils.URIBuilder.parseQuery (URIBuilder.java:111)</span><br><span class="line">at org.apache.http.client.utils.URIBuilder.digestURI (URIBuilder.java:181)</span><br><span class="line">at org.apache.http.client.utils.URIBuilder.&lt;init&gt;(URIBuilder.java:91)</span><br><span class="line">at org.apache.http.client.utils.URIUtils.rewriteURI (URIUtils.java:185)</span><br><span class="line">at org.apache.http.impl.nio.client.MainClientExec.rewriteRequestURI (MainClientExec.java:494)</span><br><span class="line">at org.apache.http.impl.nio.client.MainClientExec.prepareRequest (MainClientExec.java:529)</span><br><span class="line">at org.apache.http.impl.nio.client.MainClientExec.prepare (MainClientExec.java:156)</span><br><span class="line">at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl.start (DefaultClientExchangeHandlerImpl.java:125)</span><br><span class="line">at org.apache.http.impl.nio.client.InternalHttpAsyncClient.execute (InternalHttpAsyncClient.java:129)</span><br><span class="line">at org.elasticsearch.client.RestClient.performRequestAsync (RestClient.java:343)</span><br><span class="line">at org.elasticsearch.client.RestClient.performRequestAsync (RestClient.java:325)</span><br><span class="line">at org.elasticsearch.client.RestClient.performRequestAsync (RestClient.java:268)</span><br><span class="line">at org.elasticsearch.client.RestHighLevelClient.performRequestAsync (RestHighLevelClient.java:445)</span><br><span class="line">at org.elasticsearch.client.RestHighLevelClient.performRequestAsyncAndParseEntity (RestHighLevelClient.java:423)</span><br><span class="line">at org.elasticsearch.client.RestHighLevelClient.bulkAsync (RestHighLevelClient.java:206)</span><br><span class="line">at com.datastory.banyan.client.es.ESBulkProcessor.lambda$new$0 (ESBulkProcessor.java:154)</span><br><span class="line">at org.elasticsearch.action.bulk.Retry$RetryHandler.execute (Retry.java:230)</span><br><span class="line">at org.elasticsearch.action.bulk.Retry.withAsyncBackoff (Retry.java:87)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkRequestHandler$AsyncBulkRequestHandler.execute (BulkRequestHandler.java:138)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkProcessor.execute (BulkProcessor.java:350)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkProcessor.executeIfNeeded (BulkProcessor.java:341)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkProcessor.internalAdd (BulkProcessor.java:276)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkProcessor.add (BulkProcessor.java:259)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkProcessor.add (BulkProcessor.java:255)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkProcessor.add (BulkProcessor.java:241)</span><br><span class="line">at com.datastory.banyan.client.es.ESBulkProcessor.addIndexRequest (ESBulkProcessor.java:237)</span><br><span class="line">at com.datastory.banyan.spark.ScanFlushESMRV2$FlushESReducer.reduce (ScanFlushESMRV2.java:212)</span><br><span class="line">at com.datastory.banyan.spark.ScanFlushESMRV2$FlushESReducer.reduce (ScanFlushESMRV2.java:158)</span><br><span class="line">at org.apache.hadoop.mapreduce.Reducer.run (Reducer.java:171)</span><br><span class="line">at org.apache.hadoop.mapred.ReduceTask.runNewReducer (ReduceTask.java:627)</span><br><span class="line">at org.apache.hadoop.mapred.ReduceTask.run (ReduceTask.java:389)</span><br><span class="line">at org.apache.hadoop.mapred.YarnChild$2.run (YarnChild.java:168)</span><br><span class="line">at java.security.AccessController.doPrivileged (Native Method)</span><br><span class="line">at javax.security.auth.Subject.doAs (Subject.java:422)</span><br><span class="line">at org.apache.hadoop.security.UserGroupInformation.doAs (UserGroupInformation.java:1709)</span><br><span class="line">at org.apache.hadoop.mapred.YarnChild.main (YarnChild.java:162)</span><br></pre></td></tr></table></figure><p>截图如下：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brjd9bl2j210d0j9q4k.jpg" alt="异常日志信息" title="异常日志信息"></p><p>看到关键部分：<strong>java.lang.NoClassDefFoundError: org/apache/http/message/TokenParser</strong>，表面看是类未定义，但是真实情况是什么还要继续探索，例如依赖缺失、依赖冲突导致的类不匹配等。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><h2 id="初步分析"><a href="# 初步分析" class="headerlink" title="初步分析"></a> 初步分析 </h2><p> 先搜索类 <strong>TokenParser</strong> 吧，看看能不能搜索到，在 IDEA 中搜索，我的环境是使用 <strong>ctrl + shift + t</strong> 快捷键，搜索之后发现存在这个类，记住对应的 jar 包坐标以及版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.httpcomponents:httpcore:jar:4.3.2</span><br></pre></td></tr></table></figure><p>这里需要注意一点，如果你的项目是由多个子项目聚合而成的，此时使用 IDEA 的搜索功能并不准确，会搜索出来其它子项目的同名依赖，从而误导你的视线，所以还是使用依赖分析插件比较好，例如：depedency，下面也会讲到。</p><p>既然类已经存在，说明有极大可能是依赖冲突导致的 <strong>NoClassDefFoundError</strong>。继续从错误日志中寻找蛛丝马迹，看到 <strong>at org.apache.http.client.utils.URLEncodedUtils.parse (URLEncodedUtils.java:280)</strong> 这里，接着搜索类 <strong>URLEncodedUtils</strong> 并查看第 280 行的 <strong>parse</strong> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.httpcomponents:httpclient:jar:4.5.2</span><br></pre></td></tr></table></figure><p>上面是依赖坐标以及版本，看到这里有经验的工程师已经可以发现问题所在了：两个同类型的依赖 jar 包版本差别太大，这里暂且不分析。</p><p>接着查看源码：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brkjzrvrj20v50djt9j.jpg" alt="URLEncodedUtils 源码" title="URLEncodedUtils 源码"></p><p>好，到这里已经把基本情况分析清楚了，程序异常里面的 <strong>NoClassDefFoundError</strong> 并不是类缺失，所以没有报错 <strong>ClassNotFound</strong>。根本原因是类版本不对，导致 <strong>URLEncodedUtils</strong> 找不到自己需要的特定版本的类，尽管有一个同名的低版本的类存在，但是对于 Java 虚拟机来说这是完全不同的两个类，这也是容易误导人的地方。</p><p>再延伸一下话题，如果真的是类不存在，使用 IDEA 查看源码时会显示红色字体提示的，如图：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brle6hgjj20zc0ieq49.jpg" alt="类不存在错误提示" title="类不存在错误提示"></p><h2 id="详细分析"><a href="# 详细分析" class="headerlink" title="详细分析"></a>详细分析 </h2><p> 接下来就使用依赖分析插件 <strong>dependency</strong> 来分析这两个 jar 包的来源以及版本差异，在项目的根目录执行 <strong>mvn dependency:tree -Dverbose &gt; tree.txt</strong> ，把依赖树信息重定向到 tree.txt 文件中，里面的 -Dverbose 参数可以使我们更为清晰地看到版本冲突的 jar 包以及实际使用的 jar 包。</p><p>找到 httpclient 和 httpcore 的来源，依赖树片段截取如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] +- com.company.commons3:ds-commons3-es-rest:jar:1.2:compile</span><br><span class="line">[INFO] |  +- org.apache.httpcomponents:httpclient:jar:4.5.2:compile</span><br><span class="line"></span><br><span class="line">...... 省略 </span><br><span class="line"></span><br><span class="line">[INFO] |  +- org.apache.httpcomponents:httpasyncclient:jar:4.0.2:compile</span><br><span class="line">[INFO] |  |  +- org.apache.httpcomponents:httpcore:jar:4.3.2:compile</span><br><span class="line">[INFO] |  |  +- (org.apache.httpcomponents:httpcore-nio:jar:4.3.2:compile - omitted for duplicate)</span><br><span class="line">[INFO] |  |  +- (org.apache.httpcomponents:httpclient:jar:4.3.5:compile - omitted for conflict with 4.5.2)</span><br><span class="line">[INFO] |  |  \- (commons-logging:commons-logging:jar:1.1.3:compile - omitted for duplicate)</span><br></pre></td></tr></table></figure><p>可以看到 <strong>httpclient</strong> 来自于 <strong>ds-commons3-es-rest</strong>，版本为 4.5.2，而 <strong>httpcore</strong> 来自于 <strong>httpasyncclient</strong>，版本为 4.3.2。</p><p>特别注意：<strong>httpasyncclient</strong> 里面还有一个 4.3.5 版本的 <strong>httpclient</strong> 由于版本冲突被忽略了，这也是导致问题的元凶。</p><p>依赖树片段截图如下：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brlwy34ij210404e74q.jpg" alt="依赖树片段 1" title="依赖树片段 1"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brm3rutxj211508h0tr.jpg" alt="依赖树片段 2" title="依赖树片段 2"></p><p>到这里已经可以知道问题所在了，<strong>httpclient</strong>、<strong>httpcore</strong> 这两个依赖的版本差距太大，前者 4.5.2，后者 4.3.2，导致前者的类 URLEncodedUtils 在调用后者的类 TokenParser 时，找不到满足条件的版本，于是抛出异常：NoClassDefFoundError。</p><h2 id="解决方案"><a href="# 解决方案" class="headerlink" title="解决方案"></a>解决方案 </h2><p> 那这个问题也是很容易解决的，指定版本接近的两个依赖即可，但是还是要根据实际情况而来。本来最简单的方案就是移除所有相关依赖，然后在 pom.xml 中显式地指定这两个依赖的版本。但是这么做太简单粗暴了，因为这两个依赖不是一级依赖，而是传递依赖，不必手动管理。所以要适当地移除某一些传递依赖，保留另一些传递依赖，让它们不要交叉出现。</p><p>我的做法就是移除 <strong>ds-commons3-es-rest</strong> 里面的传递依赖，保持 <strong>httpasyncclient</strong> 里面的传递依赖，这样它们的版本号接近，而且是同一个依赖里面传递的，基本不可能出错。</p><p>pom.xml 配置如图：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brnorbdej211p0amaaq.jpg" alt="修复后的 pom 配置" title="修复后的 pom 配置"></p><p>httpclient 的小版本号是可以比 httpcore 高一点的，继续查看依赖树，可以看到 httpclient 的版本为 4.3.5，httpcore 的版本为 4.3.2。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brntqakfj20rp021aa1.jpg" alt="修复后的 http 依赖版本号" title="修复后的 http 依赖版本号"></p><h2 id="引申插件"><a href="# 引申插件" class="headerlink" title="引申插件"></a>引申插件 </h2><p> 除了 dependency 插件外，还有另外一个插件也非常好用：enforcer，插件的坐标如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 帮助分析依赖冲突的插件，可以在编译时期找到依赖问题 --&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-enforcer-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.1&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;enforce-ban-duplicate-classes&lt;/id&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;enforce&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;!-- 设置规则，否则没法检查 --&gt;</span><br><span class="line">                &lt;rules&gt;</span><br><span class="line">                    &lt;!-- 检查重复类 --&gt;</span><br><span class="line">                    &lt;banDuplicateClasses&gt;</span><br><span class="line">                        &lt;!-- 忽略一些类 --&gt;</span><br><span class="line">                        &lt;ignoreClasses&gt;</span><br><span class="line">                            &lt;ignoreClass&gt;javax.*&lt;/ignoreClass&gt;</span><br><span class="line">                            &lt;ignoreClass&gt;org.junit.*&lt;/ignoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.aspectj.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.jboss.netty.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.apache.juli.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.apache.commons.logging.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.apache.log4j.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.objectweb.asm.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.parboiled.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.apache.xmlbeans.xml.stream.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.json.JSONString&lt;/ingoreClass&gt;</span><br><span class="line">                        &lt;/ignoreClasses&gt;</span><br><span class="line">                        &lt;!-- 除了上面忽略的类，检查所有的类 --&gt;</span><br><span class="line">                        &lt;findAllDuplicates&gt;true&lt;/findAllDuplicates&gt;</span><br><span class="line">                    &lt;/banDuplicateClasses&gt;</span><br><span class="line">                    &lt;!-- JDK 在 1.8 以上 --&gt;</span><br><span class="line">                    &lt;requireJavaVersion&gt;</span><br><span class="line">                        &lt;version&gt;1.8.0&lt;/version&gt;</span><br><span class="line">                    &lt;/requireJavaVersion&gt;</span><br><span class="line">                    &lt;!-- Maven 在 3.0.5 以上 --&gt;</span><br><span class="line">                    &lt;requireMavenVersion&gt;</span><br><span class="line">                        &lt;version&gt;3.0.5&lt;/version&gt;</span><br><span class="line">                    &lt;/requireMavenVersion&gt;</span><br><span class="line">                &lt;/rules&gt;</span><br><span class="line">                &lt;fail&gt;true&lt;/fail&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">    &lt;!-- 官方的默认规则 --&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;extra-enforcer-rules&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-beta-6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>这个插件需要配置在 pom.xml 中，并且绑定 Maven 的生命周期，默认是绑定在 compile 上面，然后需要给 enforcer 配置一些规则，例如检查重复的类。接着在编译期间，enforcer 插件就会检验项目的依赖中所有的类【可以设置忽略容器中的类，例如作用域为 provided 的依赖包】，如果有重复的类，就会报错，编译不会通过。</p><p>注意，这个插件除了可以检查依赖、类的冲突【通过设置规则 rule 来实现】，还可以设置一些其它的开发规范，例如规定 JDK 版本、开发系统环境必须为 Windows、使用的 Maven 版本等等。此外，官方也提供了一些规则列表可以参考：<a href="http://maven.apache.org/enforcer/enforcer-rules/index.html" target="_blank" rel="noopener">http://maven.apache.org/enforcer/enforcer-rules/index.html</a> ，而且还有 API 允许我们自定义规则，非常灵活。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结 </h1><h2 id="抽象总结"><a href="# 抽象总结" class="headerlink" title="抽象总结"></a> 抽象总结 </h2><p> 总结一下现象，其实就是项目本来依赖了 B 包，B 包里面有传递依赖包 1、包 2，由于包 1、包 2 都来自于 B 包，所以版本差别不大，很适配。包 1 的类调用包 2 的类很顺利，不会有问题。</p><p>后来由于其它功能需要，项目又加入了 A 包，此时没有注意到 A 包里面也有包 1，而且比 B 包里面的包 1 版本高，这本来不是问题，只是潜在风险。但是，编译打包时 A 包里面的包 1 把 B 包里面的包 1 覆盖了，包 2 仍旧是来自于 B 包，这就出问题了，风险变成灾难了。当程序运行时包 1 需要调用包 2，由于版本差别过大，找不到符合条件的类了，抛出异常：NoClassDefFoundError。</p><p>这里面的验证机制浅显地描述就是每个类都会有自己的序列化编号，如果有严格要求同版本依赖的类，调用方法时会严格验证。</p><h2 id="关于编译的疑问"><a href="# 关于编译的疑问" class="headerlink" title="关于编译的疑问"></a>关于编译的疑问 </h2><p> 到这里，读者会有疑问，为什么编译不报错，能顺利通过呢？其实从上面就能看到答案了，这种依赖包之间相互引用的类，类是存在的，只是版本不一致而已，编译时并不能检测出来。如果是你自己写的类源码，引用了别的依赖包的类，同时对版本要求严格的话，编译是一定会报错的。</p><p>但是，如果你提前知道了是哪个类，一般不可能知道，只有报错了才会知道，而且会有不止一个类，这也是令人头疼的地方。</p><p>如果进一步分析异常信息，发现它归属于 ERROR，并不是运行时异常，更不用谈编译时异常了，这种错误和 OutOfMemoryError 类似，是虚拟机运行时出现问题，比较严重。</p><h2 id="感悟"><a href="# 感悟" class="headerlink" title="感悟"></a>感悟 </h2><p> 找到这种问题的原因是没有什么难度的，一眼就可以看出来是依赖冲突。但是解决过程可谓是难度极大，而且可以让人崩溃，对于初学者来说可以放弃了，折腾三天可能都不会有结果的。特别在依赖庞大的情况下，几百个依赖包，几百 M 大小，这时候找起来特别麻烦，有时候改动了一点会影响到其它的依赖，引起连锁反应，可能问题还没解决，又引发了其它问题。</p><p>所以，在项目开发的初始阶段，一定要管理好项目的依赖，并且在依赖变更时要一起讨论，否则后患无穷。</p><p>此外，在解决依赖冲突的过程中，有 2 个插件工具很好用：dependency、enforcer。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天，又遇到一个 Maven 冲突的问题，这种问题我遇到的多了，每次都是因为项目依赖管理混乱或者为新功能增加依赖之后影响了旧功能，这次就是因为后者，新增加的依赖的传递依赖覆盖了原有的依赖，导致了问题的产生。大家如果搜索我的博客，搜索关键词 maven 或者 mvn，应该可以看到好几篇类似的文章，每次的情况都略有不同，每次解决问题的过程也是很崩溃。不过，每次崩溃之后都是一阵喜悦，毕竟感觉自己的经验又扩充了一些，以后遇到此类问题可以迅速解决。&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑系列" scheme="https://www.playpi.org/categories/series-of-fixbug/"/>
    
    
      <category term="httpcore" scheme="https://www.playpi.org/tags/httpcore/"/>
    
      <category term="maven" scheme="https://www.playpi.org/tags/maven/"/>
    
      <category term="dependency" scheme="https://www.playpi.org/tags/dependency/"/>
    
      <category term="enforcer" scheme="https://www.playpi.org/tags/enforcer/"/>
    
  </entry>
  
  <entry>
    <title>Linux 之 kill 命令入门实践</title>
    <link href="https://www.playpi.org/2019042101.html"/>
    <id>https://www.playpi.org/2019042101.html</id>
    <published>2019-04-21T14:35:27.000Z</published>
    <updated>2019-04-21T14:35:27.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --><p>最近在实际应用场景中，需要使用 Linux 系统的 <strong>kill</strong> 命令来控制程序的生命周期，例如 <strong>ctrl + c</strong>、<strong>ctrl + z</strong>、<strong>kill -9 pid</strong> 等，而这些命令在日常的工作当中也是非常常见的并且很好用。为了多了解一些 Linux 中信号常量的知识点，以及 kill 命令的基本原理，我整理了这一篇博客。</p><a id="more"></a><h1 id="基础知识"><a href="# 基础知识" class="headerlink" title="基础知识"></a>基础知识 </h1><h2 id="信号"><a href="# 信号" class="headerlink" title="信号"></a> 信号 </h2><p> 根据 kill 的实际使用来初步了解一下信号的概念。</p><p>首先要清楚一个基本知识点：kill 命令只是用来向进程发送信号的，而不是直接杀死进程的，实际操控进程生命的仍旧是系统内核以及信号常量的规范动作【进程本身注册的信号动作：默认、忽略、捕捉自定义】。</p><blockquote><p>kill 命令使用户能够向进程发送信号，信号是发送给进程以中断进程并使其作出反应的信息。如果进程被设计为对发送给它的该类型信号作出反应，则它将作出反应；否则，该进程将终止。</p></blockquote><p>对于进程对信号做出正常反应的情况，例如对一个进程发送编号为 9 的信号，则该进程会终止。而对一个进程发送编号为 19 的信号【SIGSTOP】，则该进程会退到后台暂停，接着使用编号为 18 的信号【SIGCONT】可以激活进程继续运行【也可以直接使用 fg /bg 这一对命令】。</p><p>对于进程不能对信号做出反应而终止的情况，例如对一个进程发送编号为 10 的信号【SIGUSR1】，这个信号本来是给用户自定义的，而普通的进程没有被设计为对这个信号做出反应，因此进程将终止运行【另一方面，在 PHP 中，后台进程会对这个信号做出反应，是因为官方发布的程序实现了这个信号的指令，并为进程注册了这个信号】。</p><blockquote><p>对于 Linux 来说，实际上信号是软中断，许多重要的程序都需要处理信号。信号，为 Linux 提供了一种处理异步事件的方法。</p></blockquote><p>每个信号都有一个名字和编号，这些名字都以 <strong>SIG</strong> 开头，例如 <strong>SIGINT</strong>、<strong>SIGKILL</strong> 等等。信号定义在 <strong>signal.h</strong>【/usr/include/asm/signal.h】头文件中，信号编号都定义为正整数，从 1 开始。当然，也有编号为 0 的信号，但是它对于 kill 有特殊的应用。</p><p>使用 <strong>kill -l</strong> 可以查看所有的信号常量列表，其中，前面 32 个是基本的，后面 32 个是扩展的【做底层驱动开发时能用到】。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518213523.png" alt="kill 命令查看信号常量" title="kill 命令查看信号常量"></p><h2 id="常用信号常量"><a href="# 常用信号常量" class="headerlink" title="常用信号常量"></a>常用信号常量 </h2><p> 以下列举一些常用的信号常量以及解释说明：</p><table><thead><tr><th style="text-align:center">信号编号 </th><th style="text-align:center"> 信号名称 </th><th style="text-align:center"> 信号解释 </th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">SIGHUP</td><td style="text-align:center"> 挂起【hang up】，终端断线，经常在退出系统前使用。但是，一般启动程序时为了让程序继续运行，会指定 nohup 就是为了不让程序挂起，这样在退出系统时程序仍旧能正常运行 </td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">SIGINT</td><td style="text-align:center"> 中断【与键盘快捷键 ctrl + c 对应】，表示与键盘中断 </td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">SIGQUIT</td><td style="text-align:center"> 退出【与键盘快捷键 ctrl + \ 对应】</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">SIGKILL</td><td style="text-align:center">强制终止，程序必须终止【无需清除】，只有进程属主或者超级用户发出该命令时才起作用 </td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">SIGTERM</td><td style="text-align:center"> 停止，要求进程自己退出【需要先清除】，所以可能停止失败，只有进程属主或者超级用户发出该命令时才起作用 </td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">SIGUSR1</td><td style="text-align:center"> 用户自定义信号 1</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">SIGSEGV</td><td style="text-align:center">段错误信号，在操作内存、硬盘资源出错时会出现，例如硬盘空间不足、内存读取无权限时 </td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">SIGUSR2</td><td style="text-align:center"> 用户自定义信号 2</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">SIGCONT</td><td style="text-align:center">继续【与命令 fg/bg 对应】</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">SIGSTOP</td><td style="text-align:center">暂停【与键盘快捷键 ctrl + z 对应】，可以使用信号 18 来继续运行，或者使用 fg/bg 来调度到前 / 后台继续运行 </td></tr></tbody></table><p> 也可以在 Linux 机器上面使用 <strong>man 7 signal</strong> 可以查看帮助文档，有更为详细的解释说明。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518213623.png" alt="man 7 signal 查看帮助文档" title="man 7 signal 查看帮助文档"></p><p>在所有的信号中，只有编号为 9 的信号【SIGKILL】才可以 <strong>无条件终止 </strong>进程，编号为 15 的信号【SIGTERM】也可以 <strong>停止 </strong>进程，但是可能终止失败。对于编号为 9 的信号【SIGKILL】和编号为 19 的信号【SIGSTOP】，进程无法选择忽略，必须做出反应，而对于其它的信号，进程都有权利选择忽略。</p><h2 id="信号处理动作详解"><a href="# 信号处理动作详解" class="headerlink" title="信号处理动作详解"></a>信号处理动作详解 </h2><p> 对于信号的处理有三种方式：忽略、捕捉、默认。</p><blockquote><p>忽略信号，大多数信号可以使用这个方式来处理，但是有两种信号不能被忽略：9 号【SIGKILL】、19 号【SIGSTOP】。因为这两个信号向内核和超级用户提供了 <strong>终止 </strong>和 <strong>停止 </strong>的 <strong>可靠 </strong>方法，如果被忽略了，那么这个进程就变成了没人能管理的的进程，显然这是内核设计者不希望看到的场景。</p></blockquote><blockquote><p>捕捉信号，需要告诉内核，程序希望如何处理某一种信号，其实就是写一个信号处理函数，里面写上自定义的处理逻辑，然后将这个函数告诉内核【注册函数】。当该信号产生时，由内核来调用用户的自定义函数，以此来实现某种信号的自定义处理。说到底，就是进程捕捉信号，自定义处理，不使用内核默认的处理方式。</p></blockquote><blockquote><p>系统默认动作，对于每个信号来说，系统都对应有默认的处理动作。当发生了该信号，系统会自动执行。不过，对系统来说，大部分的处理方式都比较粗暴，就是直接杀死该进程。</p></blockquote><h2 id="信号的实际使用"><a href="# 信号的实际使用" class="headerlink" title="信号的实际使用"></a>信号的实际使用 </h2><p> 以上把信号的基本概念了解清楚了，但是在实际中程序是怎么使用的呢？为了配合使用，必须有两方面程序：一是信号发送方【即负责发送信号的工具，例如 kill 就可以】，另一方是接收方【即能接收信号并且做出反应的程序，基本所有运行在 Linux 上的程序都可以】。</p><p>接下来就以 c 语言编程，写两个例子，模拟发送方【封装 kill】、接收方【信号处理函数注册】，来观察一下信号的实际应用。</p><h3 id="信号处理函数注册"><a href="# 信号处理函数注册" class="headerlink" title="信号处理函数注册"></a>信号处理函数注册 </h3><p> 信号处理函数的注册，使用入门版的接口，signal 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal (<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br></pre></td></tr></table></figure><p>根据函数原型可以看出，由两部分组成，一个是真正处理信号的函数，另一个是注册函数。对于 <strong>sighandler_t signal (int signum, sighandler_t handler)</strong> 函数来说，signum 显然是信号的编号，handler 是处理函数的指针。同样地，在 <strong>typedef void (*sighandler_t)(int)</strong> 这个处理函数的原型中，有一个参数是 int 类型，显然也是信号的编号，在实现函数时要根据信号的编号进行不同的操作。</p><p>只需要实现真正的处理信号的方法即可，以下是示例，信号处理只是打印，方便观察：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理函数只把接收到的信号编号打印出来 </span></span><br><span class="line">    <span class="keyword">if</span>(signum == SIGIO)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SIGIO signal: % d\n"</span>, signum);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(signum == SIGUSR1)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SIGUSR1 signal: % d\n"</span>, signum);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略 SIGINT, 默认处理 SIGTERM, 其它信号不注册都会导致程序退出 </span></span><br><span class="line">    signal (SIGIO, handler);</span><br><span class="line">    signal (SIGUSR1, handler);</span><br><span class="line">    signal (SIGINT, SIG_IGN);</span><br><span class="line">    signal (SIGTERM, SIG_DFL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SIGIO=% d,SIGUSR1=% d,SIGINT=% d,SIGTERM=% d\n"</span>, SIGIO, SIGUSR1, SIGINT, SIGTERM);</span><br><span class="line">    <span class="comment">// 以下是无限循环 </span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        sleep (<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 gcc 编译器编译【如果 Linux 环境不带需要自行安装】：gcc -o signal_test signal_test.c ，然后就可以执行了：./signal_test 。</p><p>接着使用 ctrl + c 快捷键【被进程忽略】，使用 kill 命令发送 29 号信号【被接收并打印出来编号】、10 号信号【被接收并打印出来编号】、2 号【被接收并忽略】、15 号【被接收并按照系统默认动作停止进程】，具体看下面的两张图片。</p><p>使用 kill 命令发送信号 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518222351.png" alt="使用 kill 命令发送信号" title="使用 kill 命令发送信号"></p><p> 进程接收信号的处理方式 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518222402.png" alt="进程接收信号的处理方式" title="进程接收信号的处理方式"></p><p> 接着演示 kill 发送一个程序没有注册的信号 12 号【SIGUSR2】，可以观察到程序直接退出。</p><p>kill 发送 12 号信号 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518223015.png" alt="kill 发送 12 号信号" title="kill 发送 12 号信号"></p><p> 进程直接退出 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518223037.png" alt="进程直接退出" title="进程直接退出"></p><h3 id="信号发送工具模拟"><a href="# 信号发送工具模拟" class="headerlink" title="信号发送工具模拟"></a> 信号发送工具模拟 </h3><p> 信号发送工具比较简易，其实就是模拟封装 kill，观察效果，先看一下 kill 函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到函数原型很简单，有两个参数，pid 是信号接受者的 pid，sig 是信号编号，接着就实现一个简单的脚本，里面直接调用 kill 函数，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 接收的参数个数不足 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">3</span> != argc)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[Arguments ERROR!]\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tUsage:\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\t\t% s &lt;Target_PID&gt; &lt;Signal_Number&gt;\n"</span>, argv [<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pid = atoi (argv [<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> sig = atoi (argv [<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 这里增加一个对编号判断的逻辑 </span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span> &amp;&amp; sig &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        kill (pid, sig);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Target_PID or Signal_Number MUST bigger than 0!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此特殊说明一下，关于 pid 的取值范围，上述代码示例把 pid 限制在正整数，防止出错。其实 pid 的取值范围很广，各有特殊含义，请参考文末的备注。</p><p>使用 gcc 编译后【gcc -o signal_kill signal_kill.c】直接运行，观察能否把信号正常发送给运行的进程。</p><p>运行脚本发送信号 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518224421.png" alt="运行脚本发送信号" title="运行脚本发送信号"></p><p> 运行的进程可以正常接收到信号 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518224412.png" alt="运行的进程可以正常接收到信号" title="运行的进程可以正常接收到信号"></p><p> 经过观察，是可以的，至此信号函数的使用演示完成。</p><h1 id="操作实践"><a href="# 操作实践" class="headerlink" title="操作实践"></a>操作实践 </h1><p> 详细认识信号的基本知识后，接下来进行实践会更加知其所以然，那就回归到正题，我来使用 kill 命令进行实践操作一下，演示一下常用的信号以及处理效果。</p><p>在日常工作中，一般会使用信号 1、信号 3、信号 3、信号 9、信号 15，这五个比较常用，就不再演示，只是需要留意一下它们对应的键盘快捷键，信号 2 是 ctrl + c，信号 3 是 ctrl + \ 。</p><p>我想重点演示一下信号 18、信号 19 以及 bg、fg、jobs 命令。</p><h2 id="演示"><a href="# 演示" class="headerlink" title="演示"></a>演示 </h2><p> 开启三个进程，分别使用 ctrl + z 命令暂停它们的运行，在暂停时输出的日志中会有 Stopped 标记，并且会有进程的编号分配，在方括号中的就是【有时候暂停时还会有 <strong>核心已转储 </strong>的提示】。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518231714.png" alt="开启三个进程分别暂停" title="开启三个进程分别暂停"></p><p>使用 jobs 命令查看暂停的进程，此时每个进程会有编号，此时的三个进程分别是 2、3、4。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518231705.png" alt="jobs 查看暂停的进程" title="jobs 查看暂停的进程 v"></p><p>使用 kill 发送 18 号信号给编号为 4 的暂停进程，然后再次使用 jobs 命令查看，发现这个进程的状态已经由 Stopped 变为了 Running，说明这个进程继续运行了【但是是后台运行，没有占用终端】。</p><p>发送 18 号信号 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518232545.png" alt="发送 18 号信号" title="发送 18 号信号"></p><p> 编号为 4 的进程后台运行中 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518232554.png" alt="编号为 4 的进程后台运行中" title="编号为 4 的进程后台运行中"></p><p> 接着使用 fg、bg 命令把编号为 4 的进程调到前台运行、返回后台运行。此时可以发现，fg、bg 命令和信号 18 的作用是等价的，而且更为丰富，可以把进程在前台【占用终端】、后台【不占用终端】之间调换。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518233026.png" alt="使用 fg、bg 命令" title="使用 fg、bg 命令"></p><h2 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h2><p> 总结一下：</p><p>对于正在运行的进程，并且等待终端的输入，此时如果使用 <strong>ctrl + c</strong> 就会导致进程退出，所以可以使用 <strong>ctrl + z</strong> 让进程暂停，并退到后台等待，此时终端被释放，可以继续输入命令。</p><p>接着可以使用 <strong>jobs</strong> 命令查看有哪些被暂停的进程【此时进程会有编号，从 1 开始】，可以使用 <strong>bg num</strong> 命令让第 num 个进程在后台运行，可以使用 <strong>fg num</strong> 让第 num 个进程在前台运行【继续占用终端】。当然，如果使用 bg、fg 时不加序号参数，则默认对最后一个进程操作。</p><h1 id="备注"><a href="# 备注" class="headerlink" title="备注"></a>备注 </h1><h2 id="段错误"><a href="# 段错误" class="headerlink" title="段错误"></a> 段错误 </h2><p> 段错误的实际例子。</p><h2 id="进程号取值"><a href="# 进程号取值" class="headerlink" title="进程号取值"></a>进程号取值</h2><p>pid 就是系统给进程分配的编号，除了正常的正整数之外，其它的取值有各自特殊的含义。</p><ul><li>pid 大于 0，将信号发送给进程 id 为 pid 的进程</li><li>pid 等于 0，将信号发送给与发送进程属于同一进程组的所有进程【即进程组 id 相等的进程】</li><li>pid 等于 - 1，将该信号发送给系统内所有的进程【前提是有发送信号权限的，并且不包括系统进程集中的进程】</li><li>pid 小于 - 1，将该信号发送给其进程组 id 等于 pid 绝对值的所有进程【针对进程组】</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近在实际应用场景中，需要使用 Linux 系统的 &lt;strong&gt;kill&lt;/strong&gt; 命令来控制程序的生命周期，例如 &lt;strong&gt;ctrl + c&lt;/strong&gt;、&lt;strong&gt;ctrl + z&lt;/strong&gt;、&lt;strong&gt;kill -9 pid&lt;/strong&gt; 等，而这些命令在日常的工作当中也是非常常见的并且很好用。为了多了解一些 Linux 中信号常量的知识点，以及 kill 命令的基本原理，我整理了这一篇博客。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux 命令系列" scheme="https://www.playpi.org/categories/series-of-linux-cmd/"/>
    
    
      <category term="Linux" scheme="https://www.playpi.org/tags/Linux/"/>
    
      <category term="kill" scheme="https://www.playpi.org/tags/kill/"/>
    
      <category term="jobs" scheme="https://www.playpi.org/tags/jobs/"/>
    
  </entry>
  
  <entry>
    <title>JNI 字段描述符基础知识</title>
    <link href="https://www.playpi.org/2019041301.html"/>
    <id>https://www.playpi.org/2019041301.html</id>
    <published>2019-04-13T09:12:45.000Z</published>
    <updated>2019-04-14T09:12:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --><p>平时在做 Java 开发的时候，难免遇到异常信息中包含一种特殊的表达字符串，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method: createWorker signature: (Ljava/util/concurrent/Executor;) Lorg/jboss/netty/channel/socket/nio/AbstractNioWorker;</span><br></pre></td></tr></table></figure><p>或者 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: com.fasterxml.jackson.databind.JavaType.isReferenceType () Z</span><br></pre></td></tr></table></figure><p> 可以看到，异常信息中有一种特殊的字符串出现了：<strong>L 后面跟着类名 </strong>、<strong> 方法后面跟了一个 Z</strong>。其实，这就是 <strong>JNI 字段描述符【Java Native Interface FieldDescriptors】</strong>，它是一种对 Java 数据类型、数组、方法的编码。此外，在 Android 逆向分析中，通过反汇编得到的 smali 文件，里面的代码也会遵循这种方式，即 Dalvik 字节码。本文就记录一些数据类型、数组、方法的编码方式以及解释说明，方便以后查阅。</p><a id="more"></a><h1 id="基本概念"><a href="# 基本概念" class="headerlink" title="基本概念"></a>基本概念 </h1><p> 这种编码方式把 Java 中的基本数据类型、数组、对象都使用一种规范来表示：</p><ul><li>八种基本数据类型都使用一个大写字母表示 </li><li>void 使用 V 表示</li><li> 数组使用左方括号表示 </li><li> 方法使用一组圆括号表示，参数在括号里，返回类型在括号右侧 </li><li> 对象使用 L 开头，分号结束，中间是类的完整路径，包名使用正斜杠分隔 </li></ul><h1 id="基本编码"><a href="# 基本编码" class="headerlink" title="基本编码"></a> 基本编码 </h1><p> 基本编码如下表格，并配有解释说明：</p><table><thead><tr><th style="text-align:center">Java 类型 </th><th style="text-align:center">JNI 字段描述符</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center">Z</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">B</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">S</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">I</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">J</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">F</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">D</td></tr><tr><td style="text-align:center">void</td><td style="text-align:center">V</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center"> 以 L 开头，以；结尾，中间是使用 / 隔开的完整包名、类型。例如：Ljava/lang/String;。如果是内部类，添加 $ 符号分隔，例如：Landroid/os/FileUtils$FileStatus;。</td></tr><tr><td style="text-align:center">数组 </td><td style="text-align:center">[</td></tr><tr><td style="text-align:center"> 方法 </td><td style="text-align:center"> 使用 () 表示，参数在圆括号里，返回类型在圆括号右侧，例如：(II) Z，表示 boolean func (int i,int j)。</td></tr></tbody></table><h1 id="举例说明"><a href="# 举例说明" class="headerlink" title="举例说明"></a>举例说明 </h1><h2 id="数据类型"><a href="# 数据类型" class="headerlink" title="数据类型"></a> 数据类型 </h2><p>1、<strong>[I</strong>：表示 int 一维数组，即 <strong>int []</strong>。<br>2、<strong>Ljava/lang/String;</strong>：表示 String 类型，即 <strong>java.lang.String</strong>。<br>3、<strong>[Ljava/lang/Object;</strong>：表示 Object 一维数组，即 <strong>java.lang.Object []</strong>。<br>4、<strong>Z</strong>：表示 boolean 类型。<br>5、<strong>V</strong>：表示 void 类型。</p><h2 id="方法"><a href="# 方法" class="headerlink" title="方法"></a> 方法</h2><p>1、<strong>() V</strong>：表示参数列表为空，返回类型为 void 的方法，即 <strong>void func ()</strong>。<br>2、<strong>(II) V</strong>：表示参数列表为 int、int，返回类型为 void 的方法，即 <strong>void func (int i,int j)</strong>。<br>3、<strong>(Ljava/lang/String;Ljava/lang/String;) I</strong>：表示参数列表为 String、String，返回类型为 int 的方法，即 <strong>int func (String i,String j)</strong>。<br>4、<strong>([B) V</strong>：表示参数列表为 byte []，返回类型为 void 的方法，即 <strong>void func (byte [] bytes)</strong>。<br>5、<strong>(ILjava/lang/Class;) J</strong>：表示参数列表为 int、Class，返回类型为 long 的方法，即 <strong>long func (int i,Class c)</strong>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;平时在做 Java 开发的时候，难免遇到异常信息中包含一种特殊的表达字符串，例如：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;method: createWorker signature: (Ljava/util/concurrent/Executor;) Lorg/jboss/netty/channel/socket/nio/AbstractNioWorker;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;或者&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.lang.NoSuchMethodError: com.fasterxml.jackson.databind.JavaType.isReferenceType () Z&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;可以看到，异常信息中有一种特殊的字符串出现了：&lt;strong&gt;L 后面跟着类名 &lt;/strong&gt;、&lt;strong&gt; 方法后面跟了一个 Z&lt;/strong&gt;。其实，这就是 &lt;strong&gt;JNI 字段描述符【Java Native Interface FieldDescriptors】&lt;/strong&gt;，它是一种对 Java 数据类型、数组、方法的编码。此外，在 Android 逆向分析中，通过反汇编得到的 smali 文件，里面的代码也会遵循这种方式，即 Dalvik 字节码。本文就记录一些数据类型、数组、方法的编码方式以及解释说明，方便以后查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="JNI" scheme="https://www.playpi.org/tags/JNI/"/>
    
      <category term="字段描述符" scheme="https://www.playpi.org/tags/JNI-chn/"/>
    
  </entry>
  
  <entry>
    <title>预估 Mysql 数据表的数据大小和索引大小</title>
    <link href="https://www.playpi.org/2019041001.html"/>
    <id>https://www.playpi.org/2019041001.html</id>
    <published>2019-04-10T08:27:18.000Z</published>
    <updated>2019-04-13T08:27:18.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --><p>最近接到一个小的新需求，需求很容易实现，就是定时把一些分析得出的指标从 Elasticsearch 中离线存储到 Mysql 数据库中，方便以后查询。离线存储的原因是因为资源不足，Elasticsearch 会自动删除 15 天以前的原始数据，而且 Elasticsearch 每天都会新产生数十万到数百万的数据，依据这些原始数据只会产生几十条分析结果，显然离线存储到 Mysql 中更为合理。在处理这个需求时，接着就遇到了一个小问题，当前业务组没有数据库资源，需要申请，而且由于资源不足，不能随便申请，要给出合理的预估值。这样，就涉及到数据库占用空间大小的预估了，本文记录一种简单的方法。</p><a id="more"></a><h1 id="数据大小和索引大小预估"><a href="# 数据大小和索引大小预估" class="headerlink" title="数据大小和索引大小预估"></a>数据大小和索引大小预估 </h1><p> 我当前使用的是 Mysql 数据库，其它数据库产品查询方式可能会有所不同，请根据实际情况操作。</p><p>在数据库中，使用系统数据库的表 <strong>TABLES</strong> 进行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT data_length,index_length</span><br><span class="line">FROM information_schema.TABLES t</span><br><span class="line">WHERE table_schema=&apos;your_db_name&apos;</span><br><span class="line">AND table_name = &apos;your_table_name&apos;;</span><br></pre></td></tr></table></figure><p>其中，系统数据库是 <strong>information_schema</strong>，存储表信息的表是 <strong>TABLES</strong>，<strong>data_length</strong>、<strong>index_length</strong> 这 2 个字段表示数据大小、索引大小，单位是字节 B。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g228n8cy91j20cd06gq2x.jpg" alt="SQL 查询数据空间大小" title="SQL 查询数据空间大小"></p><p>当然，如果使用可视化的数据库连接管理工具，也可以通过管理工具直接鼠标点击查看，其实背后的逻辑仍旧是查询 <strong>TABLES</strong> 表，例如我通过 <strong>Navicat</strong> 工具查看。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g228nw2hx5j20er0c1t8y.jpg" alt="Navicat 查看表信息" title="Navicat 查看表信息"></p><p>可见，无论使用哪种方式，都可以把需要的信息查询出来，然后就可以预估数据大小了。我截图的信息显示，数据大小 <strong>8.5MB</strong>，索引大小 <strong>0MB</strong>，还要结合数据条数，我查了一下有 10000 条数据，因此可以粗略估计每条数据的大小为 <strong>0.85KB</strong>。这里需要注意一下，预估数据大小之前要保证数据的字段取值接近真实情况，最好能有数据示例可以参考，而且数据量要尽量大一些，例如几万条，不能只有几十条、几百条。</p><p>如果确实没有数据示例参考，需要自己模拟生成，尽量把字段的取值多生成一些实际中可能出现的值。例如字符串类型如果是 <strong>vachar</strong>，要把每种长度的取值都生成一些，或者根据实际场景，某些长度的字符串出现的可能性大一点，那就多生成一些。</p><p>如果觉得这样计算比较麻烦的话，其实还有一种更简单的方法，直接查询 <strong>avg_row_length</strong> 字段，这个字段表示数据表的平均行大小，和上面自己计算的结果类似。</p><p>总之，就是为了接近真实，才能更为准确地预估出数据占用的空间大小，实际去申请资源时才能有理有据。</p><p>此外，这个 <strong>TABLES</strong> 表里面的内容很丰富的，有需要的可以查询一下，查看数据表的字段信息 SQL 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW COLUMNS FROM TABLES;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近接到一个小的新需求，需求很容易实现，就是定时把一些分析得出的指标从 Elasticsearch 中离线存储到 Mysql 数据库中，方便以后查询。离线存储的原因是因为资源不足，Elasticsearch 会自动删除 15 天以前的原始数据，而且 Elasticsearch 每天都会新产生数十万到数百万的数据，依据这些原始数据只会产生几十条分析结果，显然离线存储到 Mysql 中更为合理。在处理这个需求时，接着就遇到了一个小问题，当前业务组没有数据库资源，需要申请，而且由于资源不足，不能随便申请，要给出合理的预估值。这样，就涉及到数据库占用空间大小的预估了，本文记录一种简单的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Mysql" scheme="https://www.playpi.org/tags/Mysql/"/>
    
      <category term="数据库" scheme="https://www.playpi.org/tags/database-chn/"/>
    
      <category term="database" scheme="https://www.playpi.org/tags/database/"/>
    
      <category term="space" scheme="https://www.playpi.org/tags/space/"/>
    
  </entry>
  
  <entry>
    <title>使用 JDK 命令行工具分析内存泄漏或内存溢出问题</title>
    <link href="https://www.playpi.org/2019040301.html"/>
    <id>https://www.playpi.org/2019040301.html</id>
    <published>2019-04-03T10:14:23.000Z</published>
    <updated>2019-04-20T10:14:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --><p>最近遇到一个棘手的问题，有业务方在调用存储系统封装的 SDK 取数的过程中，遇到了 OOM 问题，但是数据量很小，只有 12000 条。同时进程启动时申请的内存高达 12g，使用 Xmx、Xms 参数控制，实际指定参数取值为：-Xms12g -Xmx12g。但是如果只看报错日志信息，抛出异常的代码位置指向了 SDK 的内部代码。根据这个现象，我猜测可能是业务方的处理逻辑问题、SDK 内部处理逻辑问题、申请的内存过小问题，这些问题归根结底，要么是内存不够【内存溢出】，要么是内存不当使用【内存泄漏】。所以，我要在 Java 虚拟机参数方面或者业务方代码逻辑方面入手，一步一步测试，找出问题的元凶。本文就记录这一过程，以及适当引申一些关于 JVM 的知识。</p><p>解释说明一下，上述中的 SDK 表示存储系统独立封装的取数、查询接口，它屏蔽了 Elasticsearch 自带的接口，并封装成公共组件，提供给各个业务方使用。各个业务方在使用前，需要申请开通 token 验证码，存储系统会根据业务方的使用量分配合适的资源，业务方在调用时需要传入 token 验证。这样做的好处，一是可以监控所有的业务方的取数、查询情况，收集所有的请求日志，统计一些常用的指标，然后反过来指导存储系统的改进，例如根据业务方的调用情况进行资源分配的伸缩、针对常用的数据类型进行索引优化。二是可以保障整个数据库集群的正常运行，由于屏蔽了 Elasticsearch 自带的接口，业务方不能随意操作超大额的数据量，SDK 会做限制，因此不会产生某些不合理的查询、取数请求，从而不对数据库造成巨大的压力。三是限制了一些不需要的查询、取数方式，在保障业务方基本需求的情况下又可以保障数据库集群的稳定，例如多层聚合、日期聚合等操作，这些操作不合理，而且会对数据库集群造成压力【无论数据量大小都可能会出事】。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 简单描述现象，查看日志，猜测可能的原因。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><h2 id="分析现象"><a href="# 分析现象" class="headerlink" title="分析现象"></a> 分析现象 </h2><p> 一开始没有指定 JVM 参数，因为使用的是 JDK1.7 版本的参数，不会生效，这就导致分配的默认堆取值偏小。</p><p>JVM 参数设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA=$&#123;JAVA_HOME&#125;/bin/java</span><br><span class="line"># 设置 jvm 的参数 </span><br><span class="line">#HEAP_OPTS=&quot;-Xms12g -Xmx12g&quot;</span><br><span class="line">HEAP_OPTS=&quot;-Xms6g -Xmx6g -Xmn2g&quot;</span><br><span class="line"># JDK8 以后取消了 PermSize</span><br><span class="line">#PERM_OPTS=&quot;-XX:PermSize=1024M -XX:MaxPermSize=2048m -XX:+UseConcMarkSweepGC -XX:+UseParNewGC&quot;</span><br><span class="line">#JDK8 的 MetaspaceSize</span><br><span class="line">PERM_OPTS=&quot;-XX:MetaspaceSize=1024m -XX:MaxMetaspaceSize=2048m -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+HeapDumpOnOutOfMemoryError&quot;</span><br></pre></td></tr></table></figure><p>待整理，重试，重现现象，确保问题准确复现。</p><h2 id="掌握内存分析工具"><a href="# 掌握内存分析工具" class="headerlink" title="掌握内存分析工具"></a>掌握内存分析工具 </h2><p> 待整理。各种工具介绍，举例，截图。</p><h2 id="对症下药解决问题"><a href="# 对症下药解决问题" class="headerlink" title="对症下药解决问题"></a>对症下药解决问题 </h2><p> 待整理。减小内存，使用普通的 list。<br>重试，使用命令行工具查看现象，截图。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结 </h1><h2 id="不同版本的参数不一致"><a href="# 不同版本的参数不一致" class="headerlink" title="不同版本的参数不一致"></a> 不同版本的参数不一致 </h2><p> 主要是针对 JDK 来说的，不同的 JDK 版本的参数会有一些不同，例如以下 2 个虚拟机参数，在 JDK1.8 的环境中是 <strong>-XX:MetaspaceSize=1024m -XX:MaxMetaspaceSize=2048m</strong>，已经不是 <strong>-XX:PermSize=1024M -XX:MaxPermSize=2048m</strong> 了【JDK 1.7 以及以前的版本】，在进程启动的时候查看日志会有警告信息的，提示参数设置无效，会被忽略。</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>占用内存，待整理。</p><h2 id="模拟内存溢出"><a href="# 模拟内存溢出" class="headerlink" title="模拟内存溢出"></a>模拟内存溢出 </h2><p> 待整理。</p><h2 id="进程已杀死问题"><a href="# 进程已杀死问题" class="headerlink" title="进程已杀死问题"></a>进程已杀死问题 </h2><p> 加大内存，机器内存不够分配，进程异常退出，待整理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近遇到一个棘手的问题，有业务方在调用存储系统封装的 SDK 取数的过程中，遇到了 OOM 问题，但是数据量很小，只有 12000 条。同时进程启动时申请的内存高达 12g，使用 Xmx、Xms 参数控制，实际指定参数取值为：-Xms12g -Xmx12g。但是如果只看报错日志信息，抛出异常的代码位置指向了 SDK 的内部代码。根据这个现象，我猜测可能是业务方的处理逻辑问题、SDK 内部处理逻辑问题、申请的内存过小问题，这些问题归根结底，要么是内存不够【内存溢出】，要么是内存不当使用【内存泄漏】。所以，我要在 Java 虚拟机参数方面或者业务方代码逻辑方面入手，一步一步测试，找出问题的元凶。本文就记录这一过程，以及适当引申一些关于 JVM 的知识。&lt;/p&gt;&lt;p&gt;解释说明一下，上述中的 SDK 表示存储系统独立封装的取数、查询接口，它屏蔽了 Elasticsearch 自带的接口，并封装成公共组件，提供给各个业务方使用。各个业务方在使用前，需要申请开通 token 验证码，存储系统会根据业务方的使用量分配合适的资源，业务方在调用时需要传入 token 验证。这样做的好处，一是可以监控所有的业务方的取数、查询情况，收集所有的请求日志，统计一些常用的指标，然后反过来指导存储系统的改进，例如根据业务方的调用情况进行资源分配的伸缩、针对常用的数据类型进行索引优化。二是可以保障整个数据库集群的正常运行，由于屏蔽了 Elasticsearch 自带的接口，业务方不能随意操作超大额的数据量，SDK 会做限制，因此不会产生某些不合理的查询、取数请求，从而不对数据库造成巨大的压力。三是限制了一些不需要的查询、取数方式，在保障业务方基本需求的情况下又可以保障数据库集群的稳定，例如多层聚合、日期聚合等操作，这些操作不合理，而且会对数据库集群造成压力【无论数据量大小都可能会出事】。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="JDK" scheme="https://www.playpi.org/tags/JDK/"/>
    
      <category term="内存泄漏" scheme="https://www.playpi.org/tags/memory-leak-chn/"/>
    
      <category term="内存溢出" scheme="https://www.playpi.org/tags/memory-overflow-chn/"/>
    
      <category term="jvm" scheme="https://www.playpi.org/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>青椒炒蛋做法总结</title>
    <link href="https://www.playpi.org/2019033101.html"/>
    <id>https://www.playpi.org/2019033101.html</id>
    <published>2019-03-31T08:40:52.000Z</published>
    <updated>2019-03-31T08:40:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --><p>青椒炒蛋，是一道非常普通的家常菜，基本家家户户都会做。有的家庭喜欢吃辣，放的是稍微辣一点的辣椒，有的家庭不喜欢吃辣，就放菜椒或者甜椒，总之，对于辣椒的选择非常多。对于辣椒的处理方式，有的人喜欢切小块，有的人喜欢斜切小段，还有的人直接剁碎，做法也多种多样。本文记录青椒炒蛋的做法总结，使用的是菜椒【不辣微甜】，由于故意多放了生抽，做出来的口味是咸香的。</p><a id="more"></a><h1 id="食材准备"><a href="# 食材准备" class="headerlink" title="食材准备"></a>食材准备 </h1><p> 以下食材的份量为一大盘，足够 2 人吃，食材非常简单：</p><ul><li>鸡蛋 3 个 </li><li> 青椒 2 棵 </li><li> 大蒜 6 粒 </li><li> 食用盐、生抽酱油 </li></ul><p> 全部的食材 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb59lzf0j229s29sx6p.jpg" alt="全部的食材" title="全部的食材"></p><h1 id="制作过程"><a href="# 制作过程" class="headerlink" title="制作过程"></a> 制作过程 </h1><p> 这是一道快菜，制作过程根据家庭灶的火力大小，2-5 分钟即完成。</p><h2 id="处理食材备用"><a href="# 处理食材备用" class="headerlink" title="处理食材备用"></a>处理食材备用 </h2><p> 青椒洗净去籽切小快，鸡蛋液加少量食用盐搅拌均匀，大蒜切片。</p><p>青椒切块，大蒜切片 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb5ifv55j229s29sb2a.jpg" alt="青椒切块，大蒜切片" title="青椒切块，大蒜切片"></p><p> 鸡蛋液 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb5mnskjj229s29sb29.jpg" alt="鸡蛋液" title="鸡蛋液"></p><h2 id="炒鸡蛋备用"><a href="# 炒鸡蛋备用" class="headerlink" title="炒鸡蛋备用"></a> 炒鸡蛋备用 </h2><p> 锅里加油，要多加一点，鸡蛋液很吸油，烧热后下鸡蛋液，定型后炒散，炒散后盛出备用。由于鸡蛋液里面已经加了食用盐，就不用再加盐调味了。</p><p>鸡蛋液下锅 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb5rk896j229s29s4qq.jpg" alt="鸡蛋液下锅" title="鸡蛋液下锅"></p><p> 定型炒散 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb5x5pt6j229s29skjl.jpg" alt="定型炒散" title="定型炒散"></p><p> 鸡蛋盛出备用 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb62uunrj229s29sqv5.jpg" alt="鸡蛋盛出备用" title="鸡蛋盛出备用"></p><h2 id="炒青椒大蒜"><a href="# 炒青椒大蒜" class="headerlink" title="炒青椒大蒜"></a> 炒青椒大蒜 </h2><p> 锅里留底油，如果炒完鸡蛋后不够再适当加点油，烧热，大蒜片和青椒同时下锅翻炒【注意是同时下锅】，翻炒至青椒 5 成熟，关小火准备加生抽调味。</p><p>青椒大蒜同时下锅 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb6hcvv2j229s29snpe.jpg" alt="青椒大蒜同时下锅" title="青椒大蒜同时下锅"></p><p> 翻炒至青椒 5 成熟 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb6n92i2j229s29snpe.jpg" alt="翻炒至青椒 5 成熟" title="翻炒至青椒 5 成熟"></p><h2 id="加生抽调味后下鸡蛋"><a href="# 加生抽调味后下鸡蛋" class="headerlink" title="加生抽调味后下鸡蛋"></a> 加生抽调味后下鸡蛋 </h2><p> 青椒翻炒至 5 成熟时，关小火，加生抽调味。注意一定要加多一点生抽，那种大的汤勺可以加将近一汤勺，然后开大火翻炒，把青椒炒至 8 成熟，生抽遇到大火热量时会散发独特的香味。</p><p>加生抽炒至青椒 8 成熟 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb72tpblj229s29snpe.jpg" alt="加生抽炒至青椒 8 成熟" title="加生抽炒至青椒 8 成熟"></p><p> 此时倒入前面炒过的鸡蛋，混合翻炒，如果觉得不够味再加一点食用盐，我加的生抽已经够味，不再加食用盐了。</p><p>倒入鸡蛋 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb7dw5nvj229s29se82.jpg" alt="倒入鸡蛋" title="倒入鸡蛋"></p><p> 翻炒均匀 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb7i7j4wj229s29skjm.jpg" alt="翻炒均匀" title="翻炒均匀"></p><h2 id="出锅装盘"><a href="# 出锅装盘" class="headerlink" title="出锅装盘"></a> 出锅装盘 </h2><p> 翻炒均匀后可以出锅装盘了。</p><p>装盘侧视图 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb7odz35j229s29sqv5.jpg" alt="装盘侧视图" title="装盘侧视图"></p><p> 装盘俯视图 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb7s48a3j229s29snpd.jpg" alt="装盘俯视图" title="装盘俯视图"></p><p> 配上剩下的几块红烧肉，美滋滋。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1mb7ww16ej229s29sqv5.jpg" alt="配上剩下的几块红烧肉，美滋滋" title="配上剩下的几块红烧肉，美滋滋"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a>注意事项 </h1><p>1、炒青椒时和大蒜片一起下锅，不需要先下大蒜片爆香，这很关键。</p><p>2、油量，炒鸡蛋的时候一定要多放一点油，才能保持鸡蛋的嫩滑，因为鸡蛋液吸油很厉害。如果油加的少，会导致鸡蛋炒的有点干有点糊，影响口感。</p><p>3、炒青椒的时候为什么要多加一点生抽呢，毕竟会影响这道菜的颜色，一般炒菜都只会在最后调味时加一点点。因为使用青椒来炒鸡蛋，这种青椒是没有什么味道的，那样只会有鸡蛋的香味，显得太单调，而生抽遇到热量会散发出独特的香味，同时生抽里面又有盐分，从而达到了咸香的效果。就如北方有些地方做番茄炒蛋的时候，是做成咸味的，也会加入大量的生抽，味道也非常好，特别是拌面吃，既是菜又能调味。</p><h1 id="致谢"><a href="# 致谢" class="headerlink" title="致谢"></a> 致谢 </h1><p> 感谢微博用户 <strong>@开心的柠檬日记 </strong>，在微博上放了很多做菜的方子，微博主页为：<a href="https://weibo.com/u/2232990523" target="_blank" rel="noopener">开心的柠檬日记的微博</a> 。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;青椒炒蛋，是一道非常普通的家常菜，基本家家户户都会做。有的家庭喜欢吃辣，放的是稍微辣一点的辣椒，有的家庭不喜欢吃辣，就放菜椒或者甜椒，总之，对于辣椒的选择非常多。对于辣椒的处理方式，有的人喜欢切小块，有的人喜欢斜切小段，还有的人直接剁碎，做法也多种多样。本文记录青椒炒蛋的做法总结，使用的是菜椒【不辣微甜】，由于故意多放了生抽，做出来的口味是咸香的。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="青椒炒蛋" scheme="https://www.playpi.org/tags/green-pepper-scrambled-eggs-chn/"/>
    
      <category term="辣椒炒蛋" scheme="https://www.playpi.org/tags/fried-egg-with-chili-chn/"/>
    
  </entry>
  
  <entry>
    <title>参加 Elastic 社区第三次线下活动广州站</title>
    <link href="https://www.playpi.org/2019033001.html"/>
    <id>https://www.playpi.org/2019033001.html</id>
    <published>2019-03-29T16:41:05.000Z</published>
    <updated>2019-04-06T16:41:05.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --><p>在 2019 年 3 月 30 日，我去参加了 Elastic 社区第三次线下活动广州站的分享会，活动简介：<a href="https://meetup.elasticsearch.cn/event/guangzhou/1001.html" target="_blank" rel="noopener">Elastic 社区第三次线下活动广州站 </a> 。看到各位行业顶尖分享者的分享，不能说受益匪浅，至少给我打开了一些思路，拓展了我的知识面，同时我也学到了一些知识，既包括技术方面的，也包括处事方面的。这篇博文就简单记录一下这个过程。</p><a id="more"></a><h1 id="出发"><a href="# 出发" class="headerlink" title="出发"></a> 出发 </h1><p> 先看一下地图指引 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf2ls1z3j214q0u0djy.jpg" alt="地图指引" title="地图指引"></p><p> 到达公交站，上冲南站，天气不错 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf2vj7mlj229s29sb2c.jpg" alt="上冲南站" title="上冲南站"></p><p> 走路路过特斯拉服务站，听说最近交付的特斯拉电动车有很多问题 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf33253ij229s29shdt.jpg" alt="路过特斯拉服务站" title="路过特斯拉服务站"></p><h1 id="到达"><a href="# 到达" class="headerlink" title="到达"></a> 到达 </h1><p> 到达的比较早，因为要帮忙安排桌子凳子，一切准备就绪后，一起吃了个午饭。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf3jejrej229s29s1ky.jpg" alt="吃了个午饭" title="吃了个午饭"></p><p>13:30 开始签到，签到现场 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf3of8qlj229s29sb2a.jpg" alt="签到现场" title="签到现场"></p><p> 我充当了一会儿签到员，坐着的那个是我 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf3sy1ylj20m80cimyt.jpg" alt="坐着的那个是我" title="坐着的那个是我"></p><p> 各种各样的 Elasticsearch 贴纸 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf3ydx4cj229s29s4qq.jpg" alt="各种各样的 Elasticsearch 贴纸" title="各种各样的 Elasticsearch 贴纸"></p><p> 这是一种比较特殊的 Elasticsearch 贴纸 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf427iykj20qo1hcq74.jpg" alt="特殊的 Elasticsearch 贴纸" title="特殊的 Elasticsearch 贴纸"></p><h1 id="静听分享"><a href="# 静听分享" class="headerlink" title="静听分享"></a> 静听分享 </h1><p> 先简单看一下这个分享会的大概流程与分享内容 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf471eb8j21830o9gnw.jpg" alt="分享内容" title="分享内容"></p><h2 id="分享一"><a href="# 分享一" class="headerlink" title="分享一"></a> 分享一 </h2><p>Elasticsearch 在数说全量库的应用实践</p><p> 现场场景一 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf5ceaqtj21kw0w0as5.jpg" alt="场景一" title="场景一"></p><p> 现场场景二 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf58jqs2j20zk0k0ta7.jpg" alt="场景二" title="场景二"></p><p> 现场场景三 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf54mc76j21hc0u0q84.jpg" alt="场景三" title="场景三"></p><h2 id="分享二"><a href="# 分享二" class="headerlink" title="分享二"></a> 分享二 </h2><p>Elasticsearch 在慧算账技术运营中的应用</p><p> 现场场景 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf4yz5k5j20m80ciac7.jpg" alt="现场" title="现场"></p><h2 id="分享三"><a href="# 分享三" class="headerlink" title="分享三"></a> 分享三 </h2><p>Elasticsearch 在大数据可视化分析中的应用</p><p> 现场场景 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf4twfafj20m80cit9r.jpg" alt="现场" title="现场"></p><h2 id="分享四"><a href="# 分享四" class="headerlink" title="分享四"></a> 分享四 </h2><p> 打造云原生的 Elasticsearch 服务 </p><p> 现场场景 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf4p52q6j20m80cit9u.jpg" alt="现场" title="现场"></p><h2 id="分享五"><a href="# 分享五" class="headerlink" title="分享五"></a> 分享五 </h2><p>Elasticsearch 集群在雷达大数据平台的演进</p><p> 现场场景 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf4kjqsjj20m80ciq4f.jpg" alt="现场" title="现场"></p><h2 id="分享者合影留念"><a href="# 分享者合影留念" class="headerlink" title="分享者合影留念"></a> 分享者合影留念 </h2><p> 认真的观众 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf4c5u0oj21400u00x8.jpg" alt="认真的观众" title="认真的观众"></p><p> 分享者合影留念 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1tf4ftxkrj20m80cizlx.jpg" alt="分享者合影留念" title="分享者合影留念"></p><h1 id="我的思考以及学到的东西"><a href="# 我的思考以及学到的东西" class="headerlink" title="我的思考以及学到的东西"></a> 我的思考以及学到的东西 </h1><p>0、虽然有一些分享听不懂，例如腾讯云的 Elasticsearch 云服务，做了什么优化、达到了什么效果，或者是数说雷达的架构演进，这些目前对于我来说都太不切实际，因为还没接触到这么高深的知识，平时也使用不到，所以听起来云里雾里。但是，能从中提取 1-2 个重要知识点也是有用的，例如腾讯云的索引碎片化，导致读写速度严重下降，这与我在工作当中遇到的问题一模一样。再例如数说雷达演进过程中遇到的坑，某个字段没有做 doc_values，导致不支持 aggregation 查询，这与我很久之前遇到的问题一模一样，此时又加深了我的认知。</p><p>1、多版本 Elasticsearch 的兼容解决办法，需要设置拦截器，把请求的不兼容参数部分替换掉，可以使用 SpringBoot 整合，需要注意已知版本的种类。</p><p>2、针对 long 类型字段的聚合【即 aggregation】请求根据自己的业务场景，如果判断为实际上没有必要【例如只是对年份、月份、日做聚合，并不考虑时区、毫秒时间戳的问题】，可以换一种思路，转化为字符串存储，针对字符串做聚合操作效率就高多了。</p><p>3、在现场提问时，有的人是带着自己业务实际遇到的问题来提问探讨的，提问时描述问题已经消耗了将近 10 分钟。接下来如果真的探讨起来，估计没有半个小时一个小时搞不定，这显然是在浪费大家的时间。所以分享者也及时打断了提问，并留下联系方式，分享会后线下接着再讨论。这种做法很得体，虽然不能在现场解答【为了节约大家的时间】，但是会后讨论也是一样，有时候根据实际情况就是需要这样的取舍。</p><p>4、在 Elasticsearch 中，字段类型是可以节约存储空间与请求耗时的，例如 integer、long、short 的合理使用，但是切记存储的目的最终都是为了使用。</p><h1 id="备注"><a href="# 备注" class="headerlink" title="备注"></a> 备注 </h1><p> 如果需要查看分享者的 PPT 文档，可以在 Elastic 社区下载：<a href="https://elasticsearch.cn/slides" target="_blank" rel="noopener">https://elasticsearch.cn/slides</a> 。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在 2019 年 3 月 30 日，我去参加了 Elastic 社区第三次线下活动广州站的分享会，活动简介：&lt;a href=&quot;https://meetup.elasticsearch.cn/event/guangzhou/1001.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Elastic 社区第三次线下活动广州站&lt;/a&gt; 。看到各位行业顶尖分享者的分享，不能说受益匪浅，至少给我打开了一些思路，拓展了我的知识面，同时我也学到了一些知识，既包括技术方面的，也包括处事方面的。这篇博文就简单记录一下这个过程。&lt;/p&gt;
    
    </summary>
    
      <category term="游玩" scheme="https://www.playpi.org/categories/have-for-fun/"/>
    
    
      <category term="Elastic" scheme="https://www.playpi.org/tags/Elastic/"/>
    
      <category term="线下活动" scheme="https://www.playpi.org/tags/offline-activity-chn/"/>
    
      <category term="广州" scheme="https://www.playpi.org/tags/Guangzhou-chn/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg 使用总结</title>
    <link href="https://www.playpi.org/2019032701.html"/>
    <id>https://www.playpi.org/2019032701.html</id>
    <published>2019-03-27T13:28:09.000Z</published>
    <updated>2019-03-27T13:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --><p>FFmpeg 是一款开源的软件，可以进行多种格式的视频、音频编码转换、片段剪辑。它包含了 libavcodec – 这是一个用于多个项目中音频和视频的解码器库，以及 libavformat – 一个音频与视频格式转换库。<strong>FFmpeg</strong> 这个单词中的 <strong>FF</strong> 指的是 <strong>Fast Forward</strong>。FFmpeg 官网：<a href="https://ffmpeg.org" target="_blank" rel="noopener">https://ffmpeg.org</a> ，下载时会跳转到这里：<a href="https://ffmpeg.zeranoe.com/builds" target="_blank" rel="noopener">https://ffmpeg.zeranoe.com/builds</a> ，请选择合适的版本下载使用。本文记录 FFmpeg 的使用方法，基于 Windows X64 平台。</p><a id="more"></a><h1 id="下载安装"><a href="# 下载安装" class="headerlink" title="下载安装"></a>下载安装 </h1><h2 id="下载"><a href="# 下载" class="headerlink" title="下载"></a> 下载 </h2><p> 在 <a href="https://ffmpeg.zeranoe.com/builds" target="_blank" rel="noopener">https://ffmpeg.zeranoe.com/builds</a> 下载页面，选择适合自己操作系统的版本，我这里选择 Windows X64 的 static zip 包，解压后直接使用，无需安装。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3ly1g1ivhlcgh4j21hc0q9dkh.jpg" alt="FFmpeg 下载页面" title="FFmpeg 下载页面"></p><h2 id="解压配置环境变量"><a href="# 解压配置环境变量" class="headerlink" title="解压配置环境变量"></a>解压配置环境变量 </h2><p> 下载到指定的目录【最好放在方便管理的目录，不显得混乱】，直接解压，得到一个文件夹，里面有 bin、doc、presets 这 3 个子文件夹，其中 bin 里面就包含了主程序：ffmpeg、ffplay、ffprobe，这里不涉及安装的概念，程序可以直接使用。</p><p>解压主目录 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3ly1g1ivi9q552j20o00hgt9m.jpg" alt="解压主目录" title="解压主目录"></p><p> 子文件夹 bin<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3ly1g1ividmkdbj20o00hg753.jpg" alt="子文件夹 bin" title="子文件夹 bin"></p><p>为了方便使用这 3 个主程序，需要把 bin 所在目录配置到环境变量 PATH 中【我这里是 D:\Program Files\ffmpeg\bin】，这里就不再赘述，如果不配置，每次使用命令时都要给出完整的目录，我觉得很麻烦。</p><h1 id="使用示例"><a href="# 使用示例" class="headerlink" title="使用示例"></a>使用示例 </h1><p>ffmpeg 的命令行参数的位置会影响执行的结果，例如时间参数，这与我所知道的其它工具不一样，所以参数位置不能乱放。此外，还需要注意涉及到转码的操作会比较耗时，几十分钟的视频不是几分钟能处理完的，和视频的清晰度也有关系，这个要有一定的心理准备。</p><p>1、把 mkv 格式的视频文件转为 mp4 格式的文件，视频使用 <strong>libx264</strong> 编码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 如果没有配置环境变量 PATH, 命令需要指定 D:\Program Files\ffmpeg\bin\ffmpeg</span><br><span class="line">ffmpeg -i imput.mkv -c:v libx264 output.mp4</span><br></pre></td></tr></table></figure><p>2、查看视频文件的流信息，包括视频、音频、字幕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 其中类似 Stream #0:0 格式的内容就是流信息，指定参数时可以直接使用数字编号表示流 </span><br><span class="line">ffmpeg -i input.mkv</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3ly1g1ivijvhopj20l50cpjso.jpg" alt="查看视频文件的流信息" title="查看视频文件的流信息"></p><p>3、mkv 文件剪辑，截取片段，指定音轨。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- -ss 表示开始时间，-to 表示结束时间，</span><br><span class="line">ffmpeg -ss 01:22:08 -to 01:32:16 -accurate_seek -i in.mkv -map 0:v -map 0:a:1 -codec copy -avoid_negative_ts 1 out.mkv</span><br></pre></td></tr></table></figure><p> 其中，<strong>-accurate_seek</strong> 表示画面帧数校准，<strong>-avoid_negative_ts 1</strong> 表示修复结尾可能的空白帧，<strong>-map 0:v</strong> 表示截取所有视频，<strong>-map 0:a:1</strong> 表示截取第 2 道音轨。</p><p>此外，如果把时间参数放在 -i 前面，结果总会多截取 1-2 秒【如上面示例】。但是如果放在后面，截取的视频片段时间准确了，然而开头的音频正常，视频有 20-30 秒的漆黑一片，不知道为啥。</p><p>4、rmvb 文件转为 mp4 文件，涉及到编码转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 视频使用 h264 编码，音频使用 aac 编码 </span><br><span class="line">ffmpeg -i input.rmvb -c:v h264 -c:a aac out.mp4</span><br></pre></td></tr></table></figure><p>这里需要注意，涉及到编码转换的比较消耗 CPU，上面这个命令把我的 CPU 消耗到 100%，动态视频详见微博：<a href="https://weibo.com/3086148515/HmVcnm7Kl" target="_blank" rel="noopener">FFmpeg 视频转码 CPU 飙升到 100%</a> 。其中，留意流输出信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream mapping:</span><br><span class="line">  Stream #0:1 -&gt; #0:0 (rv40 (native) -&gt; h264 (libx264))</span><br><span class="line">  Stream #0:0 -&gt; #0:1 (cook (native) -&gt; aac (native))</span><br></pre></td></tr></table></figure><p>此外，FFmpeg 不支持 rmvb 格式的文件，只能转码为 mp4 的格式再使用，这里的不支持不是指不能处理，而是不能直接输出 rmvb 格式的文件，处理输入是可以的。</p><h1 id="其它"><a href="# 其它" class="headerlink" title="其它"></a>其它</h1><p>1、如果只是为了转换 mkv 文件的格式为 mp4，也可以使用一款软件：<a href="https://www.videohelp.com/software/MkvToMp4" target="_blank" rel="noopener">MkvToMp4</a> 。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;FFmpeg 是一款开源的软件，可以进行多种格式的视频、音频编码转换、片段剪辑。它包含了 libavcodec – 这是一个用于多个项目中音频和视频的解码器库，以及 libavformat – 一个音频与视频格式转换库。&lt;strong&gt;FFmpeg&lt;/strong&gt; 这个单词中的 &lt;strong&gt;FF&lt;/strong&gt; 指的是 &lt;strong&gt;Fast Forward&lt;/strong&gt;。FFmpeg 官网：&lt;a href=&quot;https://ffmpeg.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ffmpeg.org&lt;/a&gt; ，下载时会跳转到这里：&lt;a href=&quot;https://ffmpeg.zeranoe.com/builds&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ffmpeg.zeranoe.com/builds&lt;/a&gt; ，请选择合适的版本下载使用。本文记录 FFmpeg 的使用方法，基于 Windows X64 平台。&lt;/p&gt;
    
    </summary>
    
      <category term="知识改变生活" scheme="https://www.playpi.org/categories/knowledge-for-life/"/>
    
    
      <category term="FFmpeg" scheme="https://www.playpi.org/tags/FFmpeg/"/>
    
      <category term="视频剪辑" scheme="https://www.playpi.org/tags/video-clip-chn/"/>
    
      <category term="音频剪辑" scheme="https://www.playpi.org/tags/audio-clip-chn/"/>
    
      <category term="视频转码" scheme="https://www.playpi.org/tags/video-transcoding-chn/"/>
    
  </entry>
  
  <entry>
    <title>分别 是为了再次相聚</title>
    <link href="https://www.playpi.org/2019032702.html"/>
    <id>https://www.playpi.org/2019032702.html</id>
    <published>2019-03-26T16:45:51.000Z</published>
    <updated>2019-04-14T16:45:51.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --><p>这是我还在大学读书的时候，有一年过年回家，组织了高中同班同学的聚会，其实主要目的就是一起吃个饭，玩半天，交流一下。我还隐隐约约记得当时提前约好了十几个人，然后到了当天早上再确认的时候，只有八个人能来了，刚好凑一桌。那次一别，以后再也没见过，只在微信上聊过，大家天各一方，有的求学做科研，有的成家立业。而如今，当我碰巧再拾起这段文字的时候，只觉得沙流指尖，微风拂面。</p><p>当然，我再也写不出这么稚嫩的、无病呻吟的文字了，因为现在整天在写代码，我的思维也变化了很多。</p><p>最近三年，在工作环境中经历了多次的相聚离别，现在年后又是离职大潮，刚好整理出这篇旧笔记，提醒自己的成长之路。</p><a id="more"></a><h1 id="开篇"><a href="# 开篇" class="headerlink" title="开篇"></a>开篇 </h1><p> 我应该算是一个善感的人，但不多愁。此时努力寻找记忆中的碎片，感受那些我能看到的瞬间，尝试从记忆中寻找值得书写的部分，以作想念。</p><p>每次只要有久违的聚会，之前我都会想象见面时的情景，以及每个人的样子，认为这样能追寻到由于长时间不见面而淡去的亲切感。同时内心也会积聚起来丰富的情感，构思出许多可以表达的文字，藏在心底，待到意兴浓的时候说出来。</p><h1 id="相聚"><a href="# 相聚" class="headerlink" title="相聚"></a>相聚 </h1><p> 我记得那天早晨起的特别早，是假期中最早的一次，可能是内心的激动，亦或是天气转暖，也可能是因为我定了三个闹钟。出发的时候由于出现了三个不在我计划中的意外，导致我的出发时间比我预计的晚了一个小时，这已经使我的内心感到些许急躁。后来在路上没想到会堵车，又耽搁了 20 分钟，望着拥挤的车流，我再也按捺不住急躁的内心，便直接下车走完了最后一段路，到达的时候已经是中午 12 点了。</p><p>在路上有点风，微风拂面，我能感觉到微微颤抖，为自己没有围围巾而感到后悔，这可是冬天，温度只有几摄氏度。可是到了集合地点太阳都出来了，阳光明媚，冬风和煦，的确是个好天气，相当适合聚会，内心的寒冷一扫而空。</p><p>走到集合的地点，那是一个破旧的学校操场，我曾在这里度过一年光阴，扶了扶眼镜，向四周望了望，看到在操场旁的屋檐下，他们正在打桌球。毕竟两年多没见过面了，他们的样子在我脑海中渐渐模糊，此时努力搜寻，看着一张张熟悉又陌生的脸庞，心中情感翻涌，暗暗对着他们的名字，辛福感扑面而来。但准备好的话一句也没有说出口，这就是我的性格，见了面在一起比什么语言都美好，直接加入他们，我想这也是最好的表达。</p><p>快速从脑海中搜索记忆，在我仔细看来，大家仍然是高中的模样，没有怎么变化，还是那么青春，还是那么快乐，没有老练，没有隔阂，脸上洋溢着年少时的单纯感，都像这个年龄应该有的样子。</p><p>我装出很「酷」的样子，至少我是这么认为，可毕竟长时间没有打过桌球了，手生，出杆结果总是不尽人意，我总感觉自己处于尴尬的境地，可是仍然装出不在乎的样子，说几句玩笑话，淡淡一笑，希望没人看到，说到底还是生疏了。</p><p>本应该可以去吃饭了，但大家兴致未尽，在「混乱」的状态下又玩了几十分钟，随着黑色八号球的入袋，结束了应该有的结局，已经过了午饭的时间。说实话，此时我已经饥肠辘辘，但大家看起来都很亢奋，兴奋喜悦的表情洋溢于脸，在说笑中集体寻找吃饭的地点。</p><p>八个年轻人一起走在马路上，蹦蹦跳跳，三两成堆，不时对旁边的人吐露心声，开着不着边际的玩笑，说着没心没肺的笑话。此时我的脑海中浮现出一幅和谐美好的画面，也必将印在我的心底。</p><p>走走停停，说说笑笑，乘坐免费的公交，不多时便到达了新建落成的七彩世界，映入眼帘的是花花绿绿的色彩，心情豁然开朗，已经做好了吃喝的准备。进入大楼入口，乘坐电梯，直奔饮食区域。</p><p>首先寻找最佳的位置，足够容纳八个人入座，围在一起，谈笑风生。我实在是饿坏了，便独自一人去点了一碗面，首先尝尝咸淡。没想到我等了一会儿，他们大部分人都来了，都要吃面，那就点吧。七七八八大家议论了一番，各自点了一碗面。</p><p>等待上面的过程中，几个男生又去点了一些副食，女生去点了饮品，相互搭配，应该足够果腹了。东西上齐后，本想随心所欲，大快朵颐，可是不知怎么的，先前的食欲减小了，不过以我的大饭量还是能消耗很多食物的。</p><p>吃饭的过程就是吃饭的过程。</p><p>吃饱喝足之后，大家聊了一会儿，有人提议打牌，反正闲着没事儿干，打就开打。本来准备去购买纸牌的，没想到王飞的书包里居然带着这玩意儿，看来他那书包里面装着很多现金也是真的了。</p><p>打牌真的是体力活也是脑力活，不仅需要工于计算，还需要相互配合，可是牌不好什么都白搭。在这个过程，我可以说是遭遇了打牌生涯的滑铁卢，无论怎么样打，都是输牌。当然，值得说明的是，输牌并不是因为牌技不好，而是因为牌不好，就算什么都算出来了也打不赢，这不能怪我。</p><p>身为理科生，我清楚地知道这只是概率问题，风水会轮流转，但为了缓解气氛，我也可以承认这可能是人品的问题。况且竟然牌从头到尾一直不好，想想这也是一个小概率事件，我不得不承认可能确实和我的人品有一点关系。</p><p>输输输……</p><p>输了牌，就会有惩罚，惩罚过后，换了一波人继续打。可是万万没想到，我这一门虽然换了人打，牌还是不好，虽然比我打的时候好了那么一点点，仍然是稳输不赢，牌差的简直令人发指。打牌成绩的最顶峰也就是赢了一个而已，很快又变成负数了，真是令人伤悲。</p><h1 id="分别"><a href="# 分别" class="headerlink" title="分别"></a>分别 </h1><p> 不知不觉中，在说说笑笑、打打闹闹的氛围下过去了几个小时，天也已经快黑了，是时候该分别了，各自回家，要不然有些人恐怕赶不上末班车了（十八线小县城过了六点就没车了）。而后大家收拾东西，开始动身，临走时总要合照一张吧。<br>合照一没有我 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g22nqcm23mj22kg1g0qrf.jpg" alt="合照一没有我" title="合照一没有我"></p><p> 合照二没有我 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g22nq6tdiuj22kg1g0e39.jpg" alt="合照二没有我" title="合照二没有我"></p><p> 每一张照片，王飞的脖子和头看起来很奇怪，我没法挑出效果更好的了。第一张解丰的全身没有入镜，当然，这怪我，是我拍的。请看下面零散的几张照片，当时的红米手机拍照效果也就这样了，每张照片的大小只有 800KB 左右。<br>大家闲聊 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g22nqg2uudj22kg1g01gn.jpg" alt="大家闲聊" title="大家闲聊"></p><p> 二位在比划啥 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g22nqk8fcij22kg1g0e5h.jpg" alt="二位在比划啥" title="二位在比划啥"></p><p> 二位正经的样子 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g22nqnctgmj21g02kgav7.jpg" alt="二位正经的样子" title="二位正经的样子"></p><p> 正经人 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g22nrb50u6j22kg1g0qrd.jpg" alt="正经人" title="正经人"></p><p> 这里面有我 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g22nqqosy6j22kg1g0nlw.jpg" alt="这里面有我" title="这里面有我"></p><p> 这是干啥 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g22nreufvtj21g02kgnl7.jpg" alt="这是干啥" title="这是干啥"></p><p> 下了楼，大家一起往车站行走，途中许梦宇有事首先分别，王继雪顺车回家第二个分别。剩下的六人继续走在繁华的街头，沿着热闹的商铺，趁着剩下不多的时间聊天说笑。</p><p>本来是一段很短的路程，我们却走了很长时间，可能大家心里都想着多聊一会儿吧，才故意放慢了脚步。当然，最终这也导致了我错过了回家的末班车。</p><p>到了车站，大家又聊了一会儿，当作告别的寒暄。我不得不乘坐另外一辆车，和李欢一起，只是到达离家还有十多公里的永兴街上，然后让家里的亲人来接。</p><h1 id="结尾"><a href="# 结尾" class="headerlink" title="结尾"></a>结尾 </h1><p>「天下没有不散的宴席」，这句老话大家都知道，可大概只有经历过的人才能理解其中蕴含着的意义吧。时间总是很快，最终的时刻总要分别。</p><p> 分别，是为了再次相聚。</p><p>下一次再相聚会是什么时候呢？</p><p>下一次再相聚大家会变吗？</p><p>静静等待着再次相聚。</p><p>哦，对了，我离开家乡去学校的那天，火车开动的时候，家乡飘起了小雪。后来火车远离家乡的时候，听说雪已经很大了，可惜我没有见到。</p><p>是为记。</p><p>2015 年 02 月 26 日 </p><p> 鹏飞</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;这是我还在大学读书的时候，有一年过年回家，组织了高中同班同学的聚会，其实主要目的就是一起吃个饭，玩半天，交流一下。我还隐隐约约记得当时提前约好了十几个人，然后到了当天早上再确认的时候，只有八个人能来了，刚好凑一桌。那次一别，以后再也没见过，只在微信上聊过，大家天各一方，有的求学做科研，有的成家立业。而如今，当我碰巧再拾起这段文字的时候，只觉得沙流指尖，微风拂面。&lt;/p&gt;&lt;p&gt;当然，我再也写不出这么稚嫩的、无病呻吟的文字了，因为现在整天在写代码，我的思维也变化了很多。&lt;/p&gt;&lt;p&gt;最近三年，在工作环境中经历了多次的相聚离别，现在年后又是离职大潮，刚好整理出这篇旧笔记，提醒自己的成长之路。&lt;/p&gt;
    
    </summary>
    
      <category term="游玩" scheme="https://www.playpi.org/categories/have-for-fun/"/>
    
    
      <category term="聚会" scheme="https://www.playpi.org/tags/get-together-chn/"/>
    
      <category term="利辛一中" scheme="https://www.playpi.org/tags/Lixin-Yizhong-chn/"/>
    
  </entry>
  
  <entry>
    <title>爆炒花甲做法总结</title>
    <link href="https://www.playpi.org/2019032501.html"/>
    <id>https://www.playpi.org/2019032501.html</id>
    <published>2019-03-24T17:02:40.000Z</published>
    <updated>2019-03-24T17:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --><p>爆炒花甲是一道做法简单、快速出菜、可口下饭的家常菜，一般晚上去大排档吃夜宵，基本都会有这道菜。本文记录爆炒花甲的家常做法，以及需要注意的地方。</p><a id="more"></a><h1 id="食材准备"><a href="# 食材准备" class="headerlink" title="食材准备"></a>食材准备 </h1><p> 以下份量为一盘：</p><ul><li>花甲 1.5 斤 - 2 斤，花甲的价格一般在 6-10 块钱之间【广州地区】</li><li>二荆条辣椒 2 个，细长条那种，不是很辣 </li><li> 小米椒 5 个，我用干辣椒和辣椒酱代替了 </li><li> 豆瓣酱、蚝油、食用盐、淀粉 </li><li> 大蒜、香葱，香葱我用青椒代替了 </li></ul><p> 辣椒食材 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1l5ne1e6kj229s29se81.jpg" alt="辣椒食材" title="辣椒食材"></p><p> 辣椒切碎备用 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1l5njohsrj229s29se82.jpg" alt="辣椒切碎备用" title="辣椒切碎备用"></p><p> 准备工作中最重要的就是让花甲吐沙，一般买回来的花甲里面都会有大量的沙子，所以要让花甲把沙子吐出来，这样吃起来才不会硌牙，否则会严重影响口感，没法吃。</p><p>花甲吐沙方法主要有两种：</p><ul><li>方法 1【时间长，简单】：放入清水、食用盐、香油，浸泡一个小时，基本可以把沙吐干净。</li><li>方法 2【时间短，麻烦】：放入锅中，加入清水、料酒、姜片、香油，小火煮热【不要很热，保持不烫手的温度，否则会严重影响肉质】，持续 15 分钟，也可以把沙吐干净。</li></ul><p>我一般选择第一种，花甲买回来之后放在盆里，加入盐、香油等着就行了，可以先去处理其它食材了，不用管，很方便。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1l5oxjyxmj229s29se82.jpg" alt="让花甲吐沙" title="让花甲吐沙"></p><h1 id="制作步骤"><a href="# 制作步骤" class="headerlink" title="制作步骤"></a>制作步骤 </h1><h2 id="花甲焯水"><a href="# 花甲焯水" class="headerlink" title="花甲焯水"></a> 花甲焯水 </h2><p> 花甲吐沙完成之后，捞出进行焯水，焯水之后花甲基本熟了，然后捞出花甲迅速过冷水，过冷水的目的是保持花甲肉的鲜嫩。注意焯水不要太久，否则花甲肉就老了，影响口感。我把花甲焯水的时候还加了姜片和料酒去腥。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1l5pebk8cj229s29s4qq.jpg" alt="花甲焯水" title="花甲焯水"></p><h2 id="爆香锅底"><a href="# 爆香锅底" class="headerlink" title="爆香锅底"></a>爆香锅底 </h2><p> 油烧热，一定要比平时炒菜多放一点油，毕竟是爆炒，加入大蒜、辣椒、姜片，十几秒爆香，我这里省略了姜片，因为焯水的时候用的水里面加了姜片和料酒。大蒜也不加了。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1l5qj41y0j229s29skjm.jpg" alt="爆香锅底" title="爆香锅底"></p><h2 id="豆瓣酱或者蚝油调味"><a href="# 豆瓣酱或者蚝油调味" class="headerlink" title="豆瓣酱或者蚝油调味"></a>豆瓣酱或者蚝油调味 </h2><p> 关小火，加入豆瓣酱，调和味道，我没有豆瓣酱，就用蚝油代替了。</p><h2 id="爆炒花甲"><a href="# 爆炒花甲" class="headerlink" title="爆炒花甲"></a>爆炒花甲 </h2><p> 味道调和好后，加入过冷水的花甲，开大火，爆炒。</p><p>爆炒 3 分钟后关小火调味【时间实际依据灶的火力大小，家用灶一般火不够大，要多炒一会】，加入食用盐【如果豆瓣酱或者生抽够味就不用加盐了】、生抽、辣椒酱，大火翻炒十几秒。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1l5r7ayuaj229s29shdu.jpg" alt="爆炒花甲" title="爆炒花甲"></p><p>我又补了一点辣椒酱 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1l5y5pj3ej229s29sb2a.jpg" alt="补了一点辣椒酱" title="补了一点辣椒酱"></p><p> 最后一步也很关键，使用淀粉液勾芡，目的是让味道均匀包裹在花甲的表面，否则味道都会遗留在锅里，导致花甲味道偏淡。勾芡可以实现真正入味的效果。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1l5rkc386j229s29shdu.jpg" alt="淀粉液勾芡" title="淀粉液勾芡"></p><h2 id="出锅装盘"><a href="# 出锅装盘" class="headerlink" title="出锅装盘"></a>出锅装盘 </h2><p> 如果有香葱的话，出锅前再放一点点香葱，更好看，味道也更好。我这里没放香葱，使用青椒代替了。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1l5s40v2jj229s29su0x.jpg" alt="出锅装盘" title="出锅装盘"></p><h2 id="其它配菜"><a href="# 其它配菜" class="headerlink" title="其它配菜"></a>其它配菜 </h2><p> 顺手做了一道红烧肉，加了香菇和 2 个鸡蛋，有点偏卤肉的口味了。</p><p>红烧肉收汁阶段 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1l5spgpkhj229s29sb2a.jpg" alt="红烧肉收汁阶段" title="红烧肉收汁阶段"></p><p> 红烧肉成品 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1l5su5ddgj229s29sqv5.jpg" alt="红烧肉成品" title="红烧肉成品"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项 </h1><h2 id="花甲吐沙"><a href="# 花甲吐沙" class="headerlink" title="花甲吐沙"></a> 花甲吐沙 </h2><p> 花甲吐沙一定要做好，不可匆匆了事，否则花甲吃起来全部都是沙子就不好了，严重影响口感，另外还要注意在爆炒的时候会有一些花甲壳碎掉，混在花甲肉里面，吃的时候也要注意一下，虽然不是沙子，但是也会硌牙。</p><h2 id="花甲焯水 -1"><a href="# 花甲焯水 -1" class="headerlink" title="花甲焯水"></a>花甲焯水 </h2><p> 花甲焯水，可以适当放一点姜片、料酒，去腥味。当然，如果吐沙的方法采用的是温水慢煮的方式，可以不用再放任何调料了，直接焯水就行了。焯水时要切记水不能太沸腾，或者不要一直放在沸水里面，要适当用漏勺翻一下，否则会导致花甲肉全部脱离花甲壳了，这个和花甲新不新鲜无关，水太沸腾会导致大量的花甲肉脱离花甲壳。</p><h2 id="勾芡"><a href="# 勾芡" class="headerlink" title="勾芡"></a>勾芡 </h2><p> 勾芡，才能保证味道均匀分布在花甲表面，吃起来才有入味的效果，否则调味料大部分都粘在锅的表面了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:58 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;爆炒花甲是一道做法简单、快速出菜、可口下饭的家常菜，一般晚上去大排档吃夜宵，基本都会有这道菜。本文记录爆炒花甲的家常做法，以及需要注意的地方。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="爆炒花甲" scheme="https://www.playpi.org/tags/fried-huajia-hard-chn/"/>
    
      <category term="麻辣花甲" scheme="https://www.playpi.org/tags/spicy-huajia-chn/"/>
    
      <category term="炒花甲" scheme="https://www.playpi.org/tags/fried-huajia-chn/"/>
    
  </entry>
  
  <entry>
    <title>使用 Valine 给 Hexo 博客添加评论系统</title>
    <link href="https://www.playpi.org/2019032001.html"/>
    <id>https://www.playpi.org/2019032001.html</id>
    <published>2019-03-20T12:44:40.000Z</published>
    <updated>2019-03-20T12:44:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --><p>我的博客已经搭建得差不多了，一些配置也固定下来了，最近重点一直在补充博客内容，把以前的笔记都整理出来。然后有一天我就想，好像总感觉少点什么，发现评论这个功能是没有的。以前是为了追求简洁的风格，而且评论这个功能不稳定，主要是评论系统不好选择，很多都关闭了。思前想后，考虑了好几天，最终还是决定先加上评论功能，实验一阵子，看看有没有必要，后续再决定是取消还是继续，反正也就是改一下配置就行了，没有多大工作量。接下来查了一下当前还活着的评论系统的种类，最后选择了 <strong>Valine</strong> 这个评论系统。它不需要登录，无后台管理，非常简洁，比较符合我追求的理念。参考相关内容：<a href="https://github.com/xCss/Valine" target="_blank" rel="noopener">https://github.com/xCss/Valine</a> 、<a href="https://valine.js.org" target="_blank" rel="noopener">https://valine.js.org</a> 、<a href="https://leancloud.cn" target="_blank" rel="noopener">https://leancloud.cn</a> 。</p><a id="more"></a><h1 id="注册帐号创建应用"><a href="# 注册帐号创建应用" class="headerlink" title="注册帐号创建应用"></a>注册帐号创建应用 </h1><blockquote><p>Valine 诞生于 2017 年 8 月 7 日，是一款基于 Leancloud 的快速、简洁且高效的无后端评论系统。</p></blockquote><p> 所以，第一步就需要注册 Leancloud 账号，然后才能申请应用的 appid 和 appkey。注册过程我就不赘述了，和注册普通的账号一样，官网地址：<a href="https://leancloud.cn" target="_blank" rel="noopener">https://leancloud.cn</a> 。接下来重点来了，需要申请免费的应用【有钱的话也可以购买收费的版本】，这里面有一些需要注意的地方，否则最后评论的时候没有效果，会导致 Leancloud 后台接收不到评论数据。</p><p>1、登录 Leancloud 系统，进入系统的控制台，然后创建应用。<br>从主页进入控制台 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d797qim2j21hc0rvq6j.jpg" alt="从主页进入控制台" title="从主页进入控制台"></p><p> 创建应用，我这里已经创建好一个应用了。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d79ng997j21hc0q974s.jpg" alt="创建应用" title="创建应用"></p><p>2、填写、选择应用的参数，这里需要填写应用的名字，选择开发版本【免费版本，限制请求并发数】。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d79uhbrqj21hc0q9q4e.jpg" alt="填写、选择应用的参数" title="填写、选择应用的参数"></p><p>3、创建完成后，进入设置详情页面。<br>点击齿轮，进入设置详情页面。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d79z1cf8j21hc0q9mxq.jpg" alt="进入设置详情页面" title="进入设置详情页面"></p><p>在设置详情页面里面，选择 <strong>设置 -&gt; 应用 Key</strong>，就可以看到应用的 appid 和 appkey，这 2 个字符串要记下来，等一下在 Hexo 里面配置的时候有用。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d7a30cpmj21hc0q9jt5.jpg" alt="查看应用 Key" title="查看应用 Key"></p><p>4、在 <strong>存储 -&gt; 数据 </strong>里面查看默认的 Class 信息，有一些默认的 Class，例如 _User、_File、_Role 等，这些都用不到，而 Hexo 的评论功能需要一个名称为 Comment 的 Class，现在发现没有这个 Class，要不要手动配置一个呢。其实不用担心，经过我的测试 Hexo 会自动生成这个 Class，所以不需要自己手动配置了。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d7agpw2ij21hc0q9gnc.jpg" alt="查看 Class 信息" title="查看 Class 信息"></p><p>5、在 <strong>设置 -&gt; 安全中心 </strong>，把 <strong>文件上传、短信服务、推送服务、实时通信 </strong>这几个服务全部关闭，因为用不到。然后需要特别注意的就是 <strong>Web 安全域名 </strong>这一个选项，里面一定要填写自己站点的域名，并且带上端口号，例如 http 请求的默认端口就是 80，htps 请求的默认端口就是 443。这里如果没有配置好，评论的时候也会失败的。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d7amoctcj21hc0rv76n.jpg" alt="设置 Web 安全域名" title="设置 Web 安全域名"></p><h1 id="配置 -Hexo- 参数"><a href="# 配置 -Hexo- 参数" class="headerlink" title="配置 Hexo 参数"></a>配置 Hexo 参数 </h1><p> 上一步骤已经把 Leancloud 里面的应用申请好了，并且设置了重要的选项，获取到 appid 和 appkey，接下来配置 Hexo 就简单多了。打开 Hexo 主题的配置文件 <strong>_config.yml</strong>，搜索一下 Valine，找到默认配置【这是因为 Hexo 已经自动集成了 Valine 评论系统，不需要安装什么，如果没有请升级 Hexo 版本】。</p><p>默认是关闭的，把配置更改如下图，更为详细内容参考：<a href="https://valine.js.org/configuration.html" target="_blank" rel="noopener">https://valine.js.org/configuration.html</a> 。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d7at81uyj20ku0b0dgq.jpg" alt="Hexo 配置" title="Hexo 配置"></p><p>主要配置的内容如下【重点是 appid、appkey、placeholder，至于验证、邮件提醒就按照自己的需要来配置吧】：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  # 开启 Valine 评论 </span><br><span class="line">  enable: true</span><br><span class="line">  # 设置应用 id 和 key</span><br><span class="line">  appid: CCCJixxxxxxXXXxxxXXXX000-gzGzo000</span><br><span class="line">  appkey: AA1RXXXXXhPXXXX00F0XXXJSq</span><br><span class="line">  # mail notifier , https://github.com/xCss/Valine/wiki</span><br><span class="line">  # 关闭提醒与验证 </span><br><span class="line">  notify: false</span><br><span class="line">  verify: false</span><br><span class="line">  # 文本框占位文字 </span><br><span class="line">  placeholder: 没有问题吗？</span><br><span class="line">  # 需要填写的信息字段 </span><br><span class="line">  meta: [&apos;nick&apos;,&apos;mail&apos;]</span><br><span class="line">  # 默认头像 </span><br><span class="line">  avatar: wavatar</span><br><span class="line">  # 每页显示的评论数 </span><br><span class="line">  pageSize: 10</span><br></pre></td></tr></table></figure><p>这里面我发现一个问题，就是有一些配置项不生效，例如：<strong>meta</strong>、<strong>avatar</strong>，我也不知道是 Hexo 的问题还是 Valine 的问题，我也不懂，就先不管了，因为不影响评论这个功能。</p><p>另外还有一个就是评论的时候总会强制检验邮箱和 url 的规范性，如果没填或者填的不规范就弹框提示，我不知道怎么取消，只好在在 GitHub 提了一个 Issue，详见：<a href="https://github.com/xCss/Valine/issues/168" target="_blank" rel="noopener">https://github.com/xCss/Valine/issues/168</a> ，但是作者一直没回。等了几天，作者回复了，说是我的 Valine 版本太低，让我升级。我看了本地的 Valine 的版本，已经是 v1.3.5 了，然后我就怀疑可能是 Hexo 的版本问题，但是我自己做了很多自定义的配置，改了很多 css、js 文件，不能随便升级，等以后有时间做一个大版本的升级，再好好整理。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d7da6215j20u30fsdgb.jpg" alt="强制检验邮箱和 url 的规范性" title="强制检验邮箱和 url 的规范性"></p><p>那怎么才能让博客文章的底部显示评论对话框呢，其实很简单，什么都不用做，Hexo 默认是给每个页面都开启评论的【前提是在 Hexo 的配置文件中开启了一种评论系统】。它背后的配置就是 Markdown 文件的 comments 属性，默认设置是 true，所以不用配置了，如果非要配置也可以，如下图。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d7dge614j20e408c0sy.jpg" alt="配置底部显示评论对话框" title="配置底部显示评论对话框"></p><p>此外，还需要注意，如果博客还有除正文内容之外的页面存在，例如关于、分类、标签，要把他们的 Markdown 文件的 comments 属性设置为 false，否则这些页面在展示的时候也会有评论的功能出现，总不能让别人随便评论吧。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d7djunr3j20no03iq2r.jpg" alt="取消一些不该有评论的页面" title="取消一些不该有评论的页面"></p><h1 id="测试效果"><a href="# 测试效果" class="headerlink" title="测试效果"></a>测试效果 </h1><p> 打开任意一篇博客文章，可以看到底部已经有评论的文本框了。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d7e6uw4mj20uk0o2q3s.jpg" alt="查看文章的评论文本框" title="查看文章的评论文本框"></p><p>试着填写内容，评论一下，可以看到评论列表的内容。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d7e3f5njj20ta0q3750.jpg" alt="文章的评论列表" title="文章的评论列表"></p><p>好了，此时可以再回到 Leancloud 系统，看一下评论数据吧。直接在 <strong>存储 -&gt; 数据 -&gt;Comment</strong> 里面，可以看到已经有评论数据了。由于 Valine 是无后端的评论系统，所以数据直接被存储到了 Leancloud 系统的数据库表里面，看看就行了，不方便管理。如果评论数据很多，为了更方便管理评论数据，能收到更友好的邮件通知提醒，可以使用 Valine-Admin 来实现，我暂时先不用。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d7dzjwhgj21hc0q9jt1.jpg" alt="Leancloud 系统的评论数据" title="Leancloud 系统的评论数据"></p><p>经过几天的测试，可以看到应用的请求量统计信息。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1d7dvlarqj21hc0rwt9f.jpg" alt="Leancloud 系统的应用请求量" title="Leancloud 系统的应用请求量"></p><h1 id="附加 -Valine-Admin- 进行评论数据管理"><a href="# 附加 -Valine-Admin- 进行评论数据管理" class="headerlink" title="附加 Valine-Admin 进行评论数据管理"></a>附加 Valine-Admin 进行评论数据管理 </h1><p> 这个插件我现在先不使用，因为还不知道评论数据会怎么样呢，等以后如果确实有需要再考虑增加，参考项目：<a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">https://github.com/zhaojun1998/Valine-Admin</a> 。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;我的博客已经搭建得差不多了，一些配置也固定下来了，最近重点一直在补充博客内容，把以前的笔记都整理出来。然后有一天我就想，好像总感觉少点什么，发现评论这个功能是没有的。以前是为了追求简洁的风格，而且评论这个功能不稳定，主要是评论系统不好选择，很多都关闭了。思前想后，考虑了好几天，最终还是决定先加上评论功能，实验一阵子，看看有没有必要，后续再决定是取消还是继续，反正也就是改一下配置就行了，没有多大工作量。接下来查了一下当前还活着的评论系统的种类，最后选择了 &lt;strong&gt;Valine&lt;/strong&gt; 这个评论系统。它不需要登录，无后台管理，非常简洁，比较符合我追求的理念。参考相关内容：&lt;a href=&quot;https://github.com/xCss/Valine&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xCss/Valine&lt;/a&gt; 、&lt;a href=&quot;https://valine.js.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://valine.js.org&lt;/a&gt; 、&lt;a href=&quot;https://leancloud.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leancloud.cn&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://www.playpi.org/categories/building/"/>
    
    
      <category term="Hexo" scheme="https://www.playpi.org/tags/Hexo/"/>
    
      <category term="Valine" scheme="https://www.playpi.org/tags/Valine/"/>
    
      <category term="评论系统" scheme="https://www.playpi.org/tags/comment-system-chn/"/>
    
  </entry>
  
  <entry>
    <title>Git 客户端设置 Windows 下的字符编码</title>
    <link href="https://www.playpi.org/2019031901.html"/>
    <id>https://www.playpi.org/2019031901.html</id>
    <published>2019-03-19T15:22:16.000Z</published>
    <updated>2019-03-19T15:22:16.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --><p>在 Linux 以及大多数托管网站上，默认的字符编码均是 UTF-8，而 Windows 系统默认编码不是 UTF-8，一般是 GBK。如果在 Windows 平台使用 Git 客户端，不设置 Git 字符编码为 UTF-8，Git 客户端在处理中文内容时会出现乱码现象，很是烦人。但是，如果能正确设置字符编码，则可以有效解决处理中文和中文显示的问题。大多数技术从业者应该都遇到过各种各样的编码问题，后来渐渐习惯了使用英文，尽量避免中文，但是也有一些场景是必须使用中文的。本文就记录解决 Git 中文处理和中文显示的问题的过程，系统环境基于 Windows7 X64，Git 基于 v2.18.0。</p><a id="more"></a><h1 id="乱码现象"><a href="# 乱码现象" class="headerlink" title="乱码现象"></a>乱码现象 </h1><p>Git 是一款非常好用的分布式版本控制系统，为了更好地使用它，一般都需要 Git 客户端的配合，下载使用参考：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a> 。</p><p> 在 Windows 平台使用 Git 客户端的过程中，有一个问题你一定逃不掉，那就是乱码问题。这是因为 Windows 系统的编码是 GBK，而 Git 客户端的编码是 UTF-8，当两种不同的编码相遇，必然有一方会乱码。如果设置 Git 客户端的编码为 GBK，那么在使用 Git 客户端处理系统文件的时候可以正常显示，但是处理 Git 版本控制内容的时候，就会乱码，无法支持中文。如果反过来呢，把 Git 客户端的编码设置为 UTF-8，那么处理版本控制内容就可以有效支持中文，但是处理系统文件的时候又会乱码。</p><p>Git 客户端设置 UTF-8 编码，处理系统文件显示乱码 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g17blzgl2zj20l50cpjt9.jpg" alt="ls 命令中文乱码" title="ls 命令中文乱码"></p><h1 id="解决方式"><a href="# 解决方式" class="headerlink" title="解决方式"></a> 解决方式 </h1><p> 这样看起来似乎没有解决方法，其实不是的，还是有很好的解决方法的。我这里为了完全支持版本管理系统，版本管理优先，肯定要统一设置为 UTF-8 编码，然后通过 Git 客户端的编码自动转换来支持系统的 GBK 编码。</p><p>这里先提前说明，在使用 Git 客户端的时候，Git 的安装目录【一般默认是 C:\Program Files\Git】，也就是 Git 的根目录。在使用 <strong>ls</strong> 等命令处理文件时，如果携带了 <strong>/</strong> 字符，其实就表示从 Git 的安装目录开始。例如在里面寻找 etc 目录，如果是使用 Git Bash 打开的，可以直接使用根目录的方式，<strong>cd /etc/</strong>。再例如 <strong>vi /etc/git-completion.bash</strong> 不是表示从系统的根目录开始寻找文件【Windows 系统也没有根目录的概念】，而是表示从 Git 的安装目录开始寻找文件。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g17bn7wtv0j20nd0dumyg.jpg" alt="Git 安装目录" title="Git 安装目录"></p><h2 id="设置 -Git- 客户端"><a href="# 设置 -Git- 客户端" class="headerlink" title="设置 Git 客户端"></a>设置 Git 客户端 </h2><p> 打开 Git 客户端的主页面，右键打开菜单栏【或者点击窗口的左上角也可以打开】，选择 <strong>Options</strong> 选项。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g17bmpt7mnj20l50cp0tw.jpg" alt="Options 选项" title="Options 选项"></p><p>接着选择 <strong>Text</strong> 参数配置，把编码方式由 GBK 改为 UTF-8【locale 也要设置为 zh_CN】。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g17bnna4xyj20l50cpacj.jpg" alt="Text 参数配置" title="Text 参数配置"></p><p>设置完成后，一定会导致一个现象，那就是使用 <strong>ls</strong> 查看系统文件时，带有中文的目录和带有中文的文件，一定是乱码的，根本看不清楚显示的是什么。不过不用担心，后面会通过设置让它恢复正常的。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g17blzgl2zj20l50cpjt9.jpg" alt="ls 命令中文乱码" title="ls 命令中文乱码"></p><p>接下来要解决的是显示的问题，目的是保证 Windows 的 GBK 编码可以在 Git 客户端正常显示。由于 Git 客户端被设置为了 UTF-8 编码，使用 <strong>ls</strong> 命令查看目录文件详情的时候，一定是乱码的，什么也看不出来【数字和英文不受影响】。那就需要设置 <strong>ls</strong> 命令的参数，让它按照 Git 客户端的编码来显示，不支持的字符也要显示，这样再使用 <strong>ls</strong> 命令的时候，就会自动把 GBK 编码转为 UTF-8 编码，那么带有中文的目录、带有中文的文件都能正常显示了。</p><p>最简单的做法，就是需要指定 <strong>ls</strong> 命令的附加参数【–show-control-chars】，为了方便，直接更改配置文件 <strong>/etc/git-completion.bash</strong> 【没有的话新建一个既可】，在行尾增加配置项 <strong>alias ls=”ls –show-control-chars –color”</strong> 。其实就是通过新建别名这个技巧把 <strong>ls</strong> 命令的含义扩展了，让它可以根据 Git 客户端的编码转换系统的编码【在这里就是把 GBK 转为 UTF-8】。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/git-completion.bash</span><br><span class="line">alias ls=&quot;ls --show-control-chars --color&quot;</span><br></pre></td></tr></table></figure><p>更改完成后，可以看到能正常显示系统中的带有中文名称的文件了。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g17bo2mcrej20l50cpq4y.jpg" alt="ls 可以正常显示中文" title="ls 可以正常显示中文"></p><p>但是还要注意一点，如果使用 Git 客户端的 Bash 处理其它命令，一定会乱码的，因为不像 <strong>ls</strong> 那样做了编码转换。以下 2 例【分别时使用 elasticsearch、java 命令】：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g185ktkbutj20l50cp0ul.jpg" alt="elasticsearch 命令乱码" title="elasticsearch 命令乱码"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g185l2lrrhj20l50ghmz2.jpg" alt="java 命令乱码" title="java 命令乱码"></p><p>那这个现象有没有办法解决呢，网上大多数解决办法都是说把 Git 客户端的编码设置为和 Windows 系统一样，一般设置为 GBK，这显然是又倒退回去了【为了满足 Git 一定要设置为 UTF-8】。其实唯一的解决办法就是从命令的参数下手，把原生的命令利用别名机制给加上编码有关的参数，和修改 <strong>ls</strong> 命令的做法一致。以下供参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 在文件最后追加，不要修改文件原有的内容 </span><br><span class="line">vi /etc/bash.bashrc</span><br><span class="line">alias javac=&quot;javac -J-Dfile.encoding=UTF-8&quot;</span><br><span class="line">alias java=&quot;java -Dfile.encoding=UTF-8&quot;</span><br></pre></td></tr></table></figure><h2 id="设置 -Git"><a href="# 设置 -Git" class="headerlink" title="设置 Git"></a>设置 Git</h2><p>接下来就是设置 Git 进行版本控制时使用的编码方式，例如提交信息时支持输入中文日志、输出 log 可以正常显示中文。</p><p>设置 Git 有两种方式，一种是通过更改配置文件，另一种是通过 Git 自带的命令来配置参数。为了显得没有手动去破坏 Git 的原有配置文件，我就使用 Git 自带的命令来配置编码。当然，通过更改配置文件的方式也会一同描述出来。</p><p>1、通过命令行把 Git 的各种编码都设置为 UTF-8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false          # 显示 status 编码 </span><br><span class="line">git config --global gui.encoding utf-8            # 图形界面编码 </span><br><span class="line">git config --global i18n.commit.encoding utf-8    # 处理提交信息编码 </span><br><span class="line">git config --global i18n.logoutputencoding utf-8  # 输出 log 编码 </span><br><span class="line">export LESSCHARSET=utf-8                          # 因为 git log 默认使用 less 分页，所以需要 bash 对 less 命令处理时使用 utf-8 编码 </span><br></pre></td></tr></table></figure><p>2、如果通过配置文件的方式来更改，则需要编辑配置文件 <strong>/etc/gitconfig</strong> 【没有则新建一个】，在里面设置以下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">        quotepath = false </span><br><span class="line">[gui]</span><br><span class="line">        encoding = utf-8 </span><br><span class="line">[i18n]</span><br><span class="line">        commitencoding = utf-8 </span><br><span class="line">        logoutputencoding = utf-8</span><br></pre></td></tr></table></figure><p>另外还需要在配置文件 <strong>/etc/profile</strong> 中新增 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure><p>3、特殊说明</p><p><strong>gui.encoding = utf-8</strong> 是为了解决 git gui 和 gitk 中的中文乱码问题，如果发现代码中的注释显示乱码，可以在所属项目的根目录中 <strong>.git/config</strong> 文件中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[gui]</span><br><span class="line">        encoding = utf-8</span><br></pre></td></tr></table></figure><p><strong>i18n.commitencoding = utf-8</strong> 是为了设置 commit log 提交时使用 UTF-8 编码。<br><strong>i18n.logoutputencoding = utf-8</strong> 是为了保证在 <strong>git log</strong> 时使用 UTF-8 编码。<br><strong>export LESSCHARSET=utf-8</strong> 是为了保证 <strong>git log</strong> 翻页时使用 UTF-8 编码，这样就可以正常显示中文了【配合前面的 <strong>i18n.logoutputencoding</strong> 设置】。</p><h2 id="验证"><a href="# 验证" class="headerlink" title="验证"></a> 验证 </h2><p>add 执行的时候 Git 输出的日志都是中文显示的，特别是带有中文名称的文件。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g17bv0ph2yj20l50f20uh.jpg" alt="add 命令输出中文" title="add 命令输出中文"></p><p> 验证提交时填写日志信息，可以直接填写中文日志，另外 Git 的输出日志也是以中文来显示的，可以看到哪些文件变更了。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g17boorhqyj20l50cpgn8.jpg" alt="验证提交时填写中文日志" title="验证提交时填写中文日志"></p><p>验证使用 <strong>git log</strong> 查看历史日志时正常显示中文内容 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g17bosnlsnj20l50cp0tt.jpg" alt="查看历史日志时正常显示中文内容 1" title="查看历史日志时正常显示中文内容 1"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g17box3cduj20l50cp3zx.jpg" alt="查看历史日志时正常显示中文内容 2" title="查看历史日志时正常显示中文内容 2"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项</h1><p>1、此外，Cygwin 在 Windows 平台上也有同样的问题，设置方式也是类似的。当然，如果只是查看目录文件，使用基本的命令，请尽量脱离带有中文的目录和带有中文的文件，避免踩坑，这样还可以把编码直接设置为 GBK 了，但是遇到特殊的情况还是脱离不了 UTF-8 编码。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在 Linux 以及大多数托管网站上，默认的字符编码均是 UTF-8，而 Windows 系统默认编码不是 UTF-8，一般是 GBK。如果在 Windows 平台使用 Git 客户端，不设置 Git 字符编码为 UTF-8，Git 客户端在处理中文内容时会出现乱码现象，很是烦人。但是，如果能正确设置字符编码，则可以有效解决处理中文和中文显示的问题。大多数技术从业者应该都遇到过各种各样的编码问题，后来渐渐习惯了使用英文，尽量避免中文，但是也有一些场景是必须使用中文的。本文就记录解决 Git 中文处理和中文显示的问题的过程，系统环境基于 Windows7 X64，Git 基于 v2.18.0。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Git" scheme="https://www.playpi.org/tags/Git/"/>
    
      <category term="Windows" scheme="https://www.playpi.org/tags/Windows/"/>
    
      <category term="中文乱码" scheme="https://www.playpi.org/tags/chinese-garbled-chn/"/>
    
      <category term="gbk" scheme="https://www.playpi.org/tags/gbk/"/>
    
      <category term="utf-8" scheme="https://www.playpi.org/tags/utf-8/"/>
    
  </entry>
  
  <entry>
    <title>麻婆豆腐做法总结</title>
    <link href="https://www.playpi.org/2019031601.html"/>
    <id>https://www.playpi.org/2019031601.html</id>
    <published>2019-03-16T13:07:13.000Z</published>
    <updated>2019-03-16T13:07:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --><p>麻婆豆腐是一道川菜，口味特色就是麻、辣、鲜，而且非常下饭。我常听说正宗的麻婆豆腐要用郫县豆瓣酱【回锅肉也是这样】，才能做出来正宗的味道，但是我身边没有那么多材料，只能做一道简单版的麻婆豆腐。本文就记录麻婆豆腐的做法总结。</p><a id="more"></a><h1 id="食材准备"><a href="# 食材准备" class="headerlink" title="食材准备"></a>食材准备 </h1><p> 食材就很简单了，以下的量为一盘：</p><ul><li>嫩豆腐一块，一般 2 块钱左右 </li><li> 瘦肉 50 克，剁成肉沫 </li><li> 豆瓣酱，我没有豆瓣酱就用一种混合调味酱【辣椒酱、豆瓣酱、胡椒粉】替代了 </li><li> 辣椒粉，或者辣椒酱 </li><li> 青花椒，最好用青花椒，才够麻的味道【买的散装青花椒里面会有一些其它植物的种子，要细心挑拣出去】</li></ul><p>一块嫩豆腐 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mdpgmo7j229s29snpd.jpg" alt="一块嫩豆腐" title="一块嫩豆腐"></p><p> 青花椒 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15me1xf07j229s29snpd.jpg" alt="青花椒" title="青花椒"></p><h1 id="制作步骤"><a href="# 制作步骤" class="headerlink" title="制作步骤"></a> 制作步骤 </h1><h2 id="初步处理食材"><a href="# 初步处理食材" class="headerlink" title="初步处理食材"></a> 初步处理食材 </h2><p> 豆腐切小块，稍微焯水，备用。如果豆腐质量比较好的话，可以一整块冲一下水就行，不用再焯水了。我买的这个豆腐有点碱的味道【类似魔芋一样】，所以稍微焯一下水为好。焯水时不能用大火，否则豆腐会碎掉的，也可以在焯水时稍微放一点点盐进去。</p><p>豆腐切小块 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15meleoz3j229s29skjl.jpg" alt="豆腐切小块" title="豆腐切小块"></p><p> 豆腐简单焯水 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15meu18t2j229s29s4qq.jpg" alt="豆腐简单焯水" title="豆腐简单焯水"></p><p> 瘦肉剁成肉沫，稍微腌制一下，备用。我为了保持肉沫的鲜嫩，还裹了一层淀粉液。<br>瘦肉剁成肉沫 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mf2x2shj229s29shdu.jpg" alt="瘦肉剁成肉沫" title="瘦肉剁成肉沫"></p><p> 肉沫腌制 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mf7k4lij229s29sb29.jpg" alt="肉沫腌制" title="肉沫腌制"></p><p> 肉沫裹淀粉液 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mfc810oj229s29s7wh.jpg" alt="肉沫裹淀粉液" title="肉沫裹淀粉液"></p><h2 id="炒肉沫"><a href="# 炒肉沫" class="headerlink" title="炒肉沫"></a> 炒肉沫 </h2><p> 锅里放油烧热，稍微多放一点油，然后倒入肉沫翻炒，基本 30 秒就可以了。<br>肉沫下锅 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mgbgss2j229s29s7wi.jpg" alt="肉沫下锅" title="肉沫下锅"></p><p> 肉沫翻炒 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mgghk4kj229s29s7wi.jpg" alt="肉沫翻炒" title="肉沫翻炒"></p><h2 id="炒豆腐"><a href="# 炒豆腐" class="headerlink" title="炒豆腐"></a> 炒豆腐 </h2><p> 一般的做法应该是接着放豆瓣酱，炒出红油，然后加青花椒、辣椒粉，加水煮了一段时间后，再下豆腐。但是我就不搞这么复杂的过程了，直接炒一下豆腐，把豆腐和肉沫混合在一起。<br>豆腐下锅炒 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mh0jf5jj229s29sx6p.jpg" alt="豆腐下锅炒" title="豆腐下锅炒"></p><p> 豆腐肉沫混合 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mh4vb6jj229s29s1ky.jpg" alt="豆腐肉沫混合" title="豆腐肉沫混合"></p><p> 加混合调味酱、辣椒酱、调味料、青花椒 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mhb1f5bj229s29se82.jpg" alt="加酱料" title="加酱料"></p><h2 id="加水开煮"><a href="# 加水开煮" class="headerlink" title="加水开煮"></a> 加水开煮 </h2><p> 因为我的豆腐已经焯水了，所以很容易就熟了，接着再加热水煮开，转为小火再煮 5 分钟就行了。切记别加太多热水，否则变汤了，我这个加的有点多，要多煮一会儿水才能蒸发。<br>加热水，刚刚淹没豆腐 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mi8u826j229s29s1ky.jpg" alt="加热水，刚刚淹没豆腐" title="加热水，刚刚淹没豆腐"></p><p> 煮开后转为小火 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mignd6yj229s29sb2a.jpg" alt="煮开后转为小火" title="煮开后转为小火"></p><p> 小火慢煮 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mindngjj229s29sb2a.jpg" alt="小火慢煮" title="小火慢煮"></p><h2 id="收汁出锅装盘"><a href="# 收汁出锅装盘" class="headerlink" title="收汁出锅装盘"></a> 收汁出锅装盘 </h2><p> 煮了 5 分钟就可以准备收汁了，接着还要进行勾芡，我使用淀粉液进行勾芡。勾芡完成稍微再煮 30 秒就可以关火，出锅装盘。</p><p>收汁 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mirmvljj229s29s4qq.jpg" alt="收汁" title="收汁"></p><p> 调淀粉液，少量淀粉加水 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mixp0uzj229s29shdt.jpg" alt="调淀粉液，少量淀粉加水" title="调淀粉液，少量淀粉加水"></p><p> 调淀粉液成品 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mj2h97cj229s29sqv5.jpg" alt="调淀粉液成品" title="调淀粉液成品"></p><p> 勾芡完成，可以看到有点浓稠 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mnev10jj229s29se82.jpg" alt="勾芡完成，可以看到有点浓稠" title="勾芡完成，可以看到有点浓稠"></p><p> 出锅装盘 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mjau8njj229s29skjm.jpg" alt="出锅装盘" title="出锅装盘"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项</h1><p>1、为了保证肉沫的鲜嫩，千万不要炒太久，下锅后稍微炒一下就行了，因为后续还要加水煮很久呢。我这里没有采用炒豆瓣酱出红油的做法，所以就用淀粉液裹了一下，肉沫炒熟后直接下豆腐。</p><p>2、切豆腐时豆腐一般都会粘在刀上，所以有一个技巧就是从手心往手指的方向反着切，切完一刀就可以用手压住，这样豆腐就不会粘在刀上了。参考如下图【我是左手持刀，右手压豆腐】：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g15mjlrsb8j229s29s4qq.jpg" alt="反向切豆腐" title="反向切豆腐"></p><p>3、收汁时最好使用淀粉液勾芡一下，这样才能保证调味料都裹在豆腐上，达到入味的效果。否则味道可能都遗落在汤汁里面了，导致豆腐没有什么味道。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;麻婆豆腐是一道川菜，口味特色就是麻、辣、鲜，而且非常下饭。我常听说正宗的麻婆豆腐要用郫县豆瓣酱【回锅肉也是这样】，才能做出来正宗的味道，但是我身边没有那么多材料，只能做一道简单版的麻婆豆腐。本文就记录麻婆豆腐的做法总结。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="麻婆豆腐" scheme="https://www.playpi.org/tags/Mapo-tofu-chn/"/>
    
      <category term="豆腐" scheme="https://www.playpi.org/tags/tofu-chn/"/>
    
      <category term="麻辣豆腐" scheme="https://www.playpi.org/tags/spicy-tofu-chn/"/>
    
  </entry>
  
  <entry>
    <title>青椒肉丝做法总结</title>
    <link href="https://www.playpi.org/2019031101.html"/>
    <id>https://www.playpi.org/2019031101.html</id>
    <published>2019-03-10T18:38:01.000Z</published>
    <updated>2019-03-12T14:38:01.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --><p>青椒肉丝，本来是一道做法非常简单的菜肴，但是想做好却不容易，为什么呢？一是因为肉丝和青椒丝很多人切不出来，可能切出来的是条状的，那就做不出来青椒肉丝；二是因为腌制肉的时候没有进行裹淀粉的步骤【有条件裹鸡蛋清当然更好】，导致肉刚下锅就老，炒不出鲜嫩滑爽的效果；三是因为炒的时候油量和油温没有控制好，导致肉炒老了，不好吃。本文则记录青椒肉丝的炒制过程以及需要注意的地方，请观察一下我是怎么做出来一道家常的青椒肉丝的。</p><a id="more"></a><h1 id="食材准备"><a href="# 食材准备" class="headerlink" title="食材准备"></a>食材准备 </h1><p> 食材就很简单了，以下是一盘的份量：</p><ul><li>纯瘦肉 200 克 </li><li> 大青椒一棵 </li><li> 大红椒一棵【为了好看，搭配一棵红椒】</li><li>淀粉少量、花生油少量 </li></ul><h1 id="制作步骤"><a href="# 制作步骤" class="headerlink" title="制作步骤"></a> 制作步骤 </h1><h2 id="食材处理"><a href="# 食材处理" class="headerlink" title="食材处理"></a> 食材处理 </h2><p> 主要就是切肉丝，切青椒丝，腌制肉丝，注意肉丝要切细一点。切肉丝的时候先把肉切片【一只手掌按着肉，刀躺着从手掌下划过】，最后用肉片去切肉丝，可以保证肉丝的质量。腌制肉丝的时候除了调味料，还需要加一点点水和淀粉【淀粉不要多放，否则菜炒出来会偏甜】，用手抓均匀，让淀粉液充分裹在肉丝表面【有条件就用鸡蛋清替代更好，但是肉丝少的时候就没必要了，用不完一个鸡蛋】。最后还要加一点点花生油，防止肉丝下锅的时候粘锅。肉丝腌制 10 分钟。</p><p>青红椒切丝 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g10fw75eifj229s29shdt.jpg" alt="青红椒切丝" title="青红椒切丝"></p><p> 腌制肉丝加调料 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g10funjj97j229s29se81.jpg" alt="腌制肉丝加调料" title="腌制肉丝加调料"></p><p> 腌制肉丝加水和淀粉 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g10fvj4muxj229s29s1ky.jpg" alt="腌制肉丝加水和淀粉" title="腌制肉丝加水和淀粉"></p><p> 抓均匀后放一点花生油 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g10fvxca54j229s29sx6p.jpg" alt="抓均匀后放一点花生油" title="抓均匀后放一点花生油"></p><h2 id="肉丝炒制，盛出备用"><a href="# 肉丝炒制，盛出备用" class="headerlink" title="肉丝炒制，盛出备用"></a> 肉丝炒制，盛出备用 </h2><p> 锅里加油，多加一点，先烧热，然后关火让油冷却一下。冷却到 3 成热再倒入肉丝，然后开大火开始翻炒，基本 30 秒就可以把肉丝炒熟了【取决于肉丝切得好不好】。然后盛出备用。</p><p>油加热后冷却 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g10fwionwoj229s29shdu.jpg" alt="油加热后冷却" title="油加热后冷却"></p><p> 倒入腌制好的肉丝 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g10fwrw22wj229s29s7wi.jpg" alt="倒入腌制好的肉丝" title="倒入腌制好的肉丝"></p><p> 不停地翻炒 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g10fx1x7c8j229s29sb2a.jpg" alt="不停地翻炒" title="不停地翻炒"></p><p> 盛出备用 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g10fxc44nlj229s29s4qq.jpg" alt="盛出备用" title="盛出备用"></p><h2 id="青椒炒制，混合翻炒"><a href="# 青椒炒制，混合翻炒" class="headerlink" title="青椒炒制，混合翻炒"></a> 青椒炒制，混合翻炒 </h2><p> 由于一开始加了偏多的油，此时不需要再放油，或者根据实际情况放一点点也行。油烧热后放入青红椒丝，大火快速翻炒，基本 1 分钟以内就可以把青红椒丝炒至断生。关小火，放入备用的肉丝，翻炒几下，开始调味，放入食用盐、鸡精、耗油，接着大火快速翻炒几下，放几滴香醋，准备出锅。</p><p>放入青红椒丝翻炒 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g10fxn3q87j229s29s1ky.jpg" alt="放入青红椒丝翻炒" title="放入青红椒丝翻炒"></p><p> 翻炒至断生【为了拍图青红椒丝炒太熟了】<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g10fxw4b92j229s29s4qq.jpg" alt="翻炒至断生" title="翻炒至断生"></p><p>放入肉丝调味翻炒 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g10fyjb9j8j229s29s1ky.jpg" alt="放入肉丝调味翻炒" title="放入肉丝调味翻炒"></p><h2 id="出锅装盘"><a href="# 出锅装盘" class="headerlink" title="出锅装盘"></a> 出锅装盘 </h2><p> 盛出装盘 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g10fyubmo8j229s29s7wi.jpg" alt="盛出装盘" title="盛出装盘"></p><p> 还配了一道麻婆豆腐 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g10fyyqu9wj229s29se82.jpg" alt="麻婆豆腐" title="麻婆豆腐"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项</h1><p>1、买肉一定要买纯瘦肉，最好不要带一丝肉筋，并且形状要规整，薄厚均匀，这样才容易切片进而切肉丝。买肉的时候肯定不需要店方帮忙切肉了，因为他们不可能有时间给你切肉丝出来。此外一定要保证刀比较锋利，锋利的刀更容易处理，如果刀用了很久都没磨过，恰好找这个机会磨磨刀。</p><p>2、腌制肉丝的时候可以适当加一点水【用来溶解淀粉】，然后加一点淀粉，抓均匀，让淀粉充分裹上肉丝。当然，有条件的直接使用鸡蛋清最好，不需要水和淀粉了，味道还更香。抓均匀后再加一点花生油，防止下锅的时候粘锅。</p><p>3、肉丝下锅之前要确保油温不高，如果油温过高要开小火让油冷却一下，否则裹着淀粉的肉丝一下锅表面就会糊掉。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;青椒肉丝，本来是一道做法非常简单的菜肴，但是想做好却不容易，为什么呢？一是因为肉丝和青椒丝很多人切不出来，可能切出来的是条状的，那就做不出来青椒肉丝；二是因为腌制肉的时候没有进行裹淀粉的步骤【有条件裹鸡蛋清当然更好】，导致肉刚下锅就老，炒不出鲜嫩滑爽的效果；三是因为炒的时候油量和油温没有控制好，导致肉炒老了，不好吃。本文则记录青椒肉丝的炒制过程以及需要注意的地方，请观察一下我是怎么做出来一道家常的青椒肉丝的。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="青椒肉丝" scheme="https://www.playpi.org/tags/green-pepper-shredded-pork-chn/"/>
    
      <category term="青红椒" scheme="https://www.playpi.org/tags/green-and-red-pepper-chn/"/>
    
      <category term="炒肉丝" scheme="https://www.playpi.org/tags/fried-pork-chn/"/>
    
  </entry>
  
  <entry>
    <title>腊肠炒饭做法总结</title>
    <link href="https://www.playpi.org/2019030901.html"/>
    <id>https://www.playpi.org/2019030901.html</id>
    <published>2019-03-08T17:06:17.000Z</published>
    <updated>2019-03-08T17:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --><p>蛋炒饭，是一种常见的菜肴，日常生活中听到的最多的就是扬州炒饭、传统炒饭。其实炒饭的做法非常多，口味也非常多，还被改成了很多版本，例如：虾仁炒饭、滑蛋炒蛋、老干妈炒饭。但无论怎么改变，它们的共同点都是做法简单，准备米饭和配菜就行了，炒出来吃起来香喷喷的，口感极好，也不用单独配其它的菜了，很方便。本文就记录腊肠炒饭的家常做法。</p><a id="more"></a><h1 id="食材准备"><a href="# 食材准备" class="headerlink" title="食材准备"></a>食材准备 </h1><p> 以下准备的是两人份的食材：</p><ul><li>腊肠，我这里选择的皇上皇腊肠，口味偏甜了，不适合炒饭，去买的时候广州酒家的咸香腊肠卖光了，先凑合着用 </li><li> 鸡蛋 2 个 </li><li> 米饭 2 小碗 </li><li> 青菜 1 小棵，普通的青菜即可，或者放绿豌豆也行，主要为了点缀一下 </li><li> 胡萝卜 1 小段 </li></ul><p> 腊肠，我买的这种偏甜了，不适合炒饭，下次还是买广州酒家的咸香腊肠比较好。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wn7ix32qj229s29s7wi.jpg" alt="皇上皇腊肠" title="皇上皇腊肠"></p><p>米饭 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wn80ipw8j229s29skjl.jpg" alt="米饭" title="米饭"></p><p> 全部食材 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wn8yzvcyj229s29shdu.jpg" alt="全部食材" title="全部食材"></p><h1 id="制作步骤"><a href="# 制作步骤" class="headerlink" title="制作步骤"></a> 制作步骤 </h1><h2 id="1、处理配菜"><a href="#1、处理配菜" class="headerlink" title="1、处理配菜"></a>1、处理配菜</h2><p> 配菜全部都切好备用：青菜切碎，腊肠切斜片，胡萝卜切丁，鸡蛋打入碗里搅拌，米饭捣碎。这里需要注意的有三点：一是胡萝卜要去皮，更能凸显颜色，而且没有胡萝卜皮的影响，炒饭吃起来口感也更好。二是米饭要捣碎，让米粒分开，不要一整块下锅，所以最好选择比较干硬的米饭来做炒饭，炒起来更方便，口感也更好。三是搅拌鸡蛋之前可以稍微放一点点食用盐，这样做为了鸡蛋更入味。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wn9b6cd2j229s29sb2a.jpg" alt="所有配菜处理完成" title="所有配菜处理完成"></p><h2 id="2、炒鸡蛋备用"><a href="#2、炒鸡蛋备用" class="headerlink" title="2、炒鸡蛋备用"></a>2、炒鸡蛋备用 </h2><p> 开火，锅里放油，一定要多放点油，因为鸡蛋非常吃油。放多点没关系，因为后续炒饭可以少放点。油烧热后，把鸡蛋液倒放进去，摇晃炒锅，让鸡蛋在里面呈圆形，防止鸡蛋液堆在一起。如果鸡蛋液太多了，可以在底部的鸡蛋液成型后，用锅铲拨到一边，让上边的鸡蛋液流下来，继续成型。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wn9xwk8jj229s29s1ky.jpg" alt="鸡蛋液入锅成型" title="鸡蛋液入锅成型"></p><p>鸡蛋基本成型后，就可以用锅铲搅拌捣碎。实际上用炒勺做就方便一点，如果是用锅铲就不太方便。这里需要注意，鸡蛋不要炒制太熟，要让它保持嫩嫩的，因为等一下还要和米饭一起重新下锅。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wna3znwnj229s29sb2a.jpg" alt="捣碎嫩鸡蛋" title="捣碎嫩鸡蛋"></p><p>捣碎后盛出备用，如果有时间的话，可以把鸡蛋的蛋清和蛋黄分别炒制，做出来的颜色会更好看。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wna81hkqj229s29sx6p.jpg" alt="盛出备用" title="盛出备用"></p><h2 id="3、炒配菜和饭"><a href="#3、炒配菜和饭" class="headerlink" title="3、炒配菜和饭"></a>3、炒配菜和饭 </h2><p> 鸡蛋盛出后，锅里表面其实还有大量的油，接着再稍微放一点点油就行了。继续加热，放入腊肠片、胡萝卜、碎青菜，大火炒 30 秒。<br>加腊肠片 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wnbf5yncj229s29shdu.jpg" alt="加腊肠片" title="加腊肠片"></p><p> 加胡萝卜青菜【我忘记放碎青菜了，出锅前才补上，看后面的图】<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wnbjhtc3j229s29s4qq.jpg" alt="加胡萝卜青菜" title="加胡萝卜青菜"></p><p>接着就开始加入米饭和刚才的鸡蛋，我这个米饭看起来是一块一块的，其实一碰就散了，开大火不停地翻炒。翻炒 3 分钟左右【如果一开始米饭没有捣碎，或者刚从冰箱拿出来的冷米饭，炒起来会比较慢】，基本就熟了，关小火，准备调味。</p><p>加入米饭和鸡蛋 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wnbopeilj229s29s1ky.jpg" alt="加入米饭和鸡蛋" title="加入米饭和鸡蛋"></p><p> 炒熟了，准备调味 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wnbti2c7j229s29sb2a.jpg" alt="准备调味" title="准备调味"></p><h2 id="4、调味出锅"><a href="#4、调味出锅" class="headerlink" title="4、调味出锅"></a>4、调味出锅</h2><p> 放入盐、鸡精、生抽、老抽，然后继续开大火，翻炒几十秒，出锅装盘，美滋滋。我还放了一点榨菜和辣椒酱。</p><p>放入调味料，因为放了老抽，可以看到颜色有一点点变化 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wnc0a62gj229s29shdu.jpg" alt="调味完成" title="调味完成"></p><p> 前面忘记放青菜了，补回来 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wngewbgvj229s29shdu.jpg" alt="补加青菜" title="补加青菜"></p><p> 出锅装盘，这图片有点糊了 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g0wnc81e80j229s29s1ky.jpg" alt="出锅装盘" title="出锅装盘"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项</h1><p>1、米饭的选择，米饭不是随便都适合做炒饭的，要选择那种稍微干硬一点的，米粒都分开的，炒出来会更香。如果是剩米饭，已经是一整块了，千万不要一整块的下锅，很难分开，要提前捣碎，处理好再下锅炒。</p><p>2、一开始炒鸡蛋的时候，不要炒制太熟，要保持嫩嫩的，因为后面还要和米饭一起下锅。</p><p>3、腊肠的选择，不要选择偏甜的口味，否则最终的炒饭吃起来会有点腻，所以还是选择咸香的口味比较好。广州酒家的那种咸香的腊肠，用来炒饭真的很合适。</p><p>4、关于分量的建议，一般做炒饭至少两人的份量。因为如果只炒一份，各种菜只能放一点，放多了就不是炒饭了。那问题来了，剩下的菜不好办【半个胡萝卜、半棵青菜】，又不能存放太久，只能下次接着炒，甚至连续吃炒饭。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;蛋炒饭，是一种常见的菜肴，日常生活中听到的最多的就是扬州炒饭、传统炒饭。其实炒饭的做法非常多，口味也非常多，还被改成了很多版本，例如：虾仁炒饭、滑蛋炒蛋、老干妈炒饭。但无论怎么改变，它们的共同点都是做法简单，准备米饭和配菜就行了，炒出来吃起来香喷喷的，口感极好，也不用单独配其它的菜了，很方便。本文就记录腊肠炒饭的家常做法。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="腊肠炒饭" scheme="https://www.playpi.org/tags/sausage-fried-rice-can/"/>
    
      <category term="蛋炒饭" scheme="https://www.playpi.org/tags/Egg-fried-rice-chn/"/>
    
      <category term="鸡蛋炒饭" scheme="https://www.playpi.org/tags/fried-rice-with-egg-chn/"/>
    
      <category term="炒饭" scheme="https://www.playpi.org/tags/fried-rice-chn/"/>
    
  </entry>
  
  <entry>
    <title>使用 Github 的 WebHooks 实现代码自动更新</title>
    <link href="https://www.playpi.org/2019030601.html"/>
    <id>https://www.playpi.org/2019030601.html</id>
    <published>2019-03-06T15:13:32.000Z</published>
    <updated>2019-03-07T15:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --><p>我的静态博客为了百度爬虫单独部署了一个镜像，放在了我的 VPS 上面【在 vultr 购买的主机】，并单独设置了二级域名 blog.playpi.org。但是，每次 GitHub 有新的提交时【基本每周都会有至少三次提交】，为了及时更新，我都会登录到 VPS 上面，到指定的项目下做一下拉取更新的操作，即执行 <strong>git pull</strong>。这样操作了三五次，我就有点不耐烦了，自己身为做技术的人，怎么能忍受这个呢，做法既低效又不优雅。于是，我就在想有没有更好的方法来实现自动拉取更新。一开始想到，直接在 VPS 起一个周期性脚本不就行了，比如每隔 1 分钟自动执行 <strong>git pull</strong>，但是立马又被我否定了，虽然做法很简单，但是太不优雅了，而且极大浪费 CPU。后来想到，GitHub 自带了 WebHooks 功能，概念类似于回调钩子，可以给 GitHub 的项目设置各种各样的行为，满足一定的场景才会触发【例如当有新的 push 时，就会向设置的 url 发送请求，并且在请求体中携带 push 的相关信息】。我的自动化构建就是这样的原理，每当 source 分支有提交时，都会通知 tavis-ci【这就是一个行为】，然后在 travis-ci 中设置好脚本，自动运行脚本，就完成了自动生成、部署的操作。</p><p>根据这个思路，就可以给 GitHub 的项目设置一个 WebHooks，每当 master 分支有提交时【代表着静态博客有更新了】，会根据设置的链接自动发送消息到 VPS 上面，然后 VPS 再执行拉取更新，这样的话就优雅多了。但是问题又来了，满足这种场景还需要在 VPS 设置一个后台服务，用来接收 GitHub 的消息通知并执行拉取更新的操作。我想了一下，既然 VPS 上面已经起了 Nginx 服务，那就要充分利用起来，给 Nginx 设置好反向代理，把指定的请求转给另外一个服务就行了。那这个服务怎么选呢，当然是选择 PHP 后台了，毕竟 PHP 号称世界上最好的语言， PHP 后台搭建起来也容易。本文就记录从基础环境安装配置到成功实现自动拉取更新的整个过程，本文涉及的系统环境是 CentOS 7 x64，软件版本会在操作中具体指明。</p><a id="more"></a><h1 id="配置服务器的 -PHP- 支持"><a href="# 配置服务器的 -PHP- 支持" class="headerlink" title="配置服务器的 PHP 支持"></a>配置服务器的 PHP 支持 </h1><p>VPS 上面的 Nginx 已经安装好了，就不再赘述过程，不清楚的可以参考我的另外一篇文章：<a href="https://www.playpi.org/2019010501.html">GitHub Pages 禁止百度蜘蛛爬取的问题</a> 。配置 PHP 的后台服务支持主要有三个步骤：一是配置安装 PHP，包括附加模块 PHP-FPM，二是配置启动 PHP-FPM 模块，三是配置重启 Nginx。由于我的机器资源问题【配置太低】，在这个过程踩了很多坑，我也会一一记录下来。</p><p> 毕竟我是新手，有很多地方不是太懂，所以先参考了官网和一些别人的博客，有时候看多了也会迷惑，有些内容大家描述的不一样，所以要结合自己的实际环境来操作，有些步骤是可以省略的。这些链接我放在这里给大家参考：<a href="https://secure.php.net/manual/zh/install.unix.nginx.php" target="_blank" rel="noopener">参考 PHP 官网 </a> 、<a href="https://segmentfault.com/a/1190000013344675" target="_blank" rel="noopener">CentOS 7.2 环境搭建实录 (第二章：php 安装)</a> 、<a href="https://learnku.com/articles/23694" target="_blank" rel="noopener">PHP-FPM 与 Nginx 的通信机制总结</a> 、<a href="https://qq52o.me/2482.html" target="_blank" rel="noopener"> 使用 Github 的 WebHooks 实现生产环境代码自动更新 </a> 。</p><p> 先安装软件仓库，我的已经安装好了，重复安装也没影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br></pre></td></tr></table></figure><h2 id="踩着坑安装 -PHP"><a href="# 踩着坑安装 -PHP" class="headerlink" title="踩着坑安装 PHP"></a>踩着坑安装 PHP</h2><p>1、下载指定版本的 PHP 源码，我这里选择了最新的版本 7.3.3，然后解压。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 下载 </span><br><span class="line">wget http://php.net/get/php-7.3.3.tar.gz/from/this/mirror -O ./php-7.3.3.tar.gz</span><br><span class="line">-- 解压 </span><br><span class="line">tar zxvf php-7.3.3.tar.gz</span><br></pre></td></tr></table></figure><p>2、configure【配置】，指定 PHP 安装目录【默认是 /usr/local/php，使用 <strong>–prefix</strong> 参数】和 PHP 配置目录【默认和 PHP 安装目录一致，使用 <strong>–with-config-file-path</strong> 参数】，我这里特意指定各自的目录，更方便管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 配置，并且开启 PHP-FPM 模块 [使用 --enable-fpm 参数]</span><br><span class="line">./configure --prefix=/site/php/--with-config-file-path=/site/php/conf/--enable-fpm</span><br></pre></td></tr></table></figure><p>遇到报错：<strong>configure: error: no acceptable C compiler found in $PATH</strong>。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g167nenhspj20jt06tglu.jpg" alt="缺少 c 编译器" title="缺少 c 编译器"></p><p>竟然缺少 c 编译器，那就安装吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 安装 gcc 编译器 </span><br><span class="line">yum install gcc</span><br></pre></td></tr></table></figure><p>安装 gcc 编译器成功 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g167o1kn4dj21hc0mrgna.jpg" alt="安装 gcc 编译器 1" title="安装 gcc 编译器 1"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g167ol7hilj21hc0mrjsx.jpg" alt="安装 gcc 编译器 2" title="安装 gcc 编译器 2"></p><p> 安装 gcc 编译器完成后，接着执行配置，又报错：<strong>configure: error: libxml2 not found. Please check your libxml2 installation.</strong>。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g167p2bqdaj20l20bxq3h.jpg" alt="缺少对应的依赖环境库" title="缺少对应的依赖环境库"></p><p>这肯定是缺少对应的依赖环境库，接着安装就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 安装 2 个，环境库 </span><br><span class="line">yum install libxml2</span><br><span class="line">yum install libxml2-devel -y</span><br></pre></td></tr></table></figure><p>安装依赖环境库成功 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g167pq2doqj21hc0mrabc.jpg" alt="安装环境库完成" title="安装环境库完成"></p><p> 接着就重复上述的配置操作，顺利通过配置。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g167qgfhy8j21hc0mrta5.jpg" alt="执行配置完成" title="执行配置完成"></p><p>3、编译、安装。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 编译，安装一起进行 </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p></p><p>遇到报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc: internal compiler error: Killed (program cc1)</span><br><span class="line">Please submit a full bug report,</span><br><span class="line">with preprocessed source if appropriate.</span><br><span class="line">See &lt;http://bugzilla.redhat.com/bugzilla&gt; for instructions.</span><br><span class="line">make: *** [ext/fileinfo/libmagic/apprentice.lo] Error 1</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g167qyojuij20rn0563yp.jpg" alt="编译安装内存不够报错" title="编译安装内存不够报错"></p><p>这是由于服务器内存小于 1G 所导致编译占用资源不足【好吧，我的服务器一共就 512M 的内存，当然不足】。解决办法：在编译参数后面加上一行内容 <strong>–disable-fileinfo</strong>，减少内存的开销。</p><p>接着执行编译又报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc: internal compiler error: Killed (program cc1)</span><br><span class="line">Please submit a full bug report,</span><br><span class="line">with preprocessed source if appropriate.</span><br><span class="line">See &lt;http://bugzilla.redhat.com/bugzilla&gt; for instructions.</span><br><span class="line">make: *** [Zend/zend_execute.lo] Error 1</span><br></pre></td></tr></table></figure><p>这是因为虚拟内存不够用，我的主机只有 512M。没办法了，降低版本试试，先降为 v7.0.0【或者开启 swap 试试，后面发现不用了，切换低版本后就成功了】，接着重新下载、配置、编译、安装，从头再来一遍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 下载的时候更改版本号就行 </span><br><span class="line">wget http://php.net/get/php-7.0.0.tar.gz/from/this/mirror -O ./php-7.0.0.tar.gz</span><br></pre></td></tr></table></figure><p>更换了版本后，一切操作都很顺利，就不再考虑开启 swap 了，最终执行编译、安装完成。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g167tfxfarj20iv0mr3zs.jpg" alt="执行编译安装完成" title="执行编译安装完成"></p><h2 id="真正开始配置"><a href="# 真正开始配置" class="headerlink" title="真正开始配置"></a>真正开始配置 </h2><p> 配置、编译、安装完成后，开始编辑各个模块的配置文件，更改默认参数，包括配置 PHP 与 PHP-FPM 模块。确认配置无误，再启动对应的服务或者重新加载对应的配置【也可以使用命令验证参数配置是否正确，下文会有描述】。</p><h3 id="PHP- 配置文件"><a href="#PHP- 配置文件" class="headerlink" title="PHP 配置文件"></a>PHP 配置文件 </h3><p> 在执行编译安装的目录，复制配置文件 <strong>php.ini-development</strong> 粘贴到 PHP 的配置目录【如果一开始 configure 时没有显示指定 PHP 的配置目录，默认应该和 PHP 的安装目录一致，也就是要复制粘贴在 /usr/local/php 中，而我指定了 PHP 的配置目录 /site/php/conf】。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp php.ini-development/site/php/conf/php.ini</span><br></pre></td></tr></table></figure><p>更改 PHP 的配置文件，修改部分参数，更改 <strong>cgi.fix_pathinfo</strong> 的值为 0，以避免遭受恶意脚本注入的攻击。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /site/php/conf/php.ini</span><br><span class="line">cgi.fix_pathinfo=0</span><br></pre></td></tr></table></figure><h3 id="PHP-FPM- 配置文件"><a href="#PHP-FPM- 配置文件" class="headerlink" title="PHP-FPM 配置文件"></a>PHP-FPM 配置文件 </h3><p> 在 PHP 的安装目录中，找到 etc 目录【如果在一开始的 configure 时没有显示指定 PHP 的安装目录，默认安装在 /usr/local/php 中，则需要到此目录下寻找 etc 目录，而我指定了 PHP 的安装目录 /site/php/】，复制 PHP-FPM 模块的配置文件 <strong>php-fpm.conf.default</strong>，内容不需要更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- PHP 的附加模块的配置默认安装在了 etc 目录下 </span><br><span class="line">cd /site/php/etc</span><br><span class="line">cp php-fpm.conf.default php-fpm.conf</span><br></pre></td></tr></table></figure><p>在上面的 etc 目录中，继续复制 PHP-FPM 模块的默认配置文件。因为在上述的配置文件 <strong>php-fpm.conf</strong> 中，指定了 <strong>include=/site/php/etc/php-fpm.d/*.conf</strong>，也就是会从此目录 <strong>/site/php/etc/php-fpm.d/</strong> 加载多份有效的配置文件，至少要有一份存在，否则后续启动 PHP-FPM 的时候会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 先直接使用模板，不改配置参数，后续需要更改用户和组 </span><br><span class="line">cp php-fpm.d/www.conf.default php-fpm.d/www.conf</span><br></pre></td></tr></table></figure><p>配置完成后，开始启动 PHP-FPM 模块，在 PHP 的安装目录中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- PHP 的附加模块的脚本默认安装在了 sbin 目录下 </span><br><span class="line">-- 为了方便可以添加环境变量，把 sbin、bin 这 2 个目录都加进去 </span><br><span class="line">cd /site/php</span><br><span class="line">-- 配置文件合法性测试 </span><br><span class="line">./sbin/php-fpm -t</span><br><span class="line">-- 启动，现在还不能使用 service php-fpm start 的方式，因为没有把此模块配置到系统里面 </span><br><span class="line">./sbin/php-fpm</span><br><span class="line">-- 检验是否启动 </span><br><span class="line">ps aux|grep php-fpm</span><br></pre></td></tr></table></figure><p>配置文件合法性检测 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g167zej3snj20ja02t0sm.jpg" alt="配置文件合法性检测" title="配置文件合法性检测"></p><p> 可以看到正常启动了 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g167zqai4zj20nb03zt8s.jpg" alt="PHP-FPM 启动成功" title="PHP-FPM 启动成功"></p><p> 那怎么关闭以及重启呢，PHP 5.3.3 以后的 PHP-FPM 模块不再支持 PHP-FPM 以前具有的 <strong>./sbin/php-fpm (start|stop|reload)</strong> 等命令，所以不要再看这种古老的命令了，需要使用信号控制：</p><ul><li>INT，TERM，立刻终止 </li><li>QUIT 平滑终止</li><li>USR1 重新打开日志文件</li><li>USR2 平滑重载所有 worker 进程并重新载入配置和二进制模块</li></ul><p> 注意，这里的信号标识和 Unix 系统中的一样，被 kill 命令所使用，其中 USR1、USR2 是用户自定义信号，PHP-FPM 模块需要自定义实现，仅供参考。</p><p>其中，根据 Unix 基础知识，INT【2】表示中断信号，等价于 Ctrl + C，TERM【15】表示终止信号【清除后正常终止，不同于编号 9 KILL 的强制终止而不清除】，QUIT【3】表示退出信号，等价于 Ctrl + \，USR1【10】、USR2【12】这 2 个表示用户自定义信号。</p><p>所以可以使用命令 <strong>kill -INT pid</strong> 来停止 PHP-FPM 模块，pid 的值可以使用 <strong>ps aux|grep php-fpm</strong> 获取。当然，也可以使用 <strong>kill -INT pid 配置文件路径 </strong>来停止 PHP-FPM 模块，pid 配置文件路径 可以在 php-fpm.conf 中查看，<strong>pid 参数 </strong>，默认是关闭的。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1681vrhobj20om071mxh.jpg" alt="使用信号控制的方式停止 PHP-FPM" title="使用信号控制的方式停止 PHP-FPM"></p><p>为了能使用 <strong>service php-fpm start|stop|restart|reload)</strong> 的方式来进行启动、停止、重启、重载配置，这种方式显得优雅，需要把此模块配置到系统里面。在 PHP 的编译安装目录，复制文件 <strong>sapi/fpm/init.d.php-fpm</strong> ，粘贴到系统指定的目录即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /site/php-7.0.0</span><br><span class="line">-- 复制文件 </span><br><span class="line">cp sapi/fpm/init.d.php-fpm/etc/init.d/php-fpm</span><br><span class="line">-- 添加执行权限 </span><br><span class="line">chmod +x /etc/init.d/php-fpm</span><br><span class="line">-- 添加服务 </span><br><span class="line">chkconfig --add php-fpm</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g16828okbij20nq06zaaf.jpg" alt="使用 service 操作 PHP-FPM" title="使用 service 操作 PHP-FPM"></p><h3 id="Nginx- 的配置文件"><a href="#Nginx- 的配置文件" class="headerlink" title="Nginx 的配置文件"></a>Nginx 的配置文件 </h3><p> 接下来就是更改 Nginx 的配置文件，让 Nginx 支持 PHP 请求，并且同时设置好反向代理，把请求转给 PHP-FPM 模块处理【前提是在不影响 html 请求的情况下】，在 server 中增加一个配置 location。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 打开配置文件 </span><br><span class="line">vi /etc/nginx/nginx.conf</span><br><span class="line">-- 更改 server 模块的内容，增加 php 的配置 </span><br><span class="line">-- 80 端口就不用管了，直接在 443 端口下配置 </span><br><span class="line">location ~* \.php$ &#123;</span><br><span class="line">      fastcgi_index   index.php;</span><br><span class="line">      fastcgi_pass    127.0.0.1:9000;</span><br><span class="line">      include         fastcgi_params;</span><br><span class="line">      fastcgi_param   SCRIPT_FILENAME    $document_root$fastcgi_script_name;</span><br><span class="line">      fastcgi_param   SCRIPT_NAME        $fastcgi_script_name;</span><br><span class="line">    &#125;</span><br><span class="line">-- 重新加载 nginx 配置，不需要重启 </span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>这样配置好，就会把所有的 PHP 请求转给 PHP-FPM 模块处理，同时并不会影响原来的 html 请求。</p><h3 id="额外优化配置项"><a href="# 额外优化配置项" class="headerlink" title="额外优化配置项"></a>额外优化配置项 </h3><p> 此外，还有一些环境变量配置、开机启动配置，这里就不再赘述了，这些配置好了可以方便后续的命令简化，不配置也是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 设置开机启动的 chkconfig 方法，以下是添加服务 </span><br><span class="line">cp sapi/fpm/init.d.php-fpm/etc/init.d/php-fpm</span><br><span class="line">chmod +x /etc/init.d/php-fpm</span><br><span class="line">chkconfig --add php-fpm</span><br><span class="line">-- 设置开机启动 </span><br><span class="line">chkconfig php-fpm on</span><br><span class="line">-- 添加环境变量，之后 php 的相关命令就可以直接使用了 </span><br><span class="line">vi /etc/profile</span><br><span class="line">export PATH=$PATH:/site/php/bin:/site/php/sbin</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h1 id="PHP- 脚本"><a href="#PHP- 脚本" class="headerlink" title="PHP 脚本"></a>PHP 脚本 </h1><p> 先在静态站点的根目录下，添加默认的 index.php 文件，用来测试，内容如下，内容的意思是输出 PHP 的所有信息。注意，PHP 文件的格式是以 <strong>&lt;?php</strong> 开头，以 <strong>?&gt;</strong> 结尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi index.php</span><br><span class="line">&lt;?php phpinfo (); ?&gt;</span><br></pre></td></tr></table></figure><p>打开浏览器访问，可以看到成功，这就代表着 PHP 与 Nginx 的配置都没有问题，已经能正常提供服务。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1685gzg77j21hk0s6did.jpg" alt="成功访问 index.php" title="成功访问 index.php"></p><p>接下来就来测试一下复杂的脚本，可以用来自动拉取 GitHub 的提交。再创建一个 auto_pull.php 文件，内容如下，会自动到执行目录拉取 GitHub 的更新，这样就能实现镜像的自动更新了，还加入了秘钥验证【先不用管功能性是否可用，而是先测试一下复杂的 PHP 脚本能不能正常执行，脚本内容后续还要优化更改】，内容大致如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vi auto_pull.php</span><br><span class="line">&lt;?php</span><br><span class="line">// 生产环境 web 目录 </span><br><span class="line">$target = &apos;/site/iplaypi.github.io&apos;;</span><br><span class="line">// 密钥，验证 GitHub 的请求 </span><br><span class="line">$secret = &quot;test666&quot;;</span><br><span class="line">// 获取 GitHub 发送的内容 </span><br><span class="line">$json = file_get_contents (&apos;php://input&apos;);</span><br><span class="line">$content = json_decode ($json, true);</span><br><span class="line">// GitHub 发送过来的签名 </span><br><span class="line">$signature = $_SERVER [&apos;HTTP_X_HUB_SIGNATURE&apos;];</span><br><span class="line">if (!$signature) &#123;</span><br><span class="line">   return http_response_code (404);</span><br><span class="line">&#125;</span><br><span class="line">list ($algo, $hash) = explode (&apos;=&apos;, $signature, 2);</span><br><span class="line">// 计算签名 </span><br><span class="line">$payloadHash = hash_hmac ($algo, $json, $secret);</span><br><span class="line">// 获取分支名字 </span><br><span class="line">$branch = $content [&apos;ref&apos;];</span><br><span class="line">// 判断签名是否匹配，分支是否匹配 </span><br><span class="line">if ($hash === $payloadHash &amp;&amp; &apos;refs/heads/master&apos; === $branch) &#123;</span><br><span class="line">    $cmd = &quot;cd $target &amp;&amp; git pull&quot;;</span><br><span class="line">    $res = shell_exec ($cmd);</span><br><span class="line">    $res_log = &apos;Success:&apos;.PHP_EOL;</span><br><span class="line">    $res_log .= $content [&apos;head_commit&apos;][&apos;committer&apos;][&apos;name&apos;] . &apos; 在 & apos; . date (&apos;Y-m-d H:i:s&apos;) . &apos; 向 & apos; . $content [&apos;repository&apos;][&apos;name&apos;] . &apos; 项目的 & apos; . $content [&apos;ref&apos;] . &apos; 分支 push 了 & apos; . count ($content [&apos;commits&apos;]) . &apos; 个 commit：&apos; . PHP_EOL;</span><br><span class="line">    $res_log .= $res.PHP_EOL;</span><br><span class="line">    $res_log .= &apos;=======================================================================&apos;.PHP_EOL;</span><br><span class="line">    echo $res_log;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $res_log  = &apos;Error:&apos;.PHP_EOL;</span><br><span class="line">    $res_log .= $content [&apos;head_commit&apos;][&apos;committer&apos;][&apos;name&apos;] . &apos; 在 & apos; . date (&apos;Y-m-d H:i:s&apos;) . &apos; 向 & apos; . $content [&apos;repository&apos;][&apos;name&apos;] . &apos; 项目的 & apos; . $content [&apos;ref&apos;] . &apos; 分支 push 了 & apos; . count ($content [&apos;commits&apos;]) . &apos; 个 commit：&apos; . PHP_EOL;</span><br><span class="line">    $res_log .= &apos; 密钥不正确或者分支不是 master, 不能 pull&apos;.PHP_EOL;</span><br><span class="line">    $res_log .= &apos;=======================================================================&apos;.PHP_EOL;</span><br><span class="line">    echo $res_log;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>接下来先手工测试一下 PHP 文件的访问是否正常，可以使用 curl 模拟请求，或者直接使用 GitHub 的 WebHooks 请求。我这里为了简单，先使用 curl 命令来测试，后续的步骤才使用 GitHub 来真正测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &apos;X-Hub-Signature:test&apos;  https://blog.playpi.org/auto_pull.php</span><br></pre></td></tr></table></figure><p>可以看到，访问正常，先不管功能上能不能正常实现，至少保证 PHP 可以正常提供服务，后面会和 GitHub 对接。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g168ab7ih9j20r206awep.jpg" alt="使用 curl 模拟访问正常" title="使用 curl 模拟访问正常"></p><h1 id="测试 -WebHooks- 效果"><a href="# 测试 -WebHooks- 效果" class="headerlink" title="测试 WebHooks 效果"></a>测试 WebHooks 效果 </h1><p> 在 GitHub 中使用 WebHooks，为了表现出它的效果是什么样，我画了一个流程图，可以直观地看到它优雅的工作方式。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g168bmzii3j20lo0jwwfi.jpg" alt="WebHooks 效果流程图" title="WebHooks 效果流程图"></p><p>在上一步骤中，自动拉取更新的脚本已经写好，并且使用 curl 测试过模拟访问可用，那接下来就测试功能是否可用，当然，踩坑是避免不了的，优化脚本内容也是必要的。特别要注意用户权限和脚本内容这两方面，用户权限方面我直接使用 nginx 用户，踩坑比较少，脚本内容方面要保证你的服务器支持 <strong>shell_exec ()</strong> 这个 PHP 函数，可以在 <strong>index.php</strong> 文件中加一段代码 <strong>echo shell_exec (‘ls -la’);</strong>，测试一下。我的机器经过测试时支持的。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g168e04yz0j21hk0s6gs3.jpg" alt="测试 shell_exec 函数" title="测试 shell_exec 函数"></p><h2 id="在 -GitHub- 设置 -WebHooks"><a href="# 在 -GitHub- 设置 -WebHooks" class="headerlink" title="在 GitHub 设置 WebHooks"></a>在 GitHub 设置 WebHooks</h2><p>在 GitHub 对应项目的设置【Settings】中，找到 <strong>Webhooks</strong> 选项，可以看到已经有一些设置完成的 WebHook，这里面就包括 travis-ci 的自动构建配置。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1691o58jij20ty0en755.jpg" alt="Webhooks 列表" title="Webhooks 列表"></p><p>然后点击新建按钮，创建一个新的 WebHook【这个过程需要重新填写密码确认】，填写必要的参数，url 地址、秘钥、触发的事件，然后确认保存即可。注意，秘钥只是为了测试使用，实际应用时请更改，包括 WebHooks 的秘钥设置和 PHP 脚本里面的秘钥字符串。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1692ybibgj20su0qxgn6.jpg" alt="新建 WebHook" title="新建 WebHook"></p><p>如果是第一次创建完成，还没有触发请求的历史记录，可以先手动在 master 分支做一次变更提交，然后就会触发一次 WebHooks 事件。我这里已经有触发历史了，拿一个出来看就行了。注意，为了方便测试，只要有一次请求就行了，因为如果后续更改了脚本，不用再手动向 master 分支做一次变更提交，可以直接点击重新发送【redeliver】。<br>触发请求的信息，就是 http 请求头和请求体 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1694gk8tdj20pl0pi3zt.jpg" alt="WebHook 触发请求携带的信息" title="WebHook 触发请求携带的信息"></p><p>VPS 的 PHP 后台服务返回的信息，可以看到正常处理了 WebHooks 请求，但是没有做拉取更新的操作，原因可能是秘钥不对或者分支不对。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1694ke4dbj20or0judgk.jpg" alt="PHP 后台服务返回的信息" title="PHP 后台服务返回的信息"></p><h2 id="测试功能是否可用"><a href="# 测试功能是否可用" class="headerlink" title="测试功能是否可用"></a> 测试功能是否可用 </h2><p> 以下内容所需要的 PHP 脚本：index.php、auto_pull.php 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo shell_exec (&quot;id -a&quot;);</span><br><span class="line">echo shell_exec (&apos;ls -la&apos;);</span><br><span class="line">phpinfo ();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 生产环境 web 目录 </span><br><span class="line">$target = &apos;/site/iplaypi.github.io&apos;;</span><br><span class="line">// 密钥，验证 GitHub 的请求 </span><br><span class="line">$secret = &quot;test666&quot;;</span><br><span class="line">// 获取 GitHub 发送的内容，解析 </span><br><span class="line">$json = file_get_contents (&apos;php://input&apos;);</span><br><span class="line">$content = json_decode ($json, true);</span><br><span class="line">// GitHub 发送过来的签名，一定要大写，虽然 http 请求里面是驼峰法命名的 </span><br><span class="line">$signature = $_SERVER [&apos;HTTP_X_HUB_SIGNATURE&apos;];</span><br><span class="line">if (!$signature) &#123;</span><br><span class="line">   return http_response_code (404);</span><br><span class="line">&#125;</span><br><span class="line">// 使用等号分割，得到算法和签名 </span><br><span class="line">list ($algo, $hash) = explode (&apos;=&apos;, $signature, 2);</span><br><span class="line">// 在本机计算签名 </span><br><span class="line">$payloadHash = hash_hmac ($algo, $json, $secret);</span><br><span class="line">// 获取分支名字 </span><br><span class="line">$branch = $content [&apos;ref&apos;];</span><br><span class="line">// 日志内容 </span><br><span class="line">$logMessage = &apos;[&apos; . $content [&apos;head_commit&apos;][&apos;committer&apos;][&apos;name&apos;] . &apos;] 在 [&apos; . date (&apos;Y-m-d H:i:s&apos;) . &apos;] 向项目 [&apos; . $content [&apos;repository&apos;][&apos;name&apos;] . &apos;] 的分支 [&apos; . $content [&apos;ref&apos;] . &apos;] push 了 [&apos; . count ($content [&apos;commits&apos;]) . &apos;] 个 commit&apos; . PHP_EOL;</span><br><span class="line">$logMessage .= &apos;ret:[&apos; . $content [&apos;ref&apos;] . &apos;],payloadHash:[&apos; . $payloadHash . &apos;]&apos; . PHP_EOL;</span><br><span class="line">// 判断签名是否匹配，分支是否匹配 </span><br><span class="line">if ($hash === $payloadHash &amp;&amp; &apos;refs/heads/master&apos; === $branch) &#123;</span><br><span class="line">    // 增加执行脚本日志重定向输出到文件 </span><br><span class="line">    $cmd = &quot;cd $target &amp;&amp; git pull&quot;;</span><br><span class="line">    $res = shell_exec ($cmd);</span><br><span class="line">    $res_log = &apos;Success:&apos; . PHP_EOL;</span><br><span class="line">    $res_log .= $logMessage;</span><br><span class="line">    $res_log .= $res . PHP_EOL;</span><br><span class="line">    $res_log .= &apos;=======================================================================&apos;.PHP_EOL;</span><br><span class="line">    echo $res_log;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $res_log  = &apos;Error:&apos; . PHP_EOL;</span><br><span class="line">    $res_log .= $logMessage;</span><br><span class="line">    $res_log .= &apos; 密钥不正确或者分支不是 master, 不能 pull&apos; . PHP_EOL;</span><br><span class="line">    $res_log .= &apos;=======================================================================&apos;.PHP_EOL;</span><br><span class="line">    echo $res_log;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>上面已经测试了访问正常，但是为了保证 PHP 脚本的功能正常执行，接下来要优化 PHP 脚本内容了。我分析一下，根据脚本的内容，只有当秘钥正确并且当前变更的分支是 master 时才会执行拉取更新操作，看返回结果也是这样的。当前没有执行拉取更新的操作，但是我的这一个触发通知里面是表明了 master 分支【根据 ref 参数】，那就是秘钥的问题了，需要详细看一下秘钥计算的那段 PHP 代码。如果怕麻烦，直接把加密这个流程去掉【会导致恶意请求，浪费 CPU 资源】，GitHub 并没有要求一定要填写秘钥，但是我为了安全，仍旧填写。</p><p>我看了一下代码，并没有发现问题，于是加日志把后台处理的一些结果返回，看看哪里出问题了。最终发现竟然是分支名字的问题，PHP 代码通过 <strong>$content</strong> 没有获取到任何内容，包括分支名字、项目名字、提交信息等，而秘钥签名的处理是正常的。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1697xx5vaj20nl0g00tb.jpg" alt="错误日志返回" title="错误日志返回"></p><p>思考了一下，然后我就发现，竟然是创建 WebHooks 的时候内容传输类型【Content type】设置错误，不能使用默认的，要设置为 <strong>application/json</strong>，否则后台的 PHP 代码处理不了内容解析，获取的全部是空内容。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g1699fp81lj20uf0oiwg0.jpg" alt="内容传输类型设置错误" title="内容传输类型设置错误"></p><p>好，一切准备就绪，再来试一次，问题又来了，果然用户权限问题是逃不了的。这个问题我早有防备，本质就是没有设置好 PHP 的用户，导致 PHP 执行脚本的时候，没有权限获取与 Git 有关的信息【执行脚本的用户没有自己的家目录，也没有存储 ssh 认证信息】。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g169b32samj20pj0hpwf4.jpg" alt="PHP 执行权限问题" title="PHP 执行权限问题"></p><p>接下来就简单了，去设置 PHP 的执行用户，可能还要涉及到 Nginx。先在原先的 <strong>index.php</strong> 脚本中增加内容 <strong>echo shell_exec (“id -a”);</strong>，用来输出当前用户信息，发现是 nobody，那就和我想的一样了。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g169d8f9fbj20sa0fsdi8.jpg" alt="输出 PHP 的执行用户信息" title="输出 PHP 的执行用户信息"></p><p>为了规范起来便于管理，还是改为和 Nginx 同一个用户比较好，还记得 PHP-FPM 模块的配置文件吗 <strong>/site/php/etc/php-fpm.d/www.conf </strong>，去里面找到用户和组的配置项 <strong>user、group</strong>，把 nobody 改为 nginx。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g169e1crm2j20gl02qwec.jpg" alt="设置 PHP-FPM 的用户名和组" title="设置 PHP-FPM 的用户名和组"></p><p>为什么选择 nginx 用户呢，因为我的 Nginx 服务使用的就是 nginx 用户，这样就不用再创建一个用户了，可以去配置文件 <strong>/etc/nginx/nginx.conf</strong> 里面查看。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g169fau9zzj20c806amx2.jpg" alt="查看 Nginx 的用户" title="查看 Nginx 的用户"></p><p>其实，用户的设置是随意的，如果把 PHP-FPM 的用户设置为 root 更方便，但是这样有很大风险，所以不要这么做。如果非要使用 nobody 也是可以的，我只是为了方便管理用户，和 Nginx 服务共同使用一个用户。一切配置完成后别忘记重启 PHP-FPM 模块。</p><p>接着就是最重要的步骤了，把本地的 GitHub 项目所属用户设置为 nginx，并且保证 nginx 用户的家目录有 ssh 认证相关的秘钥信息，这样在以后的自动拉取更新时才能畅通无阻。我把原先的项目删掉，然后使用 sudo 命令给 nginx 用户生成 ssh 认证信息，并且重新克隆项目，克隆的同时指定所属用户为 nginx。【由于用户 nginx 没有登录 Shell 的权限，所以不能直接使用 nginx 用户登录后再操作的方式解决】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 目录不存在先创建，赋给 nginx 用户权限 </span><br><span class="line">mkdir -p /home/nginx/.ssh/</span><br><span class="line">chown nginx:nginx -R /home/nginx/.ssh/</span><br><span class="line">-- H 参数表示设置家目录环境，u 参数表示用户名 </span><br><span class="line">cd /site/</span><br><span class="line">sudo -Hu nginx ssh-keygen -t rsa -C &quot;plapyi@qq.com&quot;</span><br><span class="line">sudo -Hu nginx git clone https://github.com/iplaypi/iplaypi.github.io.git</span><br><span class="line">-- 如果没有 iplaypi.github.io 目录的权限，也要赋予 nginx 用户 </span><br><span class="line">mkdir iplaypi.github.io</span><br><span class="line">chown nginx:nginx iplaypi.github.io</span><br></pre></td></tr></table></figure><p>好，一切准备就绪，我再来试一次。可以看到，完美执行，热泪盈眶。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g169gkpo0cj20s30nfgmm.jpg" alt="解决所有问题后成功实现自动拉取" title="解决所有问题后成功实现自动拉取"></p><p>为了方便，本来我把这 2 个 php 文件直接放在项目里面了，放在 source 分支，再更新一下 travis-ci 的配置文件，把它们提交到 master 分支去。但是这样做的风险就是把秘钥暴露出去了，显然不可取，所以折中的办法就是把这 2 个文件当做模板，把秘钥隐去，放在 source 分支，以后用的时候直接复制就行了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat May 18 2019 23:38:59 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;我的静态博客为了百度爬虫单独部署了一个镜像，放在了我的 VPS 上面【在 vultr 购买的主机】，并单独设置了二级域名 blog.playpi.org。但是，每次 GitHub 有新的提交时【基本每周都会有至少三次提交】，为了及时更新，我都会登录到 VPS 上面，到指定的项目下做一下拉取更新的操作，即执行 &lt;strong&gt;git pull&lt;/strong&gt;。这样操作了三五次，我就有点不耐烦了，自己身为做技术的人，怎么能忍受这个呢，做法既低效又不优雅。于是，我就在想有没有更好的方法来实现自动拉取更新。一开始想到，直接在 VPS 起一个周期性脚本不就行了，比如每隔 1 分钟自动执行 &lt;strong&gt;git pull&lt;/strong&gt;，但是立马又被我否定了，虽然做法很简单，但是太不优雅了，而且极大浪费 CPU。后来想到，GitHub 自带了 WebHooks 功能，概念类似于回调钩子，可以给 GitHub 的项目设置各种各样的行为，满足一定的场景才会触发【例如当有新的 push 时，就会向设置的 url 发送请求，并且在请求体中携带 push 的相关信息】。我的自动化构建就是这样的原理，每当 source 分支有提交时，都会通知 tavis-ci【这就是一个行为】，然后在 travis-ci 中设置好脚本，自动运行脚本，就完成了自动生成、部署的操作。&lt;/p&gt;&lt;p&gt;根据这个思路，就可以给 GitHub 的项目设置一个 WebHooks，每当 master 分支有提交时【代表着静态博客有更新了】，会根据设置的链接自动发送消息到 VPS 上面，然后 VPS 再执行拉取更新，这样的话就优雅多了。但是问题又来了，满足这种场景还需要在 VPS 设置一个后台服务，用来接收 GitHub 的消息通知并执行拉取更新的操作。我想了一下，既然 VPS 上面已经起了 Nginx 服务，那就要充分利用起来，给 Nginx 设置好反向代理，把指定的请求转给另外一个服务就行了。那这个服务怎么选呢，当然是选择 PHP 后台了，毕竟 PHP 号称世界上最好的语言， PHP 后台搭建起来也容易。本文就记录从基础环境安装配置到成功实现自动拉取更新的整个过程，本文涉及的系统环境是 CentOS 7 x64，软件版本会在操作中具体指明。&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://www.playpi.org/categories/building/"/>
    
    
      <category term="Git" scheme="https://www.playpi.org/tags/Git/"/>
    
      <category term="Github" scheme="https://www.playpi.org/tags/Github/"/>
    
      <category term="PHP" scheme="https://www.playpi.org/tags/PHP/"/>
    
      <category term="WebHooks" scheme="https://www.playpi.org/tags/WebHooks/"/>
    
      <category term="自动更新" scheme="https://www.playpi.org/tags/auto-update-chn/"/>
    
      <category term="钩子" scheme="https://www.playpi.org/tags/webhook-chn/"/>
    
  </entry>
  
</feed>
