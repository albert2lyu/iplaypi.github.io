<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虾丸派</title>
  
  <subtitle>烂笔头</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.playpi.org/"/>
  <updated>2019-08-22T15:00:47.000Z</updated>
  <id>https://www.playpi.org/</id>
  
  <author>
    <name>虾丸派</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 http 接口删除 Elasticsearch 集群的索引</title>
    <link href="https://www.playpi.org/2019082101.html"/>
    <id>https://www.playpi.org/2019082101.html</id>
    <published>2019-08-21T15:00:47.000Z</published>
    <updated>2019-08-22T15:00:47.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>在工作中遇到需要定期关闭、删除 <code>Elasticsearch</code> 集群索引的需求，关闭索引或者删除索引是一个很简单的操作，直接向 <code>Elasticsearch</code> 集群发送一个请求即可。而且，为了实现批量删除，可以一次性发送多个索引名称，使用逗号分隔即可，甚至可以使用通配符【需要 <code>Elasticsearch</code> 集群的相关设置开启】，会直接删掉满足通配符条件的索引。</p><p>本文基于最简单的一个场景：单个索引的关闭、删除，使用 <code>Java</code> 编程语言、<code>HTTP</code> 接口，尝试关闭、删除 <code>Elasticsearch</code> 集群的索引，属于入门级别，开发环境基于 <code>Elasticsearch v1.7.5</code>，这是一个很旧的版本，<code>JDK v1.8</code>。</p><a id="more"></a><p>首先声明，本文内容是基于 <code>Elasticsearch v1.7.5</code>，这是一个很旧的版本，目前各个公司应该只有在一些历史遗留的项目中使用，一般大家都会使用 <code>v5.x</code>、<code>v6.x</code> 之类的版本了。此外，在 <code>v6.x</code> 及以上版本取消了索引 <code>type</code> 的概念，在那个场景下可以随便删除一个索引，而不用再考虑单个索引 <code>index</code> 下面存在的多个 <code>type</code> 的情况，没有误删除的风险。</p><h1 id="背景介绍"><a href="# 背景介绍" class="headerlink" title="背景介绍"></a>背景介绍 </h1><p> 我的目的只有两个：关闭索引、删除索引，是不是很简单的问题。</p><p>回归到我的具体业务，其实就是由于历史数据的积压，创建了很多个索引，而这些数据平时又没有用处，特别是比较久远的数据，根本不会有人用到，留着它们纯属浪费磁盘空间。</p><p>仔细分析、调研，对于最近几个月的数据，还会有一些价值，偶尔有人翻看，其实可以先关闭索引，如果确实有人需要，再临时打开。但是对于已经存在一年以上的数据，不会有人用到，可以说是无人关心、无人问津，这种数据对应的索引就应该被删除，不需要保留。</p><p>那么为了实现这个需求，可以写一个定时程序来处理。</p><h1 id="技术分析"><a href="# 技术分析" class="headerlink" title="技术分析"></a>技术分析 </h1><p> 根据以上的想法，我去查看了 <code>Elasticsearch</code> 的官方文档，发现有非常简单的 <code>HTTP</code> 接口可以使用，我也决定使用它。但是需要注意，在 <code>Elasticsearch</code> 中只能删除整个 <code>index</code>，而不能只是删除 <code>index</code> 下面的某个 <code>type</code>。也就是说只要对某个 <code>index</code> 执行删除操作，则此 <code>index</code> 下面的所有 <code>type</code> 都会被一起删除，所以这是一个有点危险的操作，读者需要慎重执行，千万不要只想着 <strong>一顿操作猛如虎 </strong>，最终沦落为 <strong>不领工资快跑路 </strong>的境地，或者造成 <strong>明天去一趟财务室 </strong>的严重后果。</p><p>参考官方文档内容如下：</p><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.7/indices-delete-index.html" target="_blank" rel="noopener">indices-delete-index</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/1.7/indices-open-close.html" target="_blank" rel="noopener">indices-open-close</a></li></ul><p>看文档很明显，我需要使用三个 <code>HTTP</code> 接口，请读者继续往下看。</p><h2 id="删除索引"><a href="# 删除索引" class="headerlink" title="删除索引"></a>删除索引 </h2><p> 删除索引，使用 <code>curl -XDELETE http://localhost:9200/your_index</code> 接口即可，把主机地址、端口号、索引名称更换成实际的取值即可。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190823232341.png" alt="删除索引文档" title="删除索引文档"></p><p>如果想一次性删除多个索引，可以传入多个索引名称，使用逗号连接，例如：<code>index1,index2,index3</code>，这样就可以一次性删除，但是索引也不能太多，我在自己的集群测试，只能传入 20 个，再多会被忽略，不会被删除。</p><p>当然，为了方便用户使用，<code>Elasticsearch</code> 也是支持通配符的，例如使用：<br><code>curl -XDELETE http://localhost:9200/_all</code>、<br><code>curl -XDELETE http://localhost:9200/*</code><br>就可以把所有的索引删除。其中，<code>_all</code>、<code>*</code> 就是通配符，匹配所有的索引名称，显然这是一个极度危险的操作，如果做了真的是只能 <strong>删库跑路 </strong>。</p><p>另外还有一种比较安全的通配符，就是前缀匹配，例如使用 <code>curl -XDELETE http://localhost:9200/test-*</code> 就可以把以 <code>test-</code> 开头的索引删除，不会删除不满足这个匹配条件的索引。</p><p>当然，是有办法可以避免这种潜在的危险操作，那就是关闭通配符的功能，在 <code>Elasticsearch</code> 的配置文件 <code>elasticsearch.yml</code> 中，有一个 <code>action.destructive_requires_name=true</code> 参数，控制着 <code>_all</code>、<code>*</code> 这两个通配符的开启还是关闭【配置为 true 表示拒绝通配符，只能匹配特定的索引名称】。</p><p>除了直接更改配置文件，需要重启 <code>Elasticsearch</code> 集群，也可以通过 <strong>动态变更参数 </strong>接口来改变这个参数的取值，这样就不用重启集群。但是，这一特性需要 <code>v2.x</code> 以上的版本才会支持，参考官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.1/cluster-update-settings.html" target="_blank" rel="noopener">cluster-update-settings</a> 。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190823232359.png" alt="动态更新配置文档" title="动态更新配置文档"></p><p>以下使用配置举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curl XPUT http://localhost:9200/_cluster/settings -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    永久生效 </span><br><span class="line">    &quot;persistent&quot; : &#123;</span><br><span class="line">        &quot;action.destructive_requires_name&quot; : true</span><br><span class="line">    &#125;,</span><br><span class="line">    本次生效，重启集群后失效 </span><br><span class="line">    &quot;transient&quot; : &#123;</span><br><span class="line">        &quot;iaction.destructive_requires_name&quot; : true </span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p>其实仔细想想，关闭通配符可以保证数据安全，但是却给操作带来了一定的麻烦，这个需要读者自己权衡。</p><h2 id="开启关闭索引"><a href="# 开启关闭索引" class="headerlink" title="开启关闭索引"></a>开启关闭索引 </h2><p> 开启、关闭索引的接口比较简单，如下：</p><ul><li>开启索引，<code>curl -XPOST http://localhost:9200/your_index/_open</code></li><li>关闭索引，<code>curl -XPOST http://localhost:9200/your_index/_close</code></li></ul><p>把主机地址、端口号、索引名称更换成实际的取值即可。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190823232821.png" alt="开启关闭索引文档" title="开启关闭索引文档"></p><p>这里的通配符使用方式与上面的一致，不再赘述。</p><h1 id="代码实现"><a href="# 代码实现" class="headerlink" title="代码实现"></a>代码实现 </h1><p> 技术分析完毕，开始使用代码实现，这样就可以在服务器起一个定时程序，用来定时关闭一些索引，定时删除一些索引，以后只需要定期检查有无误操作即可。</p><p>代码逻辑比较简单，使用参数封装 <code>HTTP</code> 请求，然后发送给 <code>Elasticsearch</code> 集群，再解析返回的数据，来判断操作是否成功。</p><p>代码示例我已经放在 <code>GitHub</code> 上面，仅供参考：<a href="https://github.com/iplaypi/iplaypistudy/tree/master/iplaypistudy-elasticsearch/src/main/java/org/playpi/study/client" target="_blank" rel="noopener">CleanEsClusterClient.java</a> ，搜索 <strong>CleanEsClusterClient</strong> 类即可，此外，核心的处理类是 <strong>EsClusterUtil</strong>，里面封装了主要逻辑。</p><p>下面使用删除索引的 <code>HTTP</code> 请求处理来展示一下代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 删除指定的索引 </span><br><span class="line">     * 索引可以批量传入，使用逗号分隔即可 </span><br><span class="line">     *</span><br><span class="line">     * @param hostport</span><br><span class="line">     * @param indexName</span><br><span class="line">     * @param useSsl    是否使用 https 协议 </span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">public static Boolean deleteIndex (String hostport, String indexName, Boolean useSsl) &#123;</span><br><span class="line">String url = &quot;http://&quot; + hostport + &quot;/&quot; + indexName;</span><br><span class="line">String resultStr = HttpUtil.getHttpResult (url, null, HttpUtil.HTTP_METHOD.DELETE, useSsl);</span><br><span class="line">Map&lt;String, Object&gt; resultMap = new Gson ().fromJson (resultStr, Map.class);</span><br><span class="line">if (null != resultMap &amp;&amp; Boolean.valueOf (resultMap.getOrDefault (&quot;acknowledged&quot;, false).toString ())) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190823234735.png" alt="删除索引代码示例" title="删除索引代码示例"></p><p>可以看到只有几行代码，其中 <code>HttpUtil</code> 是一个工具类，也可以在 <code>GitHub</code> 项目中搜索。</p><h1 id="使用命令发送请求"><a href="# 使用命令发送请求" class="headerlink" title="使用命令发送请求"></a>使用命令发送请求 </h1><p> 演示完了代码，下面演示使用 <code>curl</code> 命令的方式来操作 <code>Elasticsearch</code> 集群，与 <code>Java</code> 代码发送 <code>HTTP</code> 请求的效果是一样的，我这里只是简单演示关闭索引的操作。</p><p>使用如下命令向我的 <code>Elasticsearch</code> 集群发送一个关闭索引的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST http://dev2:9200/test-index-v2/_close</span><br></pre></td></tr></table></figure><p>发送成功后，可以看到返回结果，关闭成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;acknowledged&quot;:true&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190823234220.png" alt="发送命令返回结果" title="发送命令返回结果"></p><p>去 <code>Elasticsearch</code> 集群看一下索引的状态，索引 <code>test-index-v2</code> 的确已经被关闭了。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190823234312.png" alt="v2 索引被关闭" title="v2 索引被关闭"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在工作中遇到需要定期关闭、删除 &lt;code&gt;Elasticsearch&lt;/code&gt; 集群索引的需求，关闭索引或者删除索引是一个很简单的操作，直接向 &lt;code&gt;Elasticsearch&lt;/code&gt; 集群发送一个请求即可。而且，为了实现批量删除，可以一次性发送多个索引名称，使用逗号分隔即可，甚至可以使用通配符【需要 &lt;code&gt;Elasticsearch&lt;/code&gt; 集群的相关设置开启】，会直接删掉满足通配符条件的索引。&lt;/p&gt;&lt;p&gt;本文基于最简单的一个场景：单个索引的关闭、删除，使用 &lt;code&gt;Java&lt;/code&gt; 编程语言、&lt;code&gt;HTTP&lt;/code&gt; 接口，尝试关闭、删除 &lt;code&gt;Elasticsearch&lt;/code&gt; 集群的索引，属于入门级别，开发环境基于 &lt;code&gt;Elasticsearch v1.7.5&lt;/code&gt;，这是一个很旧的版本，&lt;code&gt;JDK v1.8&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据技术知识" scheme="https://www.playpi.org/categories/big-data-technical-knowledge/"/>
    
    
      <category term="Java" scheme="https://www.playpi.org/tags/Java/"/>
    
      <category term="Elasticsearch" scheme="https://www.playpi.org/tags/Elasticsearch/"/>
    
      <category term="HTTP" scheme="https://www.playpi.org/tags/HTTP/"/>
    
      <category term="curl" scheme="https://www.playpi.org/tags/curl/"/>
    
  </entry>
  
  <entry>
    <title>记录一次关于 log4j 的 ClassNotFoundException 异常</title>
    <link href="https://www.playpi.org/2019073001.html"/>
    <id>https://www.playpi.org/2019073001.html</id>
    <published>2019-07-29T17:04:36.000Z</published>
    <updated>2019-08-04T17:04:36.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>本来一个正常的 <code>Java</code> 项目，某一次运行的时候发现了一个异常：<br><code>java.lang.ClassNotFoundException: org.apache.log4j.DailyRollingFileAppender</code>，<br>我觉得很奇怪，这种常用的类怎么可能会缺失。但是，<strong> 代码之多，无奇不有 </strong>，遇到这种奇怪的问题也是检验我技术高低的良机，看我怎么步步排查，找到问题所在。本文开发环境基于 <code>Java v1.8+</code>、<code>Spark v1.6.x</code>、<code>Maven v3.5.x</code> 。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 场景描述：一个常规的 <code>Java</code> 项目，单线程处理数据，一直以来都正常运行，某一天我做了小小的代码改动，接着运行就报错。</p><p>错误日志信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">log4j:ERROR Could not instantiate class [org.apache.log4j.DailyRollingFileAppender].</span><br><span class="line">java.lang.ClassNotFoundException: org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">at java.net.URLClassLoader.findClass (URLClassLoader.java:381)</span><br><span class="line">at java.lang.ClassLoader.loadClass (ClassLoader.java:424)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass (Launcher.java:338)</span><br><span class="line">at java.lang.ClassLoader.loadClass (ClassLoader.java:357)</span><br><span class="line">at java.lang.Class.forName0 (Native Method)</span><br><span class="line">at java.lang.Class.forName (Class.java:264)</span><br><span class="line">at org.apache.log4j.helpers.Loader.loadClass (Loader.java:178)</span><br><span class="line">at org.apache.log4j.helpers.OptionConverter.instantiateByClassName (OptionConverter.java:317)</span><br><span class="line">at org.apache.log4j.helpers.OptionConverter.instantiateByKey (OptionConverter.java:120)</span><br><span class="line">at org.apache.log4j.PropertyConfigurator.parseAppender (PropertyConfigurator.java:629)</span><br><span class="line">at org.apache.log4j.PropertyConfigurator.parseCategory (PropertyConfigurator.java:612)</span><br><span class="line">at org.apache.log4j.PropertyConfigurator.configureRootCategory (PropertyConfigurator.java:509)</span><br><span class="line">at org.apache.log4j.PropertyConfigurator.doConfigure (PropertyConfigurator.java:415)</span><br><span class="line">at org.apache.log4j.PropertyConfigurator.doConfigure (PropertyConfigurator.java:441)</span><br><span class="line">at org.apache.log4j.helpers.OptionConverter.selectAndConfigure (OptionConverter.java:468)</span><br><span class="line">at org.apache.log4j.LogManager.&lt;clinit&gt;(LogManager.java:122)</span><br><span class="line">at org.slf4j.impl.Log4jLoggerFactory.getLogger (Log4jLoggerFactory.java:64)</span><br><span class="line">at org.slf4j.LoggerFactory.getLogger (LoggerFactory.java:285)</span><br><span class="line">at org.slf4j.LoggerFactory.getLogger (LoggerFactory.java:305)</span><br><span class="line">at com.xxx.yyy.client.hbase.HBaseUtils.&lt;clinit&gt;(HBaseUtils.java:36)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804183345.png" alt="错误日志片段截图" title="错误日志片段截图"></p><p>错误日志很多，主要看这一行信息：<br><code>java.lang.ClassNotFoundException: org.apache.log4j.DailyRollingFileAppender</code>，<br>找不到 <code>DailyRollingFileAppender</code> 这个类，即类缺失。显然，这不可能是代码改动引起的问题，这种情况可能是虚拟机没有加载到类，或者加载了多个版本不一致的类导致冲突。</p><p>查了很多网上的相同问题，都说是依赖包缺失，但是我觉得不太可能，因为这个 <code>Java</code> 项目中的其它模块都能正常使用【使用多个 <code>Maven</code> 模块管理整个 <code>Java</code> 项目，它们的环境一致】，于是想办法验证一下。</p><p>先在 <code>Java</code> 项目中搜索类，可以看到能搜索到，说明不会缺失【此处不考虑打包过程中移除的情况】。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804183506.png" alt="全局搜索类" title="全局搜索类"></p><p>再使用 <code>mvn dependency:tree</code> 生成依赖树信息，在依赖树信息中搜索查看，也能看到关于 <code>slf4j</code> 的两个依赖包以及关于 <code>log4j</code> 的一个依赖包，说明没有缺失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[INFO] |  |  +- org.slf4j:slf4j-api:jar:1.7.10:compile</span><br><span class="line">[INFO] |  |  +- org.slf4j:slf4j-log4j12:jar:1.7.10:compile</span><br><span class="line">...</span><br><span class="line">[INFO] +- log4j:log4j:jar:1.2.12:compile</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804183531.png" alt="查看 slf4j 相关类" title="查看 slf4j 相关类"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804183539.png" alt="查看 log4j 相关类" title="查看 log4j 相关类"></p><p>根据上面的操作分析，依赖没有缺失，而且，从搜索结果看只有一个类，从依赖树信息中看也没有多版本冲突，此时看似陷入了僵局。</p><h1 id="问题分析解决"><a href="# 问题分析解决" class="headerlink" title="问题分析解决"></a>问题分析解决 </h1><p> 我努力回想改动了什么代码或者配置才会导致这个问题，使用 <code>Git</code> 查一下，通过查看提交历史记录，发现了一处微小的改动，在 <code>Maven</code> 子模块的 <code>pom.xml</code> 文件中。这也是造成这个问题的罪魁祸首，下面详细说明。</p><p>其实，此时需要考虑一个问题，本机查看的项目代码和打包后的可能不一样，比如冲突问题导致的版本选择，或者插件造成的部分无效依赖被移除等原因会造成前后差异。</p><p>我也一直在回想我改动了什么代码或者配置，才触发了这个问题，果然，通过 <code>Git</code> 的提交记录找到了蛛丝马迹。</p><p>通过仔细的对比，发现了问题所在，原来在 <code>pom.xml</code> 文件中，使用了 <code>maven-shade-plugin</code> 插件进行依赖瘦身，导致将 <code>slf4j</code>、<code>log4j</code> 相关的依赖全部被移除。归根结底，还是因为我在代码中没有使用 <code>slf4j</code>、<code>log4j</code> 的相关类【但是在父类中使用了】，<code>maven-shade-plugin</code> 插件误以为这两个依赖都是无用的，就全部移除了。等到程序启动运行的时候，发现找不到相关的类了。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804183620.png" alt="shade 插件配置" title="shade 插件配置"></p><p><code>pom.xml</code> 配置信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- shade 构件，打包时可以：包含依赖构件，重命名包名避免冲突，移除特定的类避免冲突 --&gt;</span><br><span class="line">&lt;!-- 具体参考:http://maven.apache.org/plugins/maven-shade-plugin/--&gt;</span><br><span class="line">&lt;!-- &lt;minimizeJar&gt;true&lt;/minimizeJar&gt; 可以自动移除无用的类，瘦身 jar 包 --&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">  &lt;executions&gt;</span><br><span class="line">    &lt;execution&gt;</span><br><span class="line">      &lt;!-- 绑定 Maven 的 package 阶段 --&gt;</span><br><span class="line">      &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">      &lt;goals&gt;</span><br><span class="line">        &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">      &lt;/goals&gt;</span><br><span class="line">      &lt;!-- 详细配置项 --&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;!-- 自动移除无用的依赖，坑：项目没用到 slf4j, 但是依赖的父类用到，却被移除 --&gt;</span><br><span class="line">        &lt;!--&lt;minimizeJar&gt;true&lt;/minimizeJar&gt;--&gt;</span><br><span class="line">        &lt;!-- 将指定文件以 append 方式加入到构建的 jar 包中 --&gt;</span><br><span class="line">        &lt;transformers&gt;</span><br><span class="line">          &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;&gt;</span><br><span class="line">            &lt;resource&gt;reference.conf&lt;/resource&gt;</span><br><span class="line">          &lt;/transformer&gt;</span><br><span class="line">        &lt;/transformers&gt;</span><br><span class="line">        &lt;!-- 过滤匹配到的文件 --&gt;</span><br><span class="line">        &lt;filters&gt;</span><br><span class="line">          &lt;filter&gt;</span><br><span class="line">            &lt;artifact&gt;*:*&lt;/artifact&gt;</span><br><span class="line">            &lt;excludes&gt;</span><br><span class="line">              &lt;exclude&gt;META-INF/*.SF&lt;/exclude&gt;</span><br><span class="line">              &lt;exclude&gt;META-INF/*.DSA&lt;/exclude&gt;</span><br><span class="line">              &lt;exclude&gt;META-INF/*.RSA&lt;/exclude&gt;</span><br><span class="line">            &lt;/excludes&gt;</span><br><span class="line">          &lt;/filter&gt;</span><br><span class="line">        &lt;/filters&gt;</span><br><span class="line">        &lt;!-- 附加所有构件，并指定后缀名，与主程序 jar 包区分开 --&gt;</span><br><span class="line">        &lt;shadedArtifactAttached&gt;true&lt;/shadedArtifactAttached&gt;</span><br><span class="line">        &lt;shadedClassifierName&gt;jar-with-dependencies&lt;/shadedClassifierName&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line">    &lt;/execution&gt;</span><br><span class="line">  &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;minimizeJar&gt;true&lt;/minimizeJar&gt;</code> 这个配置决定了打包的依赖保留还是移除，我把它配置为 <code>true</code>，打包时会自动帮我移除无用的依赖包，其中包括 <code>log4j</code>、<code>slf4j</code>，也就导致了本文开头的问题。</p><p>看来，<code>maven-shade-plugin</code> 插件的依赖瘦身功能，还是要慎用，像今天这种情况就很是莫名其妙，只能靠细心、靠经验来发现问题、解决问题，如果是别人的代码还真难发现。</p><p>解决方法很简单，只要把这个配置移除【或者设置为 <code>false</code>】，问题就解决了。还有另外一种解决方式，在代码中显式使用 <code>log4j</code> 的相关类，其实真实是使用 <code>slf4j</code> 里面的实现类，这样打包时 <code>maven-shade-plugin</code> 插件则不会移除相关的类。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结 </h1><p> 在这种 <code>ClassNotFoundException</code> 异常现象的分析过程中，可以借助一款工具：<a href="https://alibaba.github.io/arthas" target="_blank" rel="noopener">Arthas（阿尔萨斯）</a> ，这是一款由 <strong>阿里巴巴 </strong>开源的一款 <code>Java</code> 诊断工具，深受开发者喜爱。</p><p>它可以解决类似如下的问题：</p><ul><li>这个类从哪个 <code>jar</code> 包加载的？为什么会报各种类相关的 <code>Exception</code>？</li><li>我改的代码为什么没有执行到？难道是我没 <code>commit</code>？分支搞错了？</li><li>遇到问题无法在线上 <code>debug</code>，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 <code>debug</code>，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到 <code>JVM</code> 的实时运行状态？</li></ul><p>比如针对我这个场景，我就可以快速查到 <code>DailyRollingFileAppender</code> 这个类有没有被虚拟机加载，以及从哪个 <code>jar</code> 包加载的。可以快速发现：虚拟机中并没有加载这个类，这个时候就可以断定类缺失，然后转换思路去查为什么类缺失。如果在项目中搜索、查看依赖树信息都没有发现类缺失的迹象，就可以怀疑是不是打包过程中被移除了，甚至可以怀疑是不是上传了错误的 <code>jar</code> 包去执行程序。</p><p>这样就可以一步一步、有理有据地分析问题，直到解决问题，不至于全程懵逼，靠经验与猜测去碰运气。显然，解决问题的过程肯定是目的明确而且高效的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本来一个正常的 &lt;code&gt;Java&lt;/code&gt; 项目，某一次运行的时候发现了一个异常：&lt;br&gt;&lt;code&gt;java.lang.ClassNotFoundException: org.apache.log4j.DailyRollingFileAppender&lt;/code&gt;，&lt;br&gt;我觉得很奇怪，这种常用的类怎么可能会缺失。但是，&lt;strong&gt; 代码之多，无奇不有 &lt;/strong&gt;，遇到这种奇怪的问题也是检验我技术高低的良机，看我怎么步步排查，找到问题所在。本文开发环境基于 &lt;code&gt;Java v1.8+&lt;/code&gt;、&lt;code&gt;Spark v1.6.x&lt;/code&gt;、&lt;code&gt;Maven v3.5.x&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="Maven" scheme="https://www.playpi.org/tags/Maven/"/>
    
      <category term="log4j" scheme="https://www.playpi.org/tags/log4j/"/>
    
      <category term="slf4j" scheme="https://www.playpi.org/tags/slf4j/"/>
    
      <category term="ClassNotFoundException" scheme="https://www.playpi.org/tags/ClassNotFoundException/"/>
    
      <category term="DailyRollingFileAppender" scheme="https://www.playpi.org/tags/DailyRollingFileAppender/"/>
    
      <category term="maven-shade-plugin" scheme="https://www.playpi.org/tags/maven-shade-plugin/"/>
    
  </entry>
  
  <entry>
    <title>使用 Vultr 创建云主机详细步骤</title>
    <link href="https://www.playpi.org/2019072801.html"/>
    <id>https://www.playpi.org/2019072801.html</id>
    <published>2019-07-27T17:20:23.000Z</published>
    <updated>2019-08-03T17:20:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>我在以前的一篇博客中，详细记录了自己搭建翻墙梯子的过程，参考：<br><a href="https://www.playpi.org/2018111601.html">使用 Vultr 搭建 Shadowsocks（VPS 搭建 SS）</a> ，其中，我还顺便留下了我的 <code>Vultr</code> 推广链接：<br><a href="https://www.vultr.com/?ref=7443790" target="_blank" rel="noopener">我的 10 美元推广链接 </a> 。可能是因为这篇博客的流量还不错，基本每个月都会有几个人通过我的推广链接注册，当然，注册后真正使用的人只有 1-2 个。</p><p> 我看了一下我的账户，平均每个月都会收到一份有效注册所带来的优惠券，大概可以给我带来 <code>$10</code> 的收入，足够抵消我的月租消费了，这也是注册 <code>Vultr</code> 后并真正使用 <code>Vultr</code> 的人带给我的收入，我觉得这是意外的惊喜。</p><p>所以，本着分享的理念以及「吃饭」的需要，我推荐大家使用 <code>Vultr</code>，但是担心可能有些读者第一次使用 <code>Vultr</code>，系统又是英文的，不太熟悉。在此，我把节点的创建过程再整理出来，图文并茂，并说明注意事项，给读者参考。读者参考本文一步一步操作，就可以从零开始创建 <code>Vultr</code> 主机，只需要再花费 <code>$10</code> 就可以使用半年的 <code>Vultr</code> 云主机。至于搭建梯子的过程还是请继续参考上面给出的以前的博客内容：<a href="https://www.playpi.org/2018111601.html">使用 Vultr 搭建 Shadowsocks（VPS 搭建 SS）</a> 。</p><p><strong>声明 </strong>：2019 年 08 月 09 日发现 <code>Vultr</code> 官方不会再赠送 <code>$10</code> 的代金券给新注册用户，只会给我发放代金券，但是 <code>$25</code> 的代金券仍然有效，请读者选择 <code>$25</code> 对应的链接打开注册，以免错失了代金券。</p><a id="more"></a><p>首先声明，本文中的文字与截图整理于 2019 年 07 月 26 日到 2019 年 08 月 03 日，以后 <code>Vultr</code> 这个产品的界面或者功能可能会变化，所以请读者以实际使用时的产品为准，本文仅供参考。但是我觉得无论 <code>Vultr</code> 这个产品再怎么变，本文描述的这几大核心功能也不会变，最多就是界面操作的变化，读者可以放心参考使用。</p><h1 id="开篇推荐"><a href="# 开篇推荐" class="headerlink" title="开篇推荐"></a>开篇推荐 </h1><p> 使用 <code>Vultr</code> 的云主机，最好选择洛杉矶地区的或者日本的服务器，我亲自测试这两个地区的服务器最稳定，已经推荐给很多人，而且网速相对来说较好，我的推广链接【可以获取 10 美元的代金券，只要充值 10 美元就能使用】：<a href="https://www.vultr.com/?ref=7443790" target="_blank" rel="noopener">我的 10 美元推广链接 </a> ，官网链接也在这里：<a href="https://my.vultr.com" target="_blank" rel="noopener">Vultr</a> 。</p><p> 这里再多说点，如果使用上面的推广链接注册 <code>Vultr</code> 帐号，可以获取 10 美元的代金券，需要在 30 天之内使用，使用的条件就是充值 10 美元以上的钱。例如充值 10 美元就会获取 20 美元的帐号余额，这些钱如果购买 3.5 美元的主机可以使用半年了，挺划算的。</p><p>此外还有一个限时的大优惠，如果准备长期使用 <code>Vultr</code>，肯定要充值多一点，我这里有一个限时的推广链接：<a href="https://www.vultr.com/?ref=7861302-4F" target="_blank" rel="noopener">我的 25 美元推广链接 </a> ，可以获取 25 美元的代金券，使用条件就是充值 25 美元以上的金额。假如充值了 25 美元，总共获取 50 美元入账，购买 3.5 美元的主机可以使用 14 个多月，适合长期使用 <code>Vultr</code> 的。</p><p> 以下列举 <code>Vultr</code> 的五大好处：</p><ul><li><strong>扣费灵活 </strong>，<code>Vultr</code> 有一个好处就是主机的费用并不是按照月份扣除的，而是按照天扣除的，每天扣除的费用是 <strong>月租 / 30</strong>。例如你的主机只用了 10 天，然后销毁不用了，实际只会扣除月租 1/3 的钱，这种方式很是灵活，哪怕主机的 <code>IP</code> 地址被屏蔽了也可以销毁重新生成一个，并不会浪费钱。它不像国内的云服务商，一般是按照月份扣费的。</li><li><strong>主机管理灵活 </strong>，它不像国内的云服务商，购买一台云主机后，直接先扣费，然后分配一台主机，<code>IP</code> 地址是固定的，如果有问题只能重启。而在 <code>Vultr</code> 中是可以随意创建、销毁虚拟主机的，根据你自己的需求，选择配置、主机机房位置、操作系统，几分钟就可以生成一台主机，如果用了几天觉得不好，或者 <code>IP</code> 地址被封，再销毁重新创建即可，<code>Vultr</code> 只会扣除你几天的费用，非常人性化。</li><li><strong>价格优惠 </strong>，根据配置的不同，价格有多个档次，有 <code>$2.5 / 月 </code>（只有 <code>IP6</code> 地址）、<code>$3.5 / 月</code>、<code>$5 / 月</code> 等等，更贵的也有，一般个人使用选择这三个中的一个就够用了，但是要注意便宜的经常售罄，而且最便宜的只支持 <code>IP6</code>，慎用。大家如果看到没有便宜的主机了不用着急，可以先买了贵的用着，反正费用是按照天数扣除的，等后续发现便宜的套餐赶紧购买，同时把贵的主机给销毁，不会亏钱的。</li><li><strong> 付费方式灵活 </strong>，付费方式除了支持常见的 <strong>Paypal</strong>、<strong> 信用卡 </strong>等方式，它还支持 <strong>比特比 </strong>、<strong> 支付宝 </strong>、<strong> 微信 </strong>等方式。就问你是不是很人性化，作为一家国外的公司，还特意支持 <strong>支付宝 </strong>、<strong> 微信 </strong>的方式支付，也从侧面反映了随着中国的日益强大，中国的电子支付方式正在走向全球，越来越流行。</li><li><strong>机房分布全球 </strong>，它的机房位置遍布全球，例如 <strong>日本 </strong>、<strong> 新加坡 </strong>、<strong> 澳大利亚 </strong>、<strong> 美国 </strong>、<strong> 德国 </strong>、<strong> 英国 </strong>、<strong> 加拿大 </strong>，读者根据网络的需求可以灵活选择。</li></ul><p>至于使用 <code>Vultr</code> 云主机做什么，我想最大的用处就是自行搭建梯子，可以参考我以前的博客内容：<a href="https://www.playpi.org/2018111601.html">使用 Vultr 搭建 Shadowsocks（VPS 搭建 SS）</a> 。</p><h1 id="产品介绍"><a href="# 产品介绍" class="headerlink" title="产品介绍"></a>产品介绍 </h1><p> 首先来看一下官网主页，官网主页地址为：<a href="https://my.vultr.com" target="_blank" rel="noopener">Vultr</a> ，目前看官网的 UI 和几个月前相比有变化，颜色在视觉上加深了，图标显得更加拟物化。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190803184837.png" alt="官网首页截图" title="官网首页截图"></p><p>登录的时候需要特别注意，它的验证码非常丧心病狂，一般是六位，而且很难看清楚，更加让人抓狂的是，有时候看不清还不能换一个，只能在输入认证错误后再重新输入，这种用户体验比不上国内的厂商。当然，在常用的网络环境中，<code>Vultr</code> 会检测出当前为常用网络，从而跳过验证码验证这一步骤，所以有时候不需要输入验证码。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190803184912.png" alt="登录验证码" title="登录验证码"></p><p>登录成功后，进入到主页，默认是在 <code>Products</code> 模块下面的 <code>Instances</code> 标签页。读者可以看到我这里已经有主机显示出来，如果读者是第一次注册后登录进去或者还没有创建主机的话，是看不到类似于我这里图中的 <code>Server</code> 列表的。不过不用着急，后面我会带领读者一步一步进行主机的创建。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190803185111.png" alt="Vultr 系统主页" title="Vultr 系统主页"></p><p>先来熟悉一下系统的所有模块与常用功能，毕竟界面是全英文的，读者熟悉后方便在后续的操作中熟练找到需要的模块与功能。</p><p>注意查看上面的首页图，读者也可以在登录进入系统之后，随便点击浏览一下。先看左侧列表，分为五个大模块：<code>Products</code>、<code>Billing</code>、<code>Support</code>、<code>Affiliate</code>、<code>Account</code>，下面简单描述一下这五个大模块，读者看完后在心里可以有一个基本的概念：</p><ul><li><code>Products</code>：<strong> 产品管理 </strong>模块，在里面可以管理主机、登录密钥、DNS、系统快照等信息，最常用的就是主机的创建、查看、销毁 </li><li><code>Billing</code>：<strong> 账单管理 </strong> 模块，在里面可以查看历史消费记录、支付方式，最常用的就是欠费充值、查看历史消费记录 </li><li><code>Support</code>：<strong> 系统支持 </strong> 模块，可以在里面浏览一些常见问题，或者联系客服，一般情况下用不到，目前无需关心 </li><li><code>Affiliate</code>：<strong> 营销推广 </strong> 模块，可以利用 <code>Vultr</code> 为你生成的唯一链接，拉取新用户注册使用，然后就会给你返代金券，可抵扣消费，一般情况下用不到，不过可以分享给身边的人试试 </li><li><code>Account</code>：<strong> 帐号信息 </strong> 模块，包括姓名、地址、邮箱等信息，每月的扣费记录会以账单的形式发送到你的邮箱，这个模块除了第一次设置，以后基本用不到，一般情况下每个月看一次邮箱即可 </li></ul><h1 id="产品管理"><a href="# 产品管理" class="headerlink" title="产品管理"></a> 产品管理 </h1><p><strong> 产品管理 </strong>里面的功能很多，但是对于我这样需求简单的人来说，不需要那么多功能，我只需要创建主机、系统快照这两个功能足够，所以我也只会介绍这两个功能。</p><h2 id="主机创建"><a href="# 主机创建" class="headerlink" title="主机创建"></a>主机创建 </h2><p> 在 <code>Products</code> 模块的 <code>Instances</code> 标签页中，可以看到 <code>Server</code> 列表，也就是用户创建的主机列表，如果还没有创建，则显示为空。看看我的主机列表，已经有一台主机，如下图。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804024429.png" alt="我的主机列表" title="我的主机列表"></p><p>读者可以注意到右侧有一个蓝色背景的圆形按钮，如果把鼠标的光标放上去，会显示 <code>Deploy New Server</code>，它就是用来创建主机的，下面我将一步一步演示创建的过程。</p><p>点击上述蓝色按钮，会进入 <code>Deploy New Instance</code> 配置界面，读者在 <code>Choose Server</code> 中首先选择 <code>Cloud Compute</code>，它表示 <strong>云主机 </strong>，也就是虚拟主机，它旁边还有三个产品类型可以忽略。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804024414.png" alt="选择云主机" title="选择云主机"></p><p>接着在 <code>Server Location</code> 中选择机房位置，这个要根据网络的需要请读者自行选择，如果你在中国大陆，需要搭建梯子，建议选择日本或者美国洛杉矶的机房位置，我这里以日本为例。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804024359.png" alt="选择机房位置" title="选择机房位置"></p><p>继续往下看，在 <code>Server Type</code> 中选择操作系统类型，我选择 <code>CentOS 7x64</code>。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804024345.png" alt="选择操作系统" title="选择操作系统"></p><p>在 <code>Server Size</code> 中选择主机配置，同时也代表价格，我选择 <code>$5/mon</code>，表示每个月费用五美元，再详细看一下机器的配置：<code>25GB SSD</code> 表示固态硬盘大小、<code>$0.007/h</code> 表示每小时费用 0.007 美元、<code>1 CPU</code> 表示机器的 CPU 为一核、<code>1024MB Memory</code> 表示机器的内存大小、<code>1000GB Bandwidth</code> 表示机器的流量大小。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804024328.png" alt="选择配置" title="选择配置"></p><p>最后的 <code>Additional Features</code>、<code>Startup Script</code>、<code>SSH Keys</code>、<code>Server Hostname &amp; Label</code> 可以不用设置，如果读者对 <code>Linux</code> 服务器有一定的了解并且会简单操作，可以在 <code>Startup Script</code> 设置启动脚本用来安装需要的软件环境，也可以在 <code>SSH Keys</code> 中设置密钥用来后续的免密登录，在此不在赘述。</p><p>一切设置完成后，点击右下角的 <code>Deploy Now</code> 蓝色按钮，接着等待几分钟即可。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804024308.png" alt="点击创建主机" title="点击创建主机"></p><p>在等待的过程中，可以回到前面的 <code>Instances</code> 标签页中查看 <code>Server</code> 列表，可以看到刚刚创建的机器正在初始化。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804024248.png" alt="主机正在初始化" title="主机正在初始化"></p><p>大概需要几分钟的时间，主机就创建完成。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804024229.png" alt="主机创建完成" title="主机创建完成"></p><p>主机创建完成，最重要的事情就是要得知它的 <code>IP</code> 地址、登录密码，才能进行下一步的操作。<code>IP</code> 地址其实在 <code>Server</code> 列表中已经可以看到，是 <code>198.13.59.132</code>，也可以直接点击主机，进入到主机的详情页。或者点击最右侧的三个点，选择 <code>Server Details</code> 进入主机的详情页。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804024209.png" alt="进入主机详情页" title="进入主机详情页"></p><p>在 <code>Overview</code> 标签页，此时可以看到更多关于主机的信息，包括 <code>IP</code> 地址、登录用户名、登录密码、流量使用情况、CPU 消耗监控、当前扣费情况。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804024153.png" alt="查看主机详情页" title="查看主机详情页"></p><h2 id="系统快照"><a href="# 系统快照" class="headerlink" title="系统快照"></a>系统快照 </h2><p> 前面主机创建的过程读者看了可能会觉得很麻烦，需要设置那么多东西，如果以后机器有问题需要重新创建还要来一遍，体验多不好。况且，如果机器上面安装了一些软件，设置了一些参数，从头再来很麻烦的，有没有简单的方式可以复制一台已经存在的主机呢，除了 <code>IP</code> 地址不一样，其它配置完全一致，并且还要保留机器上面的软件、参数等信息。</p><p>可以，当然可以，接下来，<strong> 系统快照 </strong>功能就要出场了。<strong> 系统快照 </strong>其实就是把操作系统在某一时刻的状态保存下来，包括系统的配置、安装的软件、参数的配置，生成的系统快照就可以随时重复使用，就像克隆一样。</p><p>为了使用系统快照，必须先创建系统快照，在主机的详情页中，有一个 <code>Snapshots</code> 标签页，就是用来创建系统快照的。先在文本框中填入一个名字，用来标记这一个系统快照，然后点击右侧的 <code>Take Snapshot</code> 开始创建。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804024054.png" alt="创建系统快照" title="创建系统快照"></p><p>在创建的过程中，可以在 <code>Products</code> 模块中的 <code>Snapshots</code> 标签页中查看系统快照的生成状态，这个过程一般需要很长时间，根据系统的复杂度而定。当然，如果系统中没有安装任何软件，创建起来还是很快的，几分钟就行。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804033858.png" alt="查看系统快照的生成状态" title="查看系统快照的生成状态"></p><p>等系统快照创建完成，使用系统快照就简单得多了，在创建云主机的过程中，不需要选择那么多的参数，选择机房位置后，在 <code>Server Type</code> 中点击 <code>Snapshot</code> 标签页，可以看到系统快照列表，从中选择一个自己需要的系统快照，直接生成即可。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804024026.png" alt="利用快照创建主机" title="利用快照创建主机"></p><p>使用系统快照创建的主机，除了机房位置、<code>IP</code> 地址与系统快照中的不一样，其它配置信息都是一样，也包括原来的软件、系统配置。</p><h1 id="账单管理"><a href="# 账单管理" class="headerlink" title="账单管理"></a>账单管理 </h1><p><strong> 账单管理 </strong>模块包含设置支付方式、充值、消费记录查看等功能，一般都会用到充值功能，用户使用这种虚拟服务一般不会充值太多的钱，可能半年或者一年才会充值一次。</p><h2 id="支付方式选择"><a href="# 支付方式选择" class="headerlink" title="支付方式选择"></a>支付方式选择 </h2><p> 支付方式就是用户选择使用什么方式来支付，设置好就行，以后除非更换支付方式，否则再也用不到这个功能。除了常规的 <strong>信用卡 </strong>、<strong>Paypal</strong> 支付方式，<code>Vultr</code> 还支持 <strong>支付宝 </strong>、<strong> 微信 </strong>、<strong> 比特比 </strong>支付方式，这支付体验对于中国用户来说简直太友好了，直接下单扫码分分钟就能完成。</p><p>在 <code>Billing</code> 模块选择 <code>Make Payment</code> 标签页，可以看到左侧列表中有多种支付方式可以选择，我这里已经绑定了信用卡。其中，<code>Credit Card</code> 表示信用卡、<code>Bitcoin</code> 表示比特币、<code>Alipay</code> 表示支付宝，<code>Wechat Pay</code> 表示微信支付，读者可以自行选择。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804012211.png" alt="设置支付方式" title="设置支付方式"></p><p>绑定具体的支付方式时，需要填写帐号信息，读者根据要求填写即可。</p><h2 id="查看历史消费记录"><a href="# 查看历史消费记录" class="headerlink" title="查看历史消费记录"></a>查看历史消费记录 </h2><p> 查看历史消费记录，就是为了对对账，看看有没有额外的乱扣费现象，一般情况下通过邮箱查看就行，不用特意登录 <code>Vultr</code> 里面看。</p><p>不过，账单默认是不会被发送到邮箱的，也不会通知用户，需要提前设置好通知方式，在 <code>Billing</code> 模块中的 <code>History</code> 标签页最底部有一个通知方式设置，选择通过邮箱发送即可，这个邮箱帐号是在 <code>Account</code> 模块中设置的，可以参考下文的相关内容。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804012240.png" alt="设置账单通知方式" title="设置账单通知方式"></p><p>选择 <code>Billing</code> 模块中的 <code>Histroy</code> 标签页，可以看到我的消费记录，八月一日扣除了我七月份的费用，总计 <code>$3.5</code>，这算是很便宜的主机配置，以前我用的是 <code>$5</code> 的主机，后来发现流量用不完就换了便宜的主机。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804012307.png" alt="消费记录查看" title="消费记录查看"></p><p>接着再看看我的邮箱，收到了费用扣除账单通知，一共扣除 <code>$3.5</code>。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804012337.png" alt="邮箱收到账单通知" title="邮箱收到账单通知"></p><p>仔细看 <code>History</code> 标签页中的历史清单，可以发现其中还有一些是进账，这种情况可能是自己充值，或者是邀请新用户使用 <code>Vultr</code> 带来的代金券。可以看到在七月份有两笔钱进账，总计二十美元，这明确记得我在七月份没有充值，应该是 <code>Vultr</code> 发放给我的代金券，如果按照 <code>$5 / 月 </code> 计算，这笔钱可以抵扣我四个月的主机费用了。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190804012349.png" alt="二十美元代金券收入" title="二十美元代金券收入"></p><h1 id="系统支持"><a href="# 系统支持" class="headerlink" title="系统支持"></a> 系统支持 </h1><p> 我自始至终只使用了两次这个模块，都是为了调整我的消费额度，前提是必须把需求说明清楚，并整理成英文，然后类似于提交 <strong>工单 </strong>一样把需求从后台发给客服。我的需求就是把我的月消费额度下调至 <code>$15 / 月 </code>，主机节点个数下调至 3 个，这样可以防止由于自己误操作导致的费用消耗过多，或者密码泄漏被人滥用。当然，这些情况理论上都不会发生，我只是图一个安心而已。</p><p> 有了自己的需求，我整理了一段简单的说明，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">New Instance Limit:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">New Monthly Instances Cost Limit:</span><br><span class="line">15</span><br><span class="line"></span><br><span class="line">Intended Usage:</span><br><span class="line">I want to increase my limit of instance cost,15 is my choose.</span><br></pre></td></tr></table></figure><p>然后在 <code>Support</code> 模块中，选择 <code>Tickets</code> 功能。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190803184502.png" alt="Tickets 功能" title="Tickets 功能"></p><p>可以看到在右上角有一个 <code>Open New Ticket</code> 按钮，是用来新建工单的，点击它。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190803184551.png" alt="新建 Ticket 按钮" title="新建 Ticket 按钮"></p><p>在跳转到的内容填写页面中填写你的需求即可，需要选择问题类型、主机、标题、内容，填写完成后点击下方的 <code>Open Ticket</code> 按钮即可。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190803184624.png" alt="填写详细信息并提交 Ticket" title="填写详细信息并提交 Ticket"></p><p>接下来就是等待了，客服不会及时回复的，一般需要等待 1 个工作日【24 个小时】。而且由于时差的原因，客服一般是在半夜回复，我们只能等到第二天再看。</p><p>提交后也可以在工单列表中查看历史工单，并可以随时打开进行补充，它就像一个聊天对话系统，但不是实时的，读者要做的就是等待。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190803184701.png" alt="查看历史 Tickets" title="查看历史 Tickets"></p><p>给你们看一下客服给我的回复，提交工单、客服回复前后相差 32 个小时，这效率也是挺低的，还好这个功能基本不会用到，要不然等这么久会疯掉的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Hello, </span><br><span class="line"></span><br><span class="line">The limits have been set as requested.</span><br><span class="line"></span><br><span class="line">Please let us know if you need further assistance. Our team is here and always happy to help.</span><br><span class="line"></span><br><span class="line">Thank you for choosing Vultr!</span><br><span class="line"></span><br><span class="line">Best Regards,</span><br><span class="line">Nachelle</span><br><span class="line">Vultr.com</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190803184728.png" alt="客服给我的回复" title="客服给我的回复"></p><p>我这个申请的调整结果可以在 <code>Billing</code> 模块中的 <code>Limits</code> 标签页中查看，主机个数、消费上线都已经调整成我希望的。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190803194606.png" alt="查看调整的结果" title="查看调整的结果"></p><h1 id="营销推广"><a href="# 营销推广" class="headerlink" title="营销推广"></a>营销推广 </h1><p><strong> 营销推广 </strong>模块里面的功能基本不会用到，除非你能邀请到别人注册并充值使用 <code>Vultr</code> 这个产品，这样的话 <code>Vultr</code> 就会返给你代金券，可以抵扣消费，但是不能提现。</p><p>所以我在此只简单介绍其中的两个小功能：分享链接、用户统计。</p><h2 id="分享链接"><a href="# 分享链接" class="headerlink" title="分享链接"></a>分享链接 </h2><p> 分享链接，就是把 <code>Vultr</code> 为你生成的唯一链接分享出去，别人点击你的链接注册后，就算作是你带来的用户，如果注册用户又充值并且在 <code>Vultr</code> 里面消费，你就会收到代金券。然而，用户只是注册是不行的，不算作有效用户，毕竟随便找几个邮箱就可以注册了，必须充值使用才算。</p><p>在 <code>Affilicate</code> 模块中，选择 <code>Linking Code</code> 标签页，就可以看到 <code>Vultr</code> 为你生成的唯一链接了。例如我的唯一链接是：<a href="https://www.vultr.com/?ref=7443790" target="_blank" rel="noopener">我的 Vultr $10 代金券链接 </a> ，文本形式则是：<code>https://www.vultr.com/?ref=7443790</code>，如下图。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190803193050.png" alt="我的唯一链接" title="我的唯一链接"></p><h2 id="用户统计"><a href="# 用户统计" class="headerlink" title="用户统计"></a> 用户统计 </h2><p> 用户统计就是查看自己邀请到的用户点击、用户注册、用户消费情况，选择 <code>Stats</code> 标签页，可以看到每个月的点击用户、注册用户、消费用户数据，并且 <code>Vultr</code> 已经使用条形统计图的方式展示出来。以此可以查看自己为 <code>Vultr</code> 带来的用户，以及自己能不能有代金券的收入。</p><p>看看我的用户统计，七月份比较惨淡，共有二十多个用户点击了我的链接，但是只有一个用户注册了，至于这个用户有没有充值继续使用还不确定，要等两个月之后才能判断。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190803193109.png" alt="七月份用户统计" title="七月份用户统计"></p><h1 id="帐号信息"><a href="# 帐号信息" class="headerlink" title="帐号信息"></a>帐号信息 </h1><p> 帐号信息在 <code>Account</code> 模块中设置，能用到的也就是个人简介，在 <code>Profile</code> 标签页中。而且这个模块一般用不到，读者无需关心。</p><p>我也就是填写姓名、邮箱、地址等信息。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190803204627.png" alt="个人简介设置" title="个人简介设置"></p><p>其中，邮箱帐号是很有必要的，在 <strong>账单管理 </strong>中设置账单的通知方式时，使用的就是这里填写的邮箱帐号，这样我每个月才会收到 <code>Vultr</code> 发来的扣费通知。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;我在以前的一篇博客中，详细记录了自己搭建翻墙梯子的过程，参考：&lt;br&gt;&lt;a href=&quot;https://www.playpi.org/2018111601.html&quot;&gt;使用 Vultr 搭建 Shadowsocks（VPS 搭建 SS）&lt;/a&gt; ，其中，我还顺便留下了我的 &lt;code&gt;Vultr&lt;/code&gt; 推广链接：&lt;br&gt;&lt;a href=&quot;https://www.vultr.com/?ref=7443790&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的 10 美元推广链接&lt;/a&gt; 。可能是因为这篇博客的流量还不错，基本每个月都会有几个人通过我的推广链接注册，当然，注册后真正使用的人只有 1-2 个。&lt;/p&gt;&lt;p&gt;我看了一下我的账户，平均每个月都会收到一份有效注册所带来的优惠券，大概可以给我带来 &lt;code&gt;$10&lt;/code&gt; 的收入，足够抵消我的月租消费了，这也是注册 &lt;code&gt;Vultr&lt;/code&gt; 后并真正使用 &lt;code&gt;Vultr&lt;/code&gt; 的人带给我的收入，我觉得这是意外的惊喜。&lt;/p&gt;&lt;p&gt;所以，本着分享的理念以及「吃饭」的需要，我推荐大家使用 &lt;code&gt;Vultr&lt;/code&gt;，但是担心可能有些读者第一次使用 &lt;code&gt;Vultr&lt;/code&gt;，系统又是英文的，不太熟悉。在此，我把节点的创建过程再整理出来，图文并茂，并说明注意事项，给读者参考。读者参考本文一步一步操作，就可以从零开始创建 &lt;code&gt;Vultr&lt;/code&gt; 主机，只需要再花费 &lt;code&gt;$10&lt;/code&gt; 就可以使用半年的 &lt;code&gt;Vultr&lt;/code&gt; 云主机。至于搭建梯子的过程还是请继续参考上面给出的以前的博客内容：&lt;a href=&quot;https://www.playpi.org/2018111601.html&quot;&gt;使用 Vultr 搭建 Shadowsocks（VPS 搭建 SS）&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;声明 &lt;/strong&gt;：2019 年 08 月 09 日发现 &lt;code&gt;Vultr&lt;/code&gt; 官方不会再赠送 &lt;code&gt;$10&lt;/code&gt; 的代金券给新注册用户，只会给我发放代金券，但是 &lt;code&gt;$25&lt;/code&gt; 的代金券仍然有效，请读者选择 &lt;code&gt;$25&lt;/code&gt; 对应的链接打开注册，以免错失了代金券。&lt;/p&gt;
    
    </summary>
    
      <category term="知识改变生活" scheme="https://www.playpi.org/categories/knowledge-for-life/"/>
    
    
      <category term="Vultr" scheme="https://www.playpi.org/tags/Vultr/"/>
    
      <category term="VPS" scheme="https://www.playpi.org/tags/VPS/"/>
    
      <category term="vps" scheme="https://www.playpi.org/tags/vps/"/>
    
      <category term="Shadowsocks" scheme="https://www.playpi.org/tags/Shadowsocks/"/>
    
      <category term="Affiliate" scheme="https://www.playpi.org/tags/Affiliate/"/>
    
      <category term="cloud" scheme="https://www.playpi.org/tags/cloud/"/>
    
  </entry>
  
  <entry>
    <title>番茄鸡蛋面做法总结 - 酸汤口味</title>
    <link href="https://www.playpi.org/2019072701.html"/>
    <id>https://www.playpi.org/2019072701.html</id>
    <published>2019-07-26T17:31:57.000Z</published>
    <updated>2019-07-28T17:31:57.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>面食是中国常见的一种传统主食，馒头、饼、包子、馍、面条、面叶，使用面粉做出来的类型多种多样。其中，<strong> 面条 </strong>可谓是最为流行，无论东北、西北、东南、西南、中原、华南，都可以看到 <strong>面条 </strong>身影，形式丰富，口味不一，这更是中华民族劳动人民智慧的结晶。</p><p>其中，<strong> 汤面 </strong>又是一派，汤面最重要的是什么，除了面条本身之外，最重要的是汤。而汤，是非常难做的，耗时长且配料讲究，不仅要选骨头，还要放大料，一般一锅好汤都要熬制两个小时以上，更甚者要熬制四个小时。一般家庭吃面条是不可能这么折腾的，那么我这里有一种更为简单的方法：使用番茄鸡蛋做酸汤，再配合面条，做一碗酸汤面。这种方法操作起来简单，耗时短，又能保留汤的美味，适合自己在家做，本文记录做法总结。</p><a id="more"></a><h1 id="引言"><a href="# 引言" class="headerlink" title="引言"></a>引言 </h1><p> 我在网络上看到全国很多卖的火爆的汤面，看自媒体介绍，看采访报道，都是注重讲究汤的制作，还自夸是祖传，几十年积累改良下来的，无论他们怎么说，这可见汤的重要性。</p><p>在广州的上下九、老西关，也各有一家不错的广式汤面，汤真的很不错，年头也比较久。</p><p>目前市面上为什么很多快餐店的汤面、汤粉都不好吃，就是汤不行。我记得小时候在江南一带生活过一段时间，那里的快餐店的外墙上都会印着 <strong>民以食为天、面以汤为鲜 </strong>作为广告语，而且他们的汤做的真不错，一碗简单的青菜面都很好吃，例如上海清汤面。另外他们的小馄饨也很好吃，也是取决于汤很好，不过现在很难找到这么好吃的了。</p><p>当然，也要考虑到成本，现在如果你舍得消费 40-50 元人民币去吃一碗面，在广州还是能找到比较美味的面的，比如上下九、老西关那两家，此外以前还有一家上海风味的店：<strong> 寻人启示 </strong>【在兆佳业广场，不知道现在还开不开】，味道也很正宗。</p><p>汤固然很重要，但是普通人在家里做面条，不可能耗费那么多精力去熬制一锅汤出来，熬出来只做几碗面也很浪费。此时，可以有两个选择：</p><p>一个是购买 <strong>号称高汤的调料 </strong>，也就是使用一些浓缩骨粉、香料、调料混合制成的面汤专用调料，煮面的时候放在水里，可以把面汤调制成美味鲜香的汤。我小时候用过，当时觉得挺好吃的，但是现在吃起来明显味道不对，而且我担心健康问题。</p><p>二是直接购买 <strong>浓缩高汤液体 </strong>，一般的冷藏的，号称使用原汤制作，买回来尽快使用，不宜旧存，价格比较高，而且我也担心健康问题。</p><p>除了这些有没有其他选择了呢，有，那就是我下面的重点，最简单的番茄鸡蛋汤。这种汤做法简单，汤味鲜美，用来下面最合适。</p><h1 id="食材准备"><a href="# 食材准备" class="headerlink" title="食材准备"></a>食材准备 </h1><p> 以下食材适合 2 人食用，我自己吃是直接吃了一盆：</p><ul><li>番茄 2 个，选择粉的，不要脆的 </li><li> 手工新鲜面条 1 斤，最好是刚做出来的湿面条，实在没有挂面也可以，挂面就用不了 1 斤，半斤足够 </li><li> 鸡蛋 1-2 个 </li><li> 食用盐 </li><li> 其它配菜任选，例如青菜、酱牛肉、榨菜、牛肉丸 </li></ul><p> 番茄 2 个 </p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190810222908.jpg" alt="番茄 2 个" title="番茄 2 个"></p><p> 手工湿面条 1 斤 </p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190810222918.jpg" alt="手工湿面条 1 斤" title="手工湿面条 1 斤"></p><h1 id="制作步骤"><a href="# 制作步骤" class="headerlink" title="制作步骤"></a> 制作步骤 </h1><p> 从食材准备到出锅装盘，大概需要 20 分钟即可。</p><h2 id="番茄去皮切丁"><a href="# 番茄去皮切丁" class="headerlink" title="番茄去皮切丁"></a>番茄去皮切丁 </h2><p> 番茄切十字花刀，把番茄放在沸水中煮 1 分钟，并使用勺子不断浇番茄上半部分，然后就很容易去皮了。去皮后切丁，放在盘子中备用。</p><p>番茄切丁 </p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190810223007.jpg" alt="番茄切丁" title="番茄切丁"></p><h2 id="番茄丁下油锅"><a href="# 番茄丁下油锅" class="headerlink" title="番茄丁下油锅"></a> 番茄丁下油锅 </h2><p> 如果有吃鸡蛋面汤的需求，先把鸡蛋炒好，捣碎备用，番茄炒好后再放进去，一起煮汤。但是我是直接吃煎蛋，所以这里不放鸡蛋了。</p><p>开锅，加花生油，烧热后加入切好的番茄丁，快速翻炒，大概炒 1-2 分钟，番茄丁会产生糊状的酱汁，就可以准备加水了。</p><p>炒制番茄丁 </p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190810223120.jpg" alt="炒制番茄丁" title="炒制番茄丁"></p><h2 id="加水煮沸"><a href="# 加水煮沸" class="headerlink" title="加水煮沸"></a> 加水煮沸 </h2><p> 立马加适量水，稍微搅拌一下，接着煮沸。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190810223144.jpg" alt="加水煮沸" title="加水煮沸"></p><h2 id="下面条"><a href="# 下面条" class="headerlink" title="下面条"></a>下面条 </h2><p> 汤煮沸后开始加面条，注意要一点一点加，并及时搅拌，否则面条很容易粘连，那一锅面条就废了，如果感觉水量不够要及时加水，不要犹豫。</p><p>下面条 </p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190810223241.jpg" alt="下面条" title="下面条"></p><p> 适当搅拌防止粘连 </p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190810223310.jpg" alt="适当搅拌防止粘连" title="适当搅拌防止粘连"></p><h2 id="煮沸后加冷水"><a href="# 煮沸后加冷水" class="headerlink" title="煮沸后加冷水"></a> 煮沸后加冷水 </h2><p> 接着就是等待煮沸，此时需要反复三次煮沸，第一次煮沸后稍微加一点冷水，防止冒锅，后两次煮沸只要打开锅盖散气即可。<strong> 注意，这时候别忘记加盐。</strong></p><p>第一次煮沸加冷水 </p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190810223336.jpg" alt="第一次煮沸加冷水" title="第一次煮沸加冷水"></p><h2 id="出锅装盆"><a href="# 出锅装盆" class="headerlink" title="出锅装盆"></a> 出锅装盆 </h2><p> 最终出锅，装盆，一盆香喷喷的酸汤面就做好了。</p><p>配上煎蛋，再切几个牛肉丸，人间美味。注意，我这不是普通的碗，我这是盆，这一盆吃下去我真的有点撑了。我一开始就不想混鸡蛋在里面，怕汤喝不完浪费了，于是只放了番茄做酸汤，另外煎了一个鸡蛋。</p><p>一大盆被我吃光 </p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190810223431.jpg" alt="一大盆被我吃光" title="一大盆被我吃光"></p><h2 id="其它方式"><a href="# 其它方式" class="headerlink" title="其它方式"></a> 其它方式 </h2><p> 如果觉得汤里少了点什么，也可以选择一开始炒鸡蛋捣碎，然后放入汤中。别小看简单的鸡蛋番茄，做出来的汤非常好喝，一口气我可以喝两碗。</p><p>锅里的样子 </p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190810223452.jpg" alt="锅里的样子" title="锅里的样子"></p><p> 出锅装盆的样子 </p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190810223504.jpg" alt="出锅装盆的样子" title="出锅装盆的样子"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项 </h1><p>1、番茄品种一定要选择 <strong> 粉 </strong>的，不要 <strong>脆 </strong>的，这样更容易熬制出美味的酸汤。</p><p>2、面条下锅后一定要迅速搅拌一下，防止面条粘连，特别是挂面，很容易就是一坨，导致里面的煮不熟。</p><p>3、关于面条的选择，我更倾向于选择手工湿面条，更好吃，挂面不好吃。</p><p>4、这种酸汤千万不要浪费，最好全喝了，营养又健康。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;面食是中国常见的一种传统主食，馒头、饼、包子、馍、面条、面叶，使用面粉做出来的类型多种多样。其中，&lt;strong&gt; 面条 &lt;/strong&gt;可谓是最为流行，无论东北、西北、东南、西南、中原、华南，都可以看到 &lt;strong&gt;面条 &lt;/strong&gt;身影，形式丰富，口味不一，这更是中华民族劳动人民智慧的结晶。&lt;/p&gt;&lt;p&gt;其中，&lt;strong&gt; 汤面 &lt;/strong&gt;又是一派，汤面最重要的是什么，除了面条本身之外，最重要的是汤。而汤，是非常难做的，耗时长且配料讲究，不仅要选骨头，还要放大料，一般一锅好汤都要熬制两个小时以上，更甚者要熬制四个小时。一般家庭吃面条是不可能这么折腾的，那么我这里有一种更为简单的方法：使用番茄鸡蛋做酸汤，再配合面条，做一碗酸汤面。这种方法操作起来简单，耗时短，又能保留汤的美味，适合自己在家做，本文记录做法总结。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="patato" scheme="https://www.playpi.org/tags/patato/"/>
    
      <category term="noodles" scheme="https://www.playpi.org/tags/noodles/"/>
    
      <category term="egg" scheme="https://www.playpi.org/tags/egg/"/>
    
      <category term="sugar" scheme="https://www.playpi.org/tags/sugar/"/>
    
  </entry>
  
  <entry>
    <title>git pull 失败：RPC failed;SSL_ERROR_SYSCALL errno 10054</title>
    <link href="https://www.playpi.org/2019072301.html"/>
    <id>https://www.playpi.org/2019072301.html</id>
    <published>2019-07-23T15:06:33.000Z</published>
    <updated>2019-07-23T17:06:33.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>众所周知，<code>Git</code> 是一款非常流行的版本控制工具，现在的项目开发基本都离不开它，否则项目的协作开发将寸步难行，甚至会有专门的项目管理职位来规范项目的开发协作。如果不使用 <code>Git</code>，我的博客整理工作也会增加难度与复杂度，不得不说，我已经离不开它了。今天碰到一个关于 <code>Git</code> 的很奇怪的错误，本文记录解决的过程，整理完感觉经验技能又增长了。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 我换了一台电脑，把项目代码下载下来，正常的 <code>clone</code> 后，一直使用，过了几天，突然出现下面的问题。</p><p>在使用 <code>git pull</code> 命令同步最新代码时报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: unpack-objects failed</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190724014935.png" alt="git pull 报错信息" title="git pull 报错信息"></p><p>我仔细观察了整个过程，一开始还是正常的，百分比进度在变化，然后就卡在那里一直不再动，最后就报错，紧接着 <code>pull</code> 流程被终止。</p><p>初步看起来像是网络不好或者文件内容太大导致的网络连接超时失败。</p><p>按照可能是网络问题这个方向，我重试了多次，全部都是 <code>git pull</code> 失败，然后我换成其它项目再做相同的操作就正常，我陷入了沉思：应该和环境无关，只和项目有关，这个 <code>git pull</code> 失败的项目到底有什么特殊之处。</p><p>突然，我一拍脑门，想起来了，这个项目前一天晚上被我 <code>commit</code> 了很多张图片，应该有 100 张以上，总计 <code>200MB</code> 大小，看来这是问题所在。</p><h1 id="问题分析解决"><a href="# 问题分析解决" class="headerlink" title="问题分析解决"></a>问题分析解决 </h1><p> 循着这个线索，使用报错关键词 <code>RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054</code> 去 <code>stackoverflow</code> 搜索一下，发现很多人都遇到过这个问题。原因在于 <code>http</code> 通信缓存设置的值太小，恰好我的项目是使用 <code>http</code> 协议进行 <code>pull</code> 的，而没有使用 <code>ssh</code> 的方式。</p><p>这时候的解决方式就是设置一下缓存大小，参数名为：<code>http.postBuffer</code>，把它的值设置大一点【注意它的单位是 B，字节，进位是 1024 制的】：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 500MB, 如果配合使用 --global 参数可以全局生效 </span><br><span class="line">git config http.postBuffer 524288000</span><br><span class="line"># 1GB</span><br><span class="line">git config http.postBuffer 1048576000</span><br></pre></td></tr></table></figure><p>根据官网对 <code>http.postBuffer</code> 这个参数的解释说明：</p><blockquote><p>Maximum size in bytes of the buffer used by smart HTTP transports when POSTing data to the remote system. For requests larger than this buffer size, HTTP/1.1 and Transfer-Encoding: chunked is used to avoid creating a massive pack file locally. Default is 1 MiB, which is sufficient for most requests.</p></blockquote><p>附官网链接：<a href="https://git-scm.com/docs/git-config" target="_blank" rel="noopener">https://git-scm.com/docs/git-config</a> ，参见对参数 <code>http.postBuffer</code> 的解释。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190724015009.png" alt="Git 官网对于缓存参数的解释说明" title="Git 官网对于缓存参数的解释说明"></p><p>可以看到这个参数的默认值为：<code>1 MiB</code>，对大部分项目都是合理的，但是对于我这个一次疯狂 <code>commit</code> 很多张图片的项目就无能为力了。</p><p>配置完成后，也可以在项目的 <code>.git/config</code> 配置文件中查看这个参数的信息【如果设置了全局生效，则需要在家目录中寻找这个配置文件，即 <code>home</code> 目录】。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">repositoryformatversion = 0</span><br><span class="line">filemode = false</span><br><span class="line">bare = false</span><br><span class="line">logallrefupdates = true</span><br><span class="line">symlinks = false</span><br><span class="line">ignorecase = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">url = https://github.com/iplaypi/sources-playpi.git</span><br><span class="line">fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">remote = origin</span><br><span class="line">merge = refs/heads/master</span><br><span class="line">[gui]</span><br><span class="line">wmstate = normal</span><br><span class="line">geometry = 1061x563+30+30 233 255</span><br><span class="line">[credential]</span><br><span class="line">helper = store</span><br><span class="line">[user]</span><br><span class="line">name = iplaypi</span><br><span class="line">email = playpi@qq.com</span><br><span class="line">[http]</span><br><span class="line">postBuffer = 524288000</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190724015105.png" alt="查看 Git 项目的配置信息" title="查看 Git 项目的配置信息"></p><p>好，接下来再进行 <code>pull</code> 操作，可以看到，最终正常了，没有再出问题【一开始我设置的是 500MB，还是不行，接着改为 1GB 就可以了】。由于网络速度问题或者中国大陆访问 <code>GitHub</code> 缓慢的原因，这次正常的 <code>pull</code> 使用了将近四十分钟才完成，等得我着急。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190724015342.png" alt="pull 正常同步更新" title="pull 正常同步更新"></p><p>可见，真的是我这个项目的内容太大了，同步的时候 <code>http</code> 通信缓存不足，导致出错。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结 </h1><p>1、此外，还有一个压缩参数：<code>core.compression</code>，可以用来设置压缩率，有 11 个取值。当然，如果把项目内容压缩了，由于压缩操作本身就会很耗时，会导致下载速度变慢，下载同步过程总的耗时也会随之增加。</p><p> 官网说明：</p><blockquote><p>An integer -1..9, indicating a default compression level. -1 is the zlib default. 0 means no compression, and 1..9 are various speed/size tradeoffs, 9 being slowest. If set, this provides a default to other compression variables, such as core.looseCompression and pack.compression.</p></blockquote><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190724015140.png" alt="Git 官网对于压缩参数的解释说明" title="Git 官网对于压缩参数的解释说明"></p><p>2、我当前使用的是 <code>http</code> 方式，其实还有一种 <code>ssh</code> 方式，更方便，可以试试。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;众所周知，&lt;code&gt;Git&lt;/code&gt; 是一款非常流行的版本控制工具，现在的项目开发基本都离不开它，否则项目的协作开发将寸步难行，甚至会有专门的项目管理职位来规范项目的开发协作。如果不使用 &lt;code&gt;Git&lt;/code&gt;，我的博客整理工作也会增加难度与复杂度，不得不说，我已经离不开它了。今天碰到一个关于 &lt;code&gt;Git&lt;/code&gt; 的很奇怪的错误，本文记录解决的过程，整理完感觉经验技能又增长了。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Git" scheme="https://www.playpi.org/tags/Git/"/>
    
      <category term="PRC" scheme="https://www.playpi.org/tags/PRC/"/>
    
      <category term="SSL" scheme="https://www.playpi.org/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>使用 Java 获取 HBase 中多版本数据的方法</title>
    <link href="https://www.playpi.org/2019071101.html"/>
    <id>https://www.playpi.org/2019071101.html</id>
    <published>2019-07-11T15:35:05.000Z</published>
    <updated>2019-08-11T15:35:05.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>最近工作比较繁忙，在处理需求、写代码的过程中踩到了一些坑，不过问题都被我一个一个解决了，所以最近三周都没有更新博客内容。不过，我是整理了提纲、打了草稿，近期会陆续整理出来。今天就先整理出来一个简单的知识点：使用 <code>Java API</code> 从 <code>HBase</code> 中获取多版本【Version 的概念】数据的方法，开发环境基于 <code>JDK v1.8</code>、<code>HBase v1.1.2</code>、<code>Zookeeper v3.4.6</code>，在演示过程中还会使用原生的 <code>HBase Shell</code> 进行配合，加深理解。</p><a id="more"></a><h1 id="入门概念"><a href="# 入门概念" class="headerlink" title="入门概念"></a>入门概念 </h1><p> 先列举一些关于 <code>HBase</code> 的基础概念，有助于继续阅读下文，如果不太了解需要先回顾一下：</p><ul><li>列式分布式数据库，基于 <code>Google BigTable</code> 论文开发，适合海量的数据存储 </li><li>Rowkey、Column Family、Qualifier、Timestamp、Cell、Version 的概念</li><li>HBase Shell、Java API、Phoenix</li></ul><h1 id="示例代码"><a href="# 示例代码" class="headerlink" title="示例代码"></a> 示例代码 </h1><p> 下面的演示会以 <code>HBase Shell</code>、<code>Java API</code> 这两种方式分别进行，便于读者理解。</p><h2 id="建表造数据"><a href="# 建表造数据" class="headerlink" title="建表造数据"></a>建表造数据 </h2><p> 为了使用 <code>Java API</code> 获取多版本数据，我要先做一些基础工作：创建表、造数据、造多版本数据。为了尽量简化数据的复杂度，以及能让读者理解，我准备了 2 条数据，下面使用一个表格来整理这 2 条数据，读者可以看得更清晰：</p><table><thead><tr><th style="text-align:center">Rowkey</th><th style="text-align:center">Column Family</th><th style="text-align:center">Qualifier</th><th style="text-align:center">Version</th><th style="text-align:center">Value</th></tr></thead><tbody><tr><td style="text-align:center">row01</td><td style="text-align:center">cf</td><td style="text-align:center">name</td><td style="text-align:center">1</td><td style="text-align:center">JIM</td></tr><tr><td style="text-align:center">row01</td><td style="text-align:center">cf</td><td style="text-align:center">name</td><td style="text-align:center">2</td><td style="text-align:center">Jack</td></tr><tr><td style="text-align:center">row02</td><td style="text-align:center">cf</td><td style="text-align:center">name</td><td style="text-align:center">1</td><td style="text-align:center">Lucy</td></tr><tr><td style="text-align:center">row02</td><td style="text-align:center">cf</td><td style="text-align:center">age</td><td style="text-align:center">1</td><td style="text-align:center">20</td></tr></tbody></table><p>从上表可以看出，一共 2 条数据，<code>row01</code> 有 1 列，2 个版本，<code>row02</code> 有 2 列，1 个版本。下面使用原生的 <code>HBase Shell</code> 开始逐步建表、造数据。</p><p>1、进入交互式客户端 </p><p> 使用 <code>hbase shell</code> 进入交互式客户端，在输出的日志中可以看到当前环境 <code>HBase</code> 的版本号。</p><p>登录成功后终端显示：</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190818192301.png" alt="登录成功" title="登录成功"></p><p>2、创建表：学生表 </p><p> 使用 <code>create &#39;TB_HBASE_STUDENT&#39;,&#39;cf&#39;</code> 创建一张表，为了便于后面的操作，表名最好使用大写形式，否则涉及到表名的操作需要加单引号。由于 <code>HBase</code> 是列式存储结构，所以创建表时不需要指定具体的列名称，只要指定 <code>Column Family</code> 名称即可。</p><p>执行后终端显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 row (s) in 2.5260 seconds</span><br><span class="line"> =&gt; Hbase::Table - TB_HBASE_STUDENT</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190818192317.png" alt="创建表" title="创建表"></p><p>3、查看表结构 </p><p> 使用 <code>describe &#39;TB_HBASE_STUDENT&#39;</code> 查看表结构，执行后终端显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Table TB_HBASE_STUDENT is ENABLED</span><br><span class="line">TB_HBASE_STUDENT</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &apos;cf&apos;, BLOOMFILTER =&gt; &apos;ROW&apos;, VERSIONS =&gt; &apos;1&apos;, IN_MEMORY =&gt; &apos;false&apos;, KEEP_DELETED_CELLS =&gt; &apos;FALSE&apos;, DATA_BLOCK_ENCODING =&gt; &apos;NONE&apos;, TTL =&gt; &apos;FOREVER&apos;, COMPRESSION =&gt; &apos;NONE&apos;, MIN_VERSIONS =&gt; &apos;0&apos;, BLOCKCACHE =&gt; &apos;true&apos;, BLOCKSIZE =&gt; &apos;65536&apos;, REPLICATION_SCOPE =&gt; &apos;0&apos;&#125;</span><br><span class="line">1 row (s) in 0.0390 seconds</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190818192331.png" alt="查看表结构" title="查看表结构"></p><p>可以看到表的基本信息，其中 <code>Column Family</code> 名称为 <code>cf</code>，最大版本 <code>VERSIONS</code> 为 1，这会导致只会存储一个版本的列数据，当再次插入数据的时候，后面的值会覆盖掉前面的值。</p><p>4、修改最大版本 </p><p> 为了满足我的需求，需要更改表，把 <code>cf</code> 的最大版本数 <code>VERSIONS</code> 增加，设置为 3 。使用 <code>alter &#39;TB_HBASE_STUDENT&#39;,{NAME=&gt;&#39;cf&#39;,VERSIONS=&gt;3}</code> 命令即可。执行后终端显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Updating all regions with the new schema...</span><br><span class="line">0/1 regions updated.</span><br><span class="line">1/1 regions updated.</span><br><span class="line">Done.</span><br><span class="line">0 row (s) in 3.7710 seconds</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190818192344.png" alt="修改最大版本数" title="修改最大版本数"></p><p>修改成功后，我使用 <code>describe &#39;TB_HBASE_STUDENT&#39;</code> 再次查看表结构，终端显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Table TB_HBASE_STUDENT is ENABLED</span><br><span class="line">TB_HBASE_STUDENT</span><br><span class="line">COLUMN FAMILIES DESCRIPTION</span><br><span class="line">&#123;NAME =&gt; &apos;cf&apos;, BLOOMFILTER =&gt; &apos;ROW&apos;, VERSIONS =&gt; &apos;3&apos;, IN_MEMORY =&gt; &apos;false&apos;, KEEP_DELETED_CELLS =&gt; &apos;FALSE&apos;, DATA_BLOCK_ENCODING =&gt; &apos;NONE&apos;, TTL =&gt; &apos;FOREVER&apos;, COMPRESSION =&gt; &apos;NONE&apos;, MIN_VERSIONS =&gt; &apos;0&apos;, BLOCKCACHE =&gt; &apos;true&apos;, BLOCKSIZE =&gt; &apos;65536&apos;, REPLICATION_SCOPE =&gt; &apos;0&apos;&#125;</span><br><span class="line">1 row (s) in 0.0380 seconds</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190818192357.png" alt="再次查看表结构" title="再次查看表结构"></p><p>这次可以看到，<code>VERSIONS =&gt; &#39;3&#39;</code> 表示 <code>cf</code> 已经支持存储 3 个版本的数据了。</p><p>5、插入 2 条数据 </p><p><code>HBase</code> 的插入数据功能是使用 <code>put</code> 命令，每次插入 1 列，根据上述表格数据格式，需要执行 4 次 <code>put</code> 操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">put &apos;TB_HBASE_STUDENT&apos;,&apos;row01&apos;,&apos;cf:name&apos;,&apos;JIM&apos;</span><br><span class="line">put &apos;TB_HBASE_STUDENT&apos;,&apos;row01&apos;,&apos;cf:name&apos;,&apos;Jack&apos;</span><br><span class="line">put &apos;TB_HBASE_STUDENT&apos;,&apos;row02&apos;,&apos;cf:name&apos;,&apos;Lucy&apos;</span><br><span class="line">put &apos;TB_HBASE_STUDENT&apos;,&apos;row02&apos;,&apos;cf:age&apos;,&apos;20&apos;</span><br></pre></td></tr></table></figure><p> 执行后终端显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.8.7-p357 :012 &gt;   put &apos;TB_HBASE_STUDENT&apos;,&apos;row01&apos;,&apos;cf:name&apos;,&apos;JIM&apos;</span><br><span class="line">0 row (s) in 0.1600 seconds</span><br><span class="line"></span><br><span class="line">1.8.7-p357 :013 &gt; put &apos;TB_HBASE_STUDENT&apos;,&apos;row01&apos;,&apos;cf:name&apos;,&apos;Jack&apos;</span><br><span class="line">0 row (s) in 0.0180 seconds</span><br><span class="line"></span><br><span class="line">1.8.7-p357 :014 &gt; put &apos;TB_HBASE_STUDENT&apos;,&apos;row02&apos;,&apos;cf:name&apos;,&apos;Lucy&apos;</span><br><span class="line">0 row (s) in 0.0160 seconds</span><br><span class="line"></span><br><span class="line">1.8.7-p357 :015 &gt; put &apos;TB_HBASE_STUDENT&apos;,&apos;row02&apos;,&apos;cf:age&apos;,&apos;20&apos;</span><br><span class="line">0 row (s) in 0.0180 seconds</span><br><span class="line"></span><br><span class="line">1.8.7-p357 :016 &gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190818192412.png" alt="插入 2 条数据" title="插入 2 条数据"></p><h2 id="命令行查看"><a href="# 命令行查看" class="headerlink" title="命令行查看"></a>命令行查看 </h2><p>1、先尝试使用 <code>get</code> 命令来获取这 2 条数据，分别执行 3 次 <code>get</code> 操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get &apos;TB_HBASE_STUDENT&apos;,&apos;row02&apos;,&apos;cf:name&apos;</span><br><span class="line">get &apos;TB_HBASE_STUDENT&apos;,&apos;row02&apos;,&apos;cf:age&apos;</span><br><span class="line">get &apos;TB_HBASE_STUDENT&apos;,&apos;row01&apos;,&apos;cf:name&apos;</span><br></pre></td></tr></table></figure><p> 执行后终端显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.8.7-p357 :026 &gt;   get &apos;TB_HBASE_STUDENT&apos;,&apos;row02&apos;,&apos;cf:name&apos;</span><br><span class="line">COLUMN                CELL</span><br><span class="line">cf:name               timestamp=1566118670447, value=Lucy</span><br><span class="line"></span><br><span class="line">1 row (s) in 0.0160 seconds</span><br><span class="line"></span><br><span class="line">1.8.7-p357 :027 &gt; get &apos;TB_HBASE_STUDENT&apos;,&apos;row02&apos;,&apos;cf:age&apos;</span><br><span class="line">COLUMN                CELL</span><br><span class="line">cf:age                timestamp=1566118677185, value=20</span><br><span class="line"></span><br><span class="line">1 row (s) in 0.0060 seconds</span><br><span class="line"></span><br><span class="line">1.8.7-p357 :028 &gt; get &apos;TB_HBASE_STUDENT&apos;,&apos;row01&apos;,&apos;cf:name&apos;</span><br><span class="line">COLUMN                CELL</span><br><span class="line">cf:name               timestamp=1566118661397, value=Jack</span><br><span class="line"></span><br><span class="line">1 row (s) in 0.0080 seconds</span><br><span class="line"></span><br><span class="line">1.8.7-p357 :029 &gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190818192431.png" alt="读取数据" title="读取数据"></p><p>可以看到，此时并没有获取到 <code>row01</code> 的 2 个版本的数据，只获取了最新版本的结果。</p><p>2、使用 <code>get</code> 获取多版本数据，执行 <code>get</code> 时需要加上 <code>VERSIONS</code> 相关的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get &apos;TB_HBASE_STUDENT&apos;,&apos;row01&apos;,&#123;COLUMN=&gt;&apos;cf:name&apos;,VERSIONS=&gt;3&#125;</span><br></pre></td></tr></table></figure><p>执行后终端显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.8.7-p357 :029 &gt; get &apos;TB_HBASE_STUDENT&apos;,&apos;row01&apos;,&#123;COLUMN=&gt;&apos;cf:name&apos;,VERSIONS=&gt;3&#125;</span><br><span class="line">COLUMN                CELL</span><br><span class="line">cf:name               timestamp=1566118661397, value=Jack</span><br><span class="line">cf:name               timestamp=1566118652009, value=JIM</span><br><span class="line"></span><br><span class="line">2 row (s) in 0.0140 seconds</span><br><span class="line"></span><br><span class="line">1.8.7-p357 :030 &gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190818192445.png" alt="读取多版本数据" title="读取多版本数据"></p><p>可以看到，2 个版本的数据都读取出来了。</p><p>3、使用 <code>scan</code> 扫描数据 </p><p> 此外还有一个 <code>scan</code> 命令可以扫描表中的数据，使用 <code>scan &#39;TB_HBASE_STUDENT&#39;,{LIMIT=&gt;5}</code> 尝试扫描 5 条数据出来。</p><p>执行后终端显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.8.7-p357 :031 &gt;   scan &apos;TB_HBASE_STUDENT&apos;,&#123;LIMIT=&gt;5&#125;</span><br><span class="line">ROW                   COLUMN+CELL</span><br><span class="line">row01                 column=cf:name, timestamp=1566118661397, value=Jack</span><br><span class="line">row02                 column=cf:age, timestamp=1566118677185, value=20</span><br><span class="line">row02                 column=cf:name, timestamp=1566118670447, value=Lucy</span><br><span class="line"></span><br><span class="line">2 row (s) in 0.0420 seconds</span><br><span class="line"></span><br><span class="line">1.8.7-p357 :032 &gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190818192456.png" alt="扫描数据" title="扫描数据"></p><p>由于表中只有 2 条数据，所以只显示出 2 条，而且 <code>scan</code> 默认也是获取最新版本的数据结果。</p><p>4、如果想退出 <code>HBase Shell</code> 交互式客户端，使用 <code>!quit</code> 命令即可。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190818192505.png" alt="退出客户端" title="退出客户端"></p><h2 id="代码示例"><a href="# 代码示例" class="headerlink" title="代码示例"></a>代码示例 </h2><p> 上面使用原生的 <code>HBase Shell</code> 操作演示了创建表、插入数据、读取数据的过程，下面将使用 <code>Java API</code> 演示读取数据的过程，而创建表、插入数据的过程就不再演示。</p><p>这里需要特别注意，为了正常使用 <code>Java API</code> 的相关接口，<code>Java</code> 项目需要依赖 <code>hbase-client</code>、<code>commons-configuration</code>、<code>hadoop-auth</code>、<code>hadoop-hdfs</code> 等组件。我的代码已经上传至 <code>GitHub</code>，详见：<a href="https://github.com/iplaypi/iplaypistudy/tree/master/iplaypistudy-hbase/src/main/java/org/playpi/study/test" target="_blank" rel="noopener">TestHBase.java</a> ，搜索类名 <code>TestHBase</code> 即可。</p><p>1、代码示例 </p><p> 代码结构比较简单，分为：构造查询请求、发送请求、解析结果输出几部分，注释中也注明了各个部分的作用，总计也就 50 行代码左右。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * HBase Java API Get 测试 </span><br><span class="line">     */</span><br><span class="line">public void testGet () &#123;</span><br><span class="line">String hTableName = &quot;TB_HBASE_STUDENT&quot;;</span><br><span class="line">IplaypiStudyConfig configuration = IplaypiStudyConfig.getInstance ();</span><br><span class="line">byte [] cfbyte = &quot;cf&quot;.getBytes ();</span><br><span class="line">byte [] col01byte = &quot;name&quot;.getBytes ();</span><br><span class="line">byte [] col02byte = &quot;age&quot;.getBytes ();</span><br><span class="line">try &#123;</span><br><span class="line">// 构造查询请求，2 条数据，多个版本 </span><br><span class="line">List&lt;Get&gt; getList = Lists.newArrayList ();</span><br><span class="line">Get get = new Get (Bytes.toBytes (&quot;row01&quot;));</span><br><span class="line">get.addColumn (cfbyte, col01byte);</span><br><span class="line">// 设置最大版本数，默认为 1</span><br><span class="line">get.setMaxVersions (3);</span><br><span class="line">getList.add (get);</span><br><span class="line">Get get2 = new Get (Bytes.toBytes (&quot;row02&quot;));</span><br><span class="line">get2.addColumn (cfbyte, col01byte);</span><br><span class="line">get2.addColumn (cfbyte, col02byte);</span><br><span class="line">getList.add (get2);</span><br><span class="line">// 发送请求，获取结果 </span><br><span class="line">HTable hTable = new HTable (configuration, hTableName);</span><br><span class="line">Result [] resultArr = hTable.get (getList);</span><br><span class="line">/**</span><br><span class="line">             * 以下有两种解析结果的方法 </span><br><span class="line">             * 1 - 通过 Result 类的 getRow () 和 getValue () 两个方法，只能获取最新版本 </span><br><span class="line">             * 2 - 通过 Result 类的 rawCells () 方法返回一个 Cell 数组，可以获取多个版本 </span><br><span class="line">             * 注意，高版本不再建议使用 KeyValue 的方式，注释中有说明 </span><br><span class="line">             */</span><br><span class="line">// 1-</span><br><span class="line">log.info (&quot;====get result by first method&quot;);</span><br><span class="line">for (Result result : resultArr) &#123;</span><br><span class="line">log.info (&quot;&quot;);</span><br><span class="line">log.info (&quot;--------&quot;);</span><br><span class="line">String rowStr = Bytes.toString (result.getRow ());</span><br><span class="line">log.info (&quot;====row:[&#123;&#125;]&quot;, rowStr);</span><br><span class="line">// 如果包含 name 列，则获取输出 </span><br><span class="line">if (result.containsColumn (cfbyte, col01byte)) &#123;</span><br><span class="line">String valStr = Bytes.toString (result.getValue (cfbyte, col01byte));</span><br><span class="line">log.info (&quot;====name:[&#123;&#125;],getValue&quot;, valStr);</span><br><span class="line">// 以下方式不建议使用，但是可以获取多版本 </span><br><span class="line">List&lt;KeyValue&gt; keyValueList = result.getColumn (cfbyte, col01byte);</span><br><span class="line">for (KeyValue keyValue : keyValueList) &#123;</span><br><span class="line">log.info (&quot;====name:[&#123;&#125;],getColumn -&gt; getValue&quot;, Bytes.toString (keyValue.getValue ()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果包含 age 列，则获取输出 </span><br><span class="line">if (result.containsColumn (cfbyte, col02byte)) &#123;</span><br><span class="line">String valStr = Bytes.toString (result.getValue (cfbyte, col02byte));</span><br><span class="line">log.info (&quot;====age:[&#123;&#125;],getValue&quot;, valStr);</span><br><span class="line">// 以下方式不建议使用，但是可以获取多版本 </span><br><span class="line">List&lt;KeyValue&gt; keyValueList = result.getColumn (cfbyte, col02byte);</span><br><span class="line">for (KeyValue keyValue : keyValueList) &#123;</span><br><span class="line">log.info (&quot;====age:[&#123;&#125;],getColumn -&gt; getValue&quot;, Bytes.toString (keyValue.getValue ()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 2-</span><br><span class="line">log.info (&quot;&quot;);</span><br><span class="line">log.info (&quot;====get result by second method&quot;);</span><br><span class="line">for (Result result : resultArr) &#123;</span><br><span class="line">log.info (&quot;&quot;);</span><br><span class="line">log.info (&quot;--------&quot;);</span><br><span class="line">String rowStr = Bytes.toString (result.getRow ());</span><br><span class="line">log.info (&quot;====row:[&#123;&#125;]&quot;, rowStr);</span><br><span class="line">//name 列 </span><br><span class="line">List&lt;Cell&gt; cellList = result.getColumnCells (cfbyte, col01byte);</span><br><span class="line">// 1 个 cell 就是 1 个版本 </span><br><span class="line">for (Cell cell : cellList) &#123;</span><br><span class="line">// 高版本不建议使用 </span><br><span class="line">log.info (&quot;====name:[&#123;&#125;],getValue&quot;, Bytes.toString (cell.getValue ()));</span><br><span class="line">//getValueArray: 数据的 byte 数组 </span><br><span class="line">//getValueOffset:rowkey 在数组中的索引下标 </span><br><span class="line">//getValueLength:rowkey 的长度 </span><br><span class="line">String valStr = Bytes.toString (cell.getValueArray (), cell.getValueOffset (), cell.getValueLength ());</span><br><span class="line">log.info (&quot;====name:[&#123;&#125;],[getValueArray,getValueOffset,getValueLength]&quot;, valStr);</span><br><span class="line">log.info (&quot;====timestamp:[&#123;&#125;],cell&quot;, cell.getTimestamp ());</span><br><span class="line">&#125;</span><br><span class="line">//age 列不演示了，省略...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e) &#123;</span><br><span class="line">log.error (&quot;!!!!error: &quot; + e.getMessage (), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、运行结果 </p><p> 执行运行，可以看到结果输出，与数据表中一致，多版本数据结果也可以全部获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:58: ====get result by first method</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:60: </span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:61: --------</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:63: ====row:[row01]</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:67: ====name:[Jack],getValue</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:71: ====name:[Jack],getColumn -&gt; getValue</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:71: ====name:[JIM],getColumn -&gt; getValue</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:60: </span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:61: --------</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:63: ====row:[row02]</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:67: ====name:[Lucy],getValue</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:71: ====name:[Lucy],getColumn -&gt; getValue</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:77: ====age:[20],getValue</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:81: ====age:[20],getColumn -&gt; getValue</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:86: </span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:87: ====get result by second method</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:89: </span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:90: --------</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:92: ====row:[row01]</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:98: ====name:[Jack],getValue</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:103: ====name:[Jack],[getValueArray,getValueOffset,getValueLength]</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:104: ====timestamp:[1566118661397],cell</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:98: ====name:[JIM],getValue</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:103: ====name:[JIM],[getValueArray,getValueOffset,getValueLength]</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:104: ====timestamp:[1566118652009],cell</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:89: </span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:90: --------</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:92: ====row:[row02]</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:98: ====name:[Lucy],getValue</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:103: ====name:[Lucy],[getValueArray,getValueOffset,getValueLength]</span><br><span class="line">2019-08-18_17:54:18 [main] INFO test.TestHBase:104: ====timestamp:[1566118670447],cell</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190818192521.png" alt="Java 程序运行结果" title="Java 程序运行结果"></p><h1 id="备注"><a href="# 备注" class="headerlink" title="备注"></a>备注 </h1><p>1、在使用 <code>Java API</code> 时注意低版本、高版本之间的差异，必要时及时升级，就像上文代码中的 <code>Result.getColumn</code>、<code>KeyValue.getValue ()</code>、<code>Cell.getValue ()</code> 这几个方法。</p><p>2、<code>Phoenix</code> 是一款基于 <code>HBase</code> 的工具，在 <code>HBase</code> 之上提供了 <code>OLTP</code> 相关的功能，例如完全的 <code>ACID</code> 支持、<code>SQL</code>、二级索引等，此外 <code>Phoenix</code> 还提供了标准的 <code>JDBC</code> 的 <code>API</code>。在使用 <code>Phoenix</code> 时，可以很方便地像操作 <code>SQL</code> 那样操作 <code>HBase</code>。</p><p> 使用 <code>Phoenix</code> 创建表、查询数据示例如图。</p><p>创建表，使用：<br><code>CREATE TABLE IF NOT EXISTS TB_HBASE_STUDENT (&quot;pk&quot;varchar primary key,&quot;cf&quot;.&quot;name&quot;varchar,&quot;cf&quot;.&quot;age&quot;varchar);</code></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190818192546.png" alt="使用 Phoenix 创建表" title="使用 Phoenix 创建表"></p><p>查询示例，使用：<br><code>select * from&quot;TB_HBASE_STUDENT&quot;limit 5;</code></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190818192540.png" alt="使用 Phoenix 查询" title="使用 Phoenix 查询"></p><p>3、本示例的代码放在 <code>GirHub</code>，详见：<a href="https://github.com/iplaypi/iplaypistudy/tree/master/iplaypistudy-hbase/src/main/java/org/playpi/study/test" target="_blank" rel="noopener">TestHBase.java</a> ，搜索类名 <code>TestHBase</code> 即可。参考 <code>GitHub</code> 的代码时，注意在 <code>iplaypistudy-common-config</code> 模块中增加自己的配置文件，如果开发环境的版本不匹配，也要升级版本，在 <code>pom.xml</code> 更改即可。</p><p>4、想要使用 <code>HBase Shell</code> 删除表时，必须先使用 <code>disable YOUR_TABLE_NAME</code> 来禁用表，然后再使用 <code>drop YOUR_TABLE_NAME</code> 删除表，直接删除表是不被允许的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近工作比较繁忙，在处理需求、写代码的过程中踩到了一些坑，不过问题都被我一个一个解决了，所以最近三周都没有更新博客内容。不过，我是整理了提纲、打了草稿，近期会陆续整理出来。今天就先整理出来一个简单的知识点：使用 &lt;code&gt;Java API&lt;/code&gt; 从 &lt;code&gt;HBase&lt;/code&gt; 中获取多版本【Version 的概念】数据的方法，开发环境基于 &lt;code&gt;JDK v1.8&lt;/code&gt;、&lt;code&gt;HBase v1.1.2&lt;/code&gt;、&lt;code&gt;Zookeeper v3.4.6&lt;/code&gt;，在演示过程中还会使用原生的 &lt;code&gt;HBase Shell&lt;/code&gt; 进行配合，加深理解。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据技术知识" scheme="https://www.playpi.org/categories/big-data-technical-knowledge/"/>
    
    
      <category term="Java" scheme="https://www.playpi.org/tags/Java/"/>
    
      <category term="HBase" scheme="https://www.playpi.org/tags/HBase/"/>
    
      <category term="version" scheme="https://www.playpi.org/tags/version/"/>
    
  </entry>
  
  <entry>
    <title>记录一次 AbstractMethodError 异常</title>
    <link href="https://www.playpi.org/2019070401.html"/>
    <id>https://www.playpi.org/2019070401.html</id>
    <published>2019-07-04T15:19:13.000Z</published>
    <updated>2019-07-04T15:19:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>场景描述：在某一天我觉得我的 Java 项目的依赖太冗余了，决定删除一些无用的依赖，让整个项目瘦身，以后打包发布的时候也更快速、节省时间。</p><p>接着我按照自己的经验，把大部分依赖全部删除，此时编译会报一些错误，这是必然的，但是我不担心，根据报错信息把缺失的依赖再一个一个添加进来即可。忙活了一阵，终于解决了所有的报错，编译、打包一气呵成，不再有错误，看了一下打包后的文件大小，足足比原先小了 30%，我略感满意。</p><p>但是此时我仍旧悬着一颗心，因为编译、打包成功不代表什么，后面的运行才是大问题，运行时往往会暴露一些隐藏的问题。而且项目里面有好几个功能，只要有一个功能运行失败那就说明依赖还是有问题，改造不成功。【千万不要以为编译、打包成功就万事大吉了，运行时的异常才是大问题，一定要有未雨绸缪的准备】</p><p>果然，刚启动第一个功能就出现了我想象中的异常信息：<code>java.lang.AbstractMethodError</code>。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 异常突然出现，我差点就懵了，昨天还好好的，今天怎么就这样了，程序又不是女朋女，不可能说变就变。此时，我又想起了一个段子，程序员的一般心里活动：运行失败了，这 TM 怎么可能会失败呢？运行成功了，这 TM 怎么就成功了呢？</p><p>作为一名资深的工程师，我还是决定试试，看看能不能走个狗屎运，于是我在本机、测试环境、正式环境分别做了测试，发现都是报一样的错误，接着我就意识到问题的严重性，不能再心存侥幸，要拿出我真实的技术来说话了。</p><p>前面的处理方式就像重启系统一样，只不过是碰运气的方式，我连报错信息都没有仔细看，接下来就要认真处理了。</p><p>既然报错了，那就耐心查看，<strong> 办法总比困难多 </strong>。下面列出完整的错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">2019-07-04_20:05:26 [main] INFO yarn.Client:58: Application report for application_1561431414509_0020 (state: ACCEPTED)</span><br><span class="line">2019-07-04_20:05:26 [shuffle-server-2] ERROR server.TransportRequestHandler:191: Error sending result RpcResponse&#123;requestId=5206989806485258134, body=NioManagedBuffer&#123;buf=java.nio.HeapByteBuffer [pos=0 lim=47 cap=47]&#125;&#125; to dev6/172.18.5.206:55124; closing connection</span><br><span class="line">java.lang.AbstractMethodError</span><br><span class="line">at io.netty.util.ReferenceCountUtil.touch (ReferenceCountUtil.java:73)</span><br><span class="line">at io.netty.channel.DefaultChannelPipeline.touch (DefaultChannelPipeline.java:107)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext.write (AbstractChannelHandlerContext.java:810)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext.write (AbstractChannelHandlerContext.java:723)</span><br><span class="line">at io.netty.handler.codec.MessageToMessageEncoder.write (MessageToMessageEncoder.java:111)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0 (AbstractChannelHandlerContext.java:738)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext.invokeWrite (AbstractChannelHandlerContext.java:730)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext.write (AbstractChannelHandlerContext.java:816)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext.write (AbstractChannelHandlerContext.java:723)</span><br><span class="line">at io.netty.handler.timeout.IdleStateHandler.write (IdleStateHandler.java:302)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext.invokeWrite0 (AbstractChannelHandlerContext.java:738)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext.invokeWrite (AbstractChannelHandlerContext.java:730)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext.access$1900 (AbstractChannelHandlerContext.java:38)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write (AbstractChannelHandlerContext.java:1089)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write (AbstractChannelHandlerContext.java:1136)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run (AbstractChannelHandlerContext.java:1078)</span><br><span class="line">at io.netty.util.concurrent.AbstractEventExecutor.safeExecute (AbstractEventExecutor.java:163)</span><br><span class="line">at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks (SingleThreadEventExecutor.java:403)</span><br><span class="line">at io.netty.channel.nio.NioEventLoop.run (NioEventLoop.java:462)</span><br><span class="line">at io.netty.util.concurrent.SingleThreadEventExecutor$5.run (SingleThreadEventExecutor.java:858)</span><br><span class="line">at java.lang.Thread.run (Thread.java:748)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190704232421.png" alt="报错日志" title="报错日志"></p><p>其中，重点只需要看这几行内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-07-04_20:05:26 [shuffle-server-2] ERROR server.TransportRequestHandler:191: Error sending result RpcResponse&#123;requestId=5206989806485258134, body=NioManagedBuffer&#123;buf=java.nio.HeapByteBuffer [pos=0 lim=47 cap=47]&#125;&#125; to dev6/172.18.5.206:55124; closing connection</span><br><span class="line">java.lang.AbstractMethodError</span><br><span class="line">at io.netty.util.ReferenceCountUtil.touch (ReferenceCountUtil.java:73)</span><br><span class="line">at io.netty.channel.DefaultChannelPipeline.touch (DefaultChannelPipeline.java:107)</span><br></pre></td></tr></table></figure><p>我定睛一瞧，<code>AbstractMethodError</code> 这种异常类型我还没见过，这怎么行，抓紧去查了 Java 的官方文档，查过之后，才明白这个异常的含义。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190704232219.png" alt="AbstractMethodError 文档" title="AbstractMethodError 文档"></p><p>官方定义内容如下：</p><blockquote><p>Thrown when an application tries to call an abstract method. Normally, this error is caught by the compiler; this error can only occur at run time if the definition of some class has incompatibly changed since the currently executing method was last compiled.</p></blockquote><p>大概意思就是说 Java 程序在 <strong>运行时 </strong>发现 <strong>方法的定义 </strong>与 <strong>编译时 </strong>的不一致，怎么会有这种现象呢，最大的可能也就是依赖冲突了，至于为何造成冲突，还需要进一步检查。</p><p>我又回过头去仔细看一下这个功能的前后逻辑，很简单，只是使用 <code>Spark</code> 处理 <code>HDFS</code> 里面的数据，然后把处理结果再写回到 <code>HDFS</code>，实际运行时处理的数据量也不大，看起来不会有功能性的问题。而且，前不久这个功能还运行的好好的，只在我重构更改后才起不来的，原因基本可以定位在依赖方面：冲突、缺失。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><p> 顺着依赖冲突这个突破点看下去，可能是因为我在清理依赖时把某个依赖清除掉了，然后又自己添加一个不同版本的，导致与原先的依赖版本不匹配。而且看到异常信息里面都是和 <code>netty</code> 有关的，可以猜测可能是 <code>netty</code> 的相关依赖出问题了。</p><p>接着再多看一点点异常信息，还发现有一些额外的有效信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">2019-07-04_20:05:23 [main] INFO spark.SecurityManager:58: SecurityManager: authentication disabled; ui acls disabled; users with view permissions: Set (Administrator, dota); users with modify permissions: Set (Administrator, dota)</span><br><span class="line">2019-07-04_20:05:23 [main] INFO yarn.Client:58: Submitting application 20 to ResourceManager</span><br><span class="line">2019-07-04_20:05:23 [main] INFO impl.YarnClientImpl:274: Submitted application application_1561431414509_0020</span><br><span class="line">2019-07-04_20:05:24 [main] INFO yarn.Client:58: Application report for application_1561431414509_0020 (state: ACCEPTED)</span><br><span class="line">2019-07-04_20:05:24 [main] INFO yarn.Client:58: </span><br><span class="line"> client token: N/A</span><br><span class="line"> diagnostics: N/A</span><br><span class="line"> ApplicationMaster host: N/A</span><br><span class="line"> ApplicationMaster RPC port: -1</span><br><span class="line"> queue: default</span><br><span class="line"> start time: 1562241921232</span><br><span class="line"> final status: UNDEFINED</span><br><span class="line"> tracking URL: http://dev6:8088/proxy/application_1561431414509_0020/</span><br><span class="line"> user: dota</span><br><span class="line">2019-07-04_20:05:29 [main] INFO yarn.Client:58: Application report for application_1561431414509_0020 (state: ACCEPTED)</span><br><span class="line">2019-07-04_20:05:30 [main] INFO yarn.Client:58: Application report for application_1561431414509_0020 (state: ACCEPTED)</span><br><span class="line">2019-07-04_20:05:31 [main] INFO yarn.Client:58: Application report for application_1561431414509_0020 (state: ACCEPTED)</span><br><span class="line">2019-07-04_20:05:32 [main] INFO yarn.Client:58: Application report for application_1561431414509_0020 (state: FAILED)</span><br><span class="line">2019-07-04_20:05:32 [main] INFO yarn.Client:58: </span><br><span class="line"> client token: N/A</span><br><span class="line"> diagnostics: Application application_1561431414509_0020 failed 2 times due to AM Container for appattempt_1561431414509_0020_000002 exited with  exitCode: 10</span><br><span class="line">For more detailed output, check application tracking page:http://dev6:8088/cluster/app/application_1561431414509_0020Then, click on links to logs of each attempt.</span><br><span class="line">Diagnostics: Exception from container-launch.</span><br><span class="line">Container id: container_e19_1561431414509_0020_02_000001</span><br><span class="line">Exit code: 10</span><br><span class="line">Stack trace: ExitCodeException exitCode=10: </span><br><span class="line">at org.apache.hadoop.util.Shell.runCommand (Shell.java:576)</span><br><span class="line">at org.apache.hadoop.util.Shell.run (Shell.java:487)</span><br><span class="line">at org.apache.hadoop.util.Shell$ShellCommandExecutor.execute (Shell.java:753)</span><br><span class="line">at org.apache.hadoop.yarn.server.nodemanager.DefaultContainerExecutor.launchContainer (DefaultContainerExecutor.java:212)</span><br><span class="line">at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call (ContainerLaunch.java:303)</span><br><span class="line">at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call (ContainerLaunch.java:82)</span><br><span class="line">at java.util.concurrent.FutureTask.run (FutureTask.java:266)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run (Thread.java:748)</span><br></pre></td></tr></table></figure><p>从上文的日志信息来看，程序的 <code>Driver</code> 端已经提交了 <code>Spark</code> 任务到 <code>Yarn</code> 集群，然后 <code>Yarn</code> 集群分配了资源，但是在后续的通信过程中，不知道哪里出问题了，导致通信中断，进而导致 <code>Spark</code> 任务失败。</p><p>结合上面我猜测的和 <code>netty</code> 依赖有关，那就从这里入手吧，先把项目的依赖树梳理出来，使用 <code>mvn dependency:tree &gt; tree.txt</code>，把依赖树的信息保存在文件 <code>tree.txt</code> 中，然后在依赖树信息中搜索 <code>netty</code>。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190704232242.png" alt="搜索 netty 关键字" title="搜索 netty 关键字"></p><p>可以看到关于 <code>netty</code> 依赖的信息。</p><p>再全局搜索一下项目中的类【在 Windows 下使用 Eclipse 模式的快捷键 <code>Ctrl + Shift + t</code>】，异常信息对应的那个类：<code>ReferenceCountUtil</code>，可以看到存在两个同名的类：类名称一致【都是 ReferenceCountUtil】，包名称一致【都是 io.netty.util】，只不过对应的 jar 包依赖不一致，一个是 <code>io.netty:netty-common:4.1.13.Final.jar</code>【这个是我的 org.elasticsearch.client:transport:5.5.0 传递依赖过来的】，另一个是 <code>io.netty:netty-all:4.0.29.Final.jar</code>【这个是 Spark 自带的，只不过我重新指定了版本】，这两个类肯定会冲突的。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190704232137.png" alt="搜索 ReferenceCountUtil 类" title="搜索 ReferenceCountUtil 类"></p><p>解决办法很简单，直接去除多余的依赖即可，但是要注意去除后会不会引发其它的依赖缺失问题。我在我的项目里面移除了所有的 <code>io.netty:netty-*</code> 依赖，这些依赖也是传递过来的，版本都为 <code>v4.1.13</code>，如下图：</p><p>如果不全部移除而是选择只移除 <code>netty-common</code>，还会有问题，因为这些依赖之间也互相依赖，看 <code>common</code> 这个命名就知道了，这就是：<strong> 一荣俱荣，一损俱损 </strong>。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190718231720.png" alt="移除所有的 netty 传递依赖" title="移除所有的 netty 传递依赖"></p><p>我把这些依赖移除后，<code>netty</code> 相关的依赖冲突就没有问题了，但是又遇到了一个小问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassNotFoundException: org.elasticsearch.spark.rdd.EsPartition</span><br></pre></td></tr></table></figure><p><code>Spark</code> 任务正常启动后，运行过程中出现了上述错误，导致 <code>Spark</code> 任务失败，乍一看是类缺失。但是如果在项目中搜索的话，也能搜索到这个类，是不是觉得很奇怪。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190718233540.png" alt="搜索缺失的 ESPartition 类" title="搜索缺失的 ESPartition 类"></p><p>其实不要多想，这个是典型的 <code>Yarn/Spark</code> 集群环境问题，项目中使用的 jar 包【特定版本的，我这里是：org.elasticsearch.client:transport:jar:5.5.0】在集群环境中没有，如果切换一个集群环境中存在版本就可以了【例如 v5.6.8】。或者一定要使用这个版本的话，就把这个 jar 包复制到 <code>Yarn/Spark</code> 集群环境每台机器的 <code>lib</code> 库中去。但是一般情况下，公司的环境是统一的，会避免使用多版本的依赖，以免引起一连串的未知冲突问题，浪费大家的时间。</p><p>在实际生产环境中，可能还会遇到一个更加糟糕的问题，即项目本身的依赖非常混乱，并且有大量的重复，可能去除一个还有一个，会造成大量重复的工作，所以在查看依赖树时可以使用 <code>-Dverbose</code> 参数，完整的命令：<code>mvn dependency:tree -Dverbose &gt; tree.txt</code>，把原始的所有传递依赖全部列出来，这样就可以对症操作，一次性把所有依赖移除。</p><p>当然，会有人觉得这样操作也是很麻烦，能不能来个插件，直接配置一下即可，至于去除的操作过程我也不关心，只要能帮我去除就行。当然，这对于想偷懒并提高效率的技术人员来说是必备的，这个东西就是插件 <code>maven-shade-plugin</code>。</p><p>在 <code>configuration</code> 里面配置 <code>artifactSet -&gt; excludes -&gt; exclude -&gt; jar 包坐标 </code> 即可。</p><p> 但是要注意，插件要使用高版本的：<code>v3.1.0</code>，我一开始使用的是 <code>v2.4.3</code>，怎么配置都无效，搞了半天发现低版本不支持。此外，还要注意 JDK 的版本也要 <code>v1.8+</code>，这样才能保证使用其它的特性，例如打包压缩：<code>&lt;minimizeJar&gt;true&lt;/minimizeJar&gt;</code>。使用这个参数可以自动把无用的依赖 jar 排除掉，给代码瘦身，同时也节约打包时间，非常好用。我的 jar 在使用打包压缩参数后，由原本的 313MB 被压缩到了 191MB，压缩率超过 30%，我觉得非常好用。</p><p>此外，<code>maven-shade-plugin</code> 插件是一款非常优秀的插件，最常用的莫过于 <strong>影子别名 </strong>功能，对于复杂的依赖冲突解决有奇效。例如对于上面的依赖冲突问题，可以不用找原因一点一点解决，直接使用 <strong>影子别名 </strong>功能把传递依赖的 <code>netty</code> jar 包改个名字即可，这样它们就可以共存了，简单粗暴却有奇效。推荐大家使用，这里不再赘述。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结 </h1><p> 总结一下问题，就是同名的类存在了不同版本的 jar 包中，等到运行的时候，Java 虚拟机发现异常，便抛出异常信息，停止运行程序。</p><p>此外，在没有十足的把握或者时间人力不充足的情况下，千万不要想着重构代码，后果你不一定能承担，带来的好处可能大于带来的灾难，这也叫 <strong>好心办坏事 </strong>。</p><p>再回顾一下，我这个问题是 <code>Spark</code> 任务运行在 <code>Yarn</code> 集群上面才发现的，如果使用 <code>local</code> 模式运行 <code>Spark</code> 任务是不会有问题的。所以当时出问题后我也是疑惑，反复测试了好几次才敢确认，主要是因为使用 <code>Yarn</code> 模式时，同时也会使用集群中提供的 jar 包依赖，如果项目本身打包时又打进了相同的 jar 包，就极有可能引发冲突【版本不一致，而且 <code>netty</code> 包的冲突本身就是一个大坑】。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;场景描述：在某一天我觉得我的 Java 项目的依赖太冗余了，决定删除一些无用的依赖，让整个项目瘦身，以后打包发布的时候也更快速、节省时间。&lt;/p&gt;&lt;p&gt;接着我按照自己的经验，把大部分依赖全部删除，此时编译会报一些错误，这是必然的，但是我不担心，根据报错信息把缺失的依赖再一个一个添加进来即可。忙活了一阵，终于解决了所有的报错，编译、打包一气呵成，不再有错误，看了一下打包后的文件大小，足足比原先小了 30%，我略感满意。&lt;/p&gt;&lt;p&gt;但是此时我仍旧悬着一颗心，因为编译、打包成功不代表什么，后面的运行才是大问题，运行时往往会暴露一些隐藏的问题。而且项目里面有好几个功能，只要有一个功能运行失败那就说明依赖还是有问题，改造不成功。【千万不要以为编译、打包成功就万事大吉了，运行时的异常才是大问题，一定要有未雨绸缪的准备】&lt;/p&gt;&lt;p&gt;果然，刚启动第一个功能就出现了我想象中的异常信息：&lt;code&gt;java.lang.AbstractMethodError&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑系列" scheme="https://www.playpi.org/categories/series-of-fixbug/"/>
    
    
      <category term="Java" scheme="https://www.playpi.org/tags/Java/"/>
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="netty" scheme="https://www.playpi.org/tags/netty/"/>
    
      <category term="AbstractMethodError" scheme="https://www.playpi.org/tags/AbstractMethodError/"/>
    
  </entry>
  
  <entry>
    <title>郴州东江湖之行</title>
    <link href="https://www.playpi.org/2019062301.html"/>
    <id>https://www.playpi.org/2019062301.html</id>
    <published>2019-06-23T15:46:43.000Z</published>
    <updated>2019-06-23T15:46:43.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>从 2019 年 06 月 21 日 18:30 点到 2019 年 06 月 23 日 18:30 点，我与公司部门的同事们进行了一次为期两天两夜的郴州东江湖之旅，一行总共 25 人，其中还有两位同事的老家就在东江湖周边，这也为此次旅途带来了一些特别的安排。以前每天在喧嚣的城市中工作，面对的都是闪烁霓虹的高楼大厦，车水马龙的街道，现在选择一个合适的时间点，为自己放一个小假，去拥抱大自然的风光，走走路动动腿，看看山山水水。本文简单记录这次旅途的过程，仅为存念，请读者跟着我的文字，带你们领略 <strong>小东江 </strong>自然风光的旖旎。</p><p>注意，本文图片较多，我已经尽量把每张图片都压缩在几百 KB 的大小，浏览时请耐心等待。</p><a id="more"></a><h1 id="出发"><a href="# 出发" class="headerlink" title="出发"></a>出发 </h1><h2 id="去程记录"><a href="# 去程记录" class="headerlink" title="去程记录"></a> 去程记录 </h2><p>2019 年 06 月 21 日 18:00，大家开始吃晚饭或者零食，补充体力，我吃了一份简单的盒饭、一个粽子、一杯酸奶，算是勉强吃饱。</p><p> 我的晚饭 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190703002916.jpg" alt="我的晚饭" title="我的晚饭"></p><p> 接着从公司出发，四人组队打车去 <strong>广州南站 </strong>，由于是在下班期间，而且还是在周五，所以路上难免堵车，我们也预估了时间，提前出发，以免迟到而赶不上车。打出租车不好打，网约车也不好叫，我们等了十几分钟才坐上车，我选择了走高速，因为之前已经咨询过同事，走高速不会堵车的，只有高速出口会堵一会。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190717000630.png" alt="去程地图导航" title="去程地图导航"></p><p>从上车到到达，全程消耗了 45 分钟，加上等车的十几分钟，总共一个小时的时间，顺利提前到达 <strong>广州南站 </strong>。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190717000754.png" alt="去程打车详情" title="去程打车详情"></p><p>由于提前到达了高铁站，还需要等待 40 分钟，才能进站乘车。还有一些没吃晚饭的同事们去找吃的了，我就留在长凳上照看行李。中途我还去周围逛了一下，发现便利店的饮料真的贵，和火车上的价格差不多了，这比上海火车站可差远了。我在上海火车站候车室见到的快餐店、便利店、奶茶店，不仅种类繁多，价格也和外面平常的店铺一样，只贵了一点点。<br>广州南站便利店饮料价目表 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190703002932.jpg" alt="广州南站便利店饮料价目表" title="广州南站便利店饮料价目表"></p><p> 时间走到了 20:40，终于可以上车了，坐高铁前往郴州，整个过程大概一个半小时，预计 22:10 到达 <strong>郴州西站 </strong>。在高铁上，大家有的看电影，有的玩游戏，有的玩手机，全程轻松愉悦，不必细说。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190703002947.jpg" alt="上了高铁出发" title="上了高铁出发"></p><p>22:10 顺利到达 <strong>郴州西站 </strong>，我们换乘预定的大巴，紧接着前往住宿地点，大概 23:30 到达住宿地点。</p><h2 id="关于交通工具的选择"><a href="# 关于交通工具的选择" class="headerlink" title="关于交通工具的选择"></a>关于交通工具的选择 </h2><p> 如果坐高铁，全程换乘两次，转车也痛苦，并没有节约时间，但是对于晕车的人来说是首选。如果坐大巴，可以从公司门口出发，直接开往目的地，但是也要 5 个小时以上，坐大巴的好处是不用换乘，上车就睡，直接到达目的地，但是有些人可能会晕车。</p><p>总的来说，从广州到郴州 <strong>东江湖 </strong>，全程要 5-6 个小时，我们是 18:30 出发，23:30 到达住宿地。</p><p>是的，就是需要这么久，主要是 <strong>广州高铁站 </strong>离出发地、<strong> 郴州西高铁站 </strong>离目的地都太远了，下了班打的去 <strong>广州高铁站 </strong>将近一个小时【25 公里】，到了 <strong>郴州西高铁站 </strong>再坐大巴去景区住宿地也要一个小时【40 公里】，晚上郴州的大巴是限速的，最高 40km / 小时。</p><p>我在高铁上和一个郴州本地人聊天，他说去 <strong>东江湖 </strong>游玩千万不要住太远，如果住市区的话，早上要起的很早赶过去，太累了。看来我们一开始就选择住在景区门口【从住宿地出来走路 2 分钟就到景区大门口】还是明智的，住的这么近还要在 05:45 起床，06:00 吃早餐，06:10 出发，否则赶不上看 <strong>小东江 </strong>的雾景了【07:00 左右景色最好】。可以想象，如果住在市区，早上五点前就要起床了吧。</p><h1 id="到达"><a href="# 到达" class="headerlink" title="到达"></a>到达 </h1><p> 折腾了五个小时，转了两次车【打的转高铁，高铁转大巴】，终于到达了住宿地点【东江芳鑫酒店】，开始分房间，领了钥匙，坐下来聊聊天、喝几口水。接着看到有同事拎着一篮子杨梅，在分发，我上前问了问，原来是大哥的表妹【我们公司 CTO 旭日大哥的表妹，接送我们，并协助我们全程游玩】专门带来给我们品尝的，从她家的果园刚刚摘出来，我吃了几个，不得不说，真好吃，放在嘴里咬一口，杨梅汁渗出来，酸酸甜甜，这才是正宗的杨梅。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190714222847.jpg" alt="新鲜的杨梅真好吃" title="新鲜的杨梅真好吃"></p><p>此时已经 23:40 了，我们是真的疲惫，但是又感到饥饿，于是想着出去逛逛，吃点宵夜。问了几个人，果然也有想出去吃点东西的人，于是我们一合计，就一起出去吃宵夜吧。凑了八九个人，就一起出去了，其中包括旭日大哥，我一想坏了，肯定又少不了喝酒吃肉，今天的睡眠时间注定不足了。</p><p>由熟悉地形的同事【家就在附近】带我们来到一个叫做 <strong>吊桥 </strong>的地方，他说这里有整条街的大排档，通常到夜里一两点仍旧人声鼎沸。听着这个描述，我感觉与住宿周围的环境形成鲜明的对比，因为住宿周围基本没有人出来活动，除了路灯，所有地方基本都是漆黑一片。</p><p>步行大概十几分钟，转了一个弯，突然霓虹闪烁、人声鼎沸，聊天的声音、吵闹的声音、商家宣传的声音不绝于耳，行人、车辆来来往往，感觉是到了另外一个世界。旭日大哥先带我们来到江边吹风，给我们介绍 <strong>吊桥 </strong>，没错，它是一个标准的小桥，只不过在这个时间被封路了，不能上去，我们只能站在旁边观看、吹风。</p><p>其实，周围漆黑一片，啥也看不清，只能吹吹风。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190714223133.jpg" alt="在吊桥江边吹风" title="在吊桥江边吹风"></p><p>稍微休息了一会儿，我们就选定了一家大排档，开吃开喝。当然，基本所有的菜都是辣的，特意叮嘱了服务员不要放那么多辣，毕竟在场的广东人居多。</p><p>点了两斤小龙虾，买二送一。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190714223207.jpg" alt="两斤小龙虾" title="两斤小龙虾"></p><p>这里的啤酒是以桶为单位的，一桶五公斤，我们一群人喝了两桶，当然我由于过敏没喝。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190714223229.jpg" alt="珠江啤酒一桶五公斤" title="珠江啤酒一桶五公斤"></p><p>聊天吹水，吃饱喝足，结账走人。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721023017.jpg" alt="吃饱喝足" title="吃饱喝足"></p><p>接着回住宿点，往回走，此时已经第二天凌晨 01:30，路上也没人了，只有我们一群孤单的身影。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190714223334.jpg" alt="回去酒店的路上" title="回去酒店的路上"></p><p>回到酒店，已经 01:40，洗漱完毕，看到桌子上还剩下一些杨梅，为了不浪费，我又吃了一些杨梅，一口气吃了十几个。由于刚刚吃过宵夜，又吃了杨梅，一开始睡不着，熬到凌晨 02:30 才睡着。</p><p>我觉得这真的是作，只能睡三个小时了，不知道第二天还能不能起来，体力还能不能跟得上。</p><p>住了一晚，第二天【06 月 22 日】早上 05:30 起床，我多睡了十分钟，最后还是坚持起床了，因为其他人都已经出发了，我是最后一个。到旁边的早餐店吃早餐：鱼粉、鸡蛋、咸菜，说真的，鱼粉虽然材料简单，味道真不错，吃完早餐，准备上山【景点都在高处】。</p><p>步行几分钟，就到了景区的大门口，住得近就是好，走两步就到。注意图中，我们有人拉着行李箱过来玩的。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190714223406.jpg" alt="景区大门口" title="景区大门口"></p><h1 id="小东江"><a href="# 小东江" class="headerlink" title="小东江"></a>小东江 </h1><p> 进了景区的大门，接着就是乘坐大巴上山，当然你也可以选择步行，但是距离太远了，如果不是特意为了徒步锻炼还是坐大巴上去吧【就像在韶关丹霞山，可以选择徒步爬上去而不坐大巴也不坐缆车】。大概十分钟左右，就可以到达 <strong>小东江 </strong>景点。</p><p>刚下车，我就被眼前的景色惊到了，同时旁边有一群游客大姐特别激动，不断地发出惊讶的表情与赞美之声，场面一度非常欢乐。</p><p><strong>小东江 </strong>是东江湖的一条支流，岸边有几公里的人行道，可以散步，看 <strong>雾漫小东江 </strong>的景色。中途还会有延伸到江心的平台，可以近距离感受小东江的雾气，以及拍照留念。</p><p>先放出来几张图：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190715010459.jpg" alt="雾漫小东江之一" title="雾漫小东江之一"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190715010528.jpg" alt="雾漫小东江之二" title="雾漫小东江之二"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190715010539.jpg" alt="雾漫小东江之三" title="雾漫小东江之三"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190715010552.jpg" alt="雾漫小东江之四" title="雾漫小东江之四"></p><p>为了配合游客拍照，景点特意安排工作人员驾小舟在江心撒网捕鱼，当然，只是做动作，并不是真的捕鱼，主要就是为了配合游客拍照。我拿着一个相机竟然不会使用连拍功能，还是旁边的大叔提醒我：不使用连拍你怎么可能拍得到想要的画面，我当场查看了相机的所有设置，也没有找到连拍的设置在哪，最后只能悻悻地走了。</p><p>请看下图，靠我眼疾手快拍到的：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190715011242.jpg" alt="撒网之一" title="撒网之一"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190715011253.jpg" alt="撒网之二" title="撒网之二"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190715011313.jpg" alt="撒网之三" title="撒网之三"></p><p>在江心的平台上稍作休息，我第一次拿起了自拍杆，试拍效果。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190715012623.jpg" alt="我第一次拿起了自拍杆" title="我第一次拿起了自拍杆"></p><p>可以看到环境监测大屏显示的环境信息，空气质量超级好，温度适宜，湿度太高【大雾的原因】，负氧离子超级多，停下来每呼吸一口，感觉都是赚的。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190715012640.jpg" alt="环境监测大屏" title="环境监测大屏"></p><p>这条线路如果慢慢走，边走边赏景、边拍照，可以走大概两个小时。如果不是特别沉迷其中，没有必要走完全程，因为看到的景色都差不多，而且随着时间的消逝，雾气也会渐渐消散，后面就没有什么看头了。再者，还要适当保存体力进行后面的活动，不能在一个景点中消耗过多的时间。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190715011737.jpg" alt="人行道上面的游客" title="人行道上面的游客"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190717002354.jpg" alt="人行道上的阶梯" title="人行道上的阶梯"></p><p>前后算起来，我们徒步了大概一个多小时，最后在一个江心平台合照留念，996 专属团队，引起了路人的围观。蹲在 C 位拿着白色自拍杆的就是我。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190715012652.jpg" alt="团队合照留念" title="团队合照留念"></p><h1 id="龙景峡谷"><a href="# 龙景峡谷" class="headerlink" title="龙景峡谷"></a>龙景峡谷 </h1><p> 看完小东江雾景，我们来到一个中途服务点，稍作休息，此处有水果、饮料、小吃出售。</p><p>休息几分钟，接着坐车前往 <strong>龙景峡谷 </strong>，当然你也可以选择步行过去【去的路途中我看到有人背着包在步行】，但是实在是太远了，而且没有行人徒步专用道，都是直接走在机动车道上，太危险。</p><p>让人意外的是，第一辆车来到很快就坐满了【51 座的大巴，来到时上面已经有部分游客，应该是从上一个服务点过来的】，我们还有几个人没有上去，只好选择等待下一班车。但是，下一班车竟然是公交车，而且人已经满了，我们还是硬挤上去了，没想到在山上挤了一趟公交车。</p><p>我上车就来一张自拍，纪念一下山上的公交车。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190717003028.jpg" alt="挤山上的公交车" title="挤山上的公交车"></p><p>坐车大概十几分钟，我们来到了 <strong>龙景峡谷 </strong>入口处的游客服务中心，准备进入游览。</p><p><strong>龙景峡谷 </strong>，其实就是一个峡谷，顺带有一座小山可以爬，爬的过程中可以看到小瀑布、周围的风景。围绕着小山的阶梯绕一圈，全程大概四十分钟。</p><p>在爬山图中，看到了小瀑布，很对得起这个 <strong>小 </strong>字。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190717012231.jpg" alt="小瀑布" title="小瀑布"></p><p>在山上的某个角落看看山下的景色。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720224515.jpg" alt="山上一角的景色" title="山上一角的景色"></p><p>接着全程就很热了，太阳很晒，没有风，衣服基本被汗水浸透。而且，我还背着重重的背包，非常消耗体力，我还一路奇怪，我只睡了三个小时，是怎么坚持得了的。</p><p>从山上下来后，经过 <strong>浮桥 </strong>，也就是一些空桶做成的水中走道，可以从上面走过去。由于天气太热，可以看到上面基本没人，但是为了不虚此行，我们几个人还是冒着烈日上去走了一趟，上去之前我穿上了防晒衣。</p><p>浮桥的场景，看看这天气有多热。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190717010920.jpg" alt="浮桥的场景 1" title="浮桥的场景 1"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190717010937.jpg" alt="浮桥的场景 2" title="浮桥的场景 2"></p><p>在浮桥上，转头又看到一个小瀑布。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190717010900.jpg" alt="又一个小瀑布" title="又一个小瀑布"></p><p>从 <strong>龙景峡谷 </strong>下来后，回到入口，此时全身都湿透了，汗水哗哗地往下流。我们买了饮料、雪糕，给自己降降温。</p><p>没想到我们几个人是率先下山的，四人组自拍，这镜头显胖。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190717010824.jpg" alt="四人组率先归来" title="四人组率先归来"></p><p>接着我们几个人就先回到游客中心，在大厅等着其他人回来，准备一起坐船去 <strong>兜率岛 </strong>。</p><p>我在游客中心洗了脸，衣服全部湿透了，看看我背后的风景，再看看懵逼的我。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190717011134.jpg" alt="游客中心的某个角落" title="游客中心的某个角落"></p><h1 id="兜率岛灵岩溶洞"><a href="# 兜率岛灵岩溶洞" class="headerlink" title="兜率岛灵岩溶洞"></a>兜率岛灵岩溶洞 </h1><p> 等人全部到齐后，我们一起坐游船前往 <strong>兜率岛【读音 Doushuai，但门票上印的却是 Tushi】</strong>，沿途风景很好，还可以穿上救生衣，走上甲板，吹吹风，无论是近处还是远处的景色都一览无余，尽收眼底。</p><p><strong>兜率岛 </strong>是东江湖中的一座岛，总面积 5.6 平方公里，也是湖南第一大岛，岛上山清水秀，景色宜人。有人形容东江湖的景象：<strong> 山中有湖，湖中有岛，岛上有庙，庙里有洞，洞中有洞 </strong>，这里的岛就是 <strong>兜率岛 </strong>。</p><p>走到这里，必须要把行程路线说明一下，我们购买的是 <strong>精品线路 2</strong> 通票，等坐游船前往 <strong>兜率岛 </strong>玩一圈后，理论上就应该返程了，因为已经把所有景点全部游览一遍。但是我们不走一般的路线，后面还会有自由行路线，这全靠大哥的表妹在安排。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720174908.jpg" alt="门票上的游玩线路图" title="门票上的游玩线路图"></p><p>坐船出发啦，在游船起步的几分钟内，可以看到 <strong>东江大坝 </strong>。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720175614.JPG" alt="坐船出发" title="坐船出发"></p><p>在坐船的过程中，我只顾着看风景、拍视频了，基本没有拍照片，可惜不能把大好河山展现出来。坐船过程大概 20 分钟。</p><p>船上的小伙伴，可能是刚刚在 <strong>龙景峡谷 </strong>太累了，或者是晕船，坐下来就不想动了。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720231555.jpg" alt="坐船的小伙伴" title="坐船的小伙伴"></p><p>甲板上的小伙伴，连带后面的风景。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720231624.jpg" alt="甲板上的小伙伴" title="甲板上的小伙伴"></p><p>此情此景，老大们怎能不登场。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720231632.jpg" alt="老大们登场" title="老大们登场"></p><p>游船大概行驶 20 分钟后，到达 <strong>兜率岛 </strong>。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720231640.jpg" alt="到达兜率岛" title="到达兜率岛"></p><p>先随便来两张照片看看这里的秀丽风景。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720231731.jpg" alt="辽阔的景色 1" title="辽阔的景色 1"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720231745.jpg" alt="辽阔的景色 2" title="辽阔的景色 2"></p><p>由于有人把票弄丢了，几个人陪着在补票，所以没跟着同一艘船过来，我们一群人要等着他们。看到有人在卖水果，老大请客，先买西瓜吃。由于路途劳顿，汗水流出来了，再看着这切开的西瓜，口水又流出来了。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720231830.jpg" alt="准备买西瓜" title="准备买西瓜"></p><p>看着这一群吃瓜群众，在这个时刻吃上一块西瓜，简直就是人生中一大幸福事。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720232005.jpg" alt="吃瓜群众" title="吃瓜群众"></p><p>吃好后，后面的几个人也来到了，我们先休息一会儿。此时此刻，我们多数人已经很累了，坐在地上不想动，也不想说话，有些人已经表现出一副生无可恋的样子。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720232033.jpg" alt="南国明珠东江湖" title="南国明珠东江湖"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720232105.jpg" alt="坐在地上休息一会" title="坐在地上休息一会"></p><p>休息好后，我们开始前往 <strong>灵岩溶洞 </strong>，从大门入口处走几十个台阶就是溶洞的入口，观赏全程大概 30-40 分钟。<strong> 灵岩溶洞 </strong>又是一处神奇的景色，它处在一座庙中，里面的钟乳石光怪陆离、千姿百态、变化莫测，看了让人叹为观止。走在里面，一会儿迂回狭窄，一会儿豁然开朗，周围的环境怪石嶙峋、冷风习习，一会儿让人毛骨悚然，一会儿让人震撼不已。</p><p>溶洞的入口小门：<strong> 福地洞天 </strong>。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720232158.jpg" alt="溶洞的入口小门" title="溶洞的入口小门"></p><p>刚刚走进去的时候，就感觉到凉风习习，阴森森的，有人惊叹：是不是开空调啦！</p><p>不得不说，<strong> 灵岩溶洞 </strong>里面真是凉快，温度估计 20 摄氏度都不到，而且有风，里面绝对没有开空调、放冷气之类的，全部是自然的凉爽，但是确实有点冷。在行走的过程中，洞顶会有水滴滴下来，简直是冰水滴，滴下来很冷，如果你用手摸一下路边的石头，也是很冰的。</p><p>至于景观，主要是一些钟乳石、笋石、石柱，在五颜六色的灯光的照射下，显示出各种形态。当然，最终你看到的是什么全靠自己的想象，因为解说员在整个过程中重复了好多次：三分神似，七分想象，不同的人眼里看到的是不同的形态。在这里面拍照也是拍不清，一片漆黑，灯光太暗，除了石头上面会打一些光。</p><p>不信？来，看看这些都是什么，我反正是看不出来。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720232224.jpg" alt="溶洞的钟乳石 1" title="溶洞的钟乳石 1"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720232237.jpg" alt="溶洞的钟乳石 2" title="溶洞的钟乳石 2"></p><p>一路走下来，我就一个感觉：真是太凉快了，把整个人的温度都降下来了，出去的时候，眼镜瞬间被蒙了一层水雾，可见里外的温差有多大。在里面走的久了，我就觉得此地不宜久留，疲惫加上饥饿，如果再被冷气压制一下，很担心下一步就感冒。所以加快步伐，想快点出去。</p><p>总结一下：洞内真的像一个天然的冰箱，非常的凉爽，特别是在出洞口，从洞内一阵阵凉风刮来，纯天然空调啊，站在洞口让人挪不开脚步。不过这样的巨大温差，如果还站在洞口直接吹冷风，估计很容易就感冒了，反正我是吹了一会就站的远一点，不敢吹了。</p><p>我们几个人出来后，发现很多人还没出来，只好坐在路边，边休息边等。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720232313.jpg" alt="坐在出口吹风等待" title="坐在出口吹风等待"></p><p>有几个人在门口吹风，试图自拍：<strong> 道法自然 </strong>。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190720232324.jpg" alt="在出口吹风自拍" title="在出口吹风自拍"></p><p><strong>灵岩溶洞 </strong>观赏结束后，所有人到齐，我们将要前往 <strong>水上乐园 </strong>。</p><h1 id="水上乐园"><a href="# 水上乐园" class="headerlink" title="水上乐园"></a>水上乐园 </h1><p><strong> 水上乐园 </strong>本来是为游客开发的水上项目，可以在这里体验各种项目的玩法，例如 <strong>水上摩托艇 </strong>、<strong> 香蕉船 </strong>，当然是要额外收费的。由于时间点不合适，我们也没有提前安排这类活动，所以没有关心具体的项目。</p><p>给大家看一下 <strong>兜率岛 </strong>的地图指引，了解一下 <strong>水上乐园 </strong>的位置，其实它就在 <strong>返程码头 </strong>的旁边。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721030229.jpg" alt="兜率岛地图指引" title="兜率岛地图指引"></p><p>从 <strong>灵岩溶洞 </strong>走过去，大概十几分钟，而且路上有树荫有风，不是很热。沿途风光大好，美不胜收，随便拍一张照片都是壮阔的景色。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721030239.jpg" alt="随便拍一张壮阔的景色" title="随便拍一张壮阔的景色"></p><p>如果按照正常的官方线路图，到这里已经结束了，可以直接在 <strong>返程码头 </strong>乘坐游船返程，还不耽误回去吃午饭。但是我们至此才开始自由行，由大哥的表妹安排，先在 <strong>水上乐园 </strong>门口乘坐自己租的小船，前往我们预定的 <strong>东江湖避暑休闲农庄 </strong>，在那里度过下午和明天。</p><p>在 <strong>水上乐园 </strong>门口，有很多卖特产的，水果、鱼干、烤鱼，可以买来吃。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721030245.JPG" alt="水上乐园门口" title="水上乐园门口"></p><h1 id="直奔东江湖避暑休闲农庄"><a href="# 直奔东江湖避暑休闲农庄" class="headerlink" title="直奔东江湖避暑休闲农庄"></a>直奔东江湖避暑休闲农庄 </h1><p> 一开始我们走错路了，直接走到 <strong>返程码头 </strong>了，以为会在那里上船。其实不是，而是在另外一个简陋的停靠点，算不上码头，大家依次上小船。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721182527.JPG" alt="大家依次上小船" title="大家依次上小船"></p><p>上了小船，先来一张自拍合照。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721182555.jpg" alt="自拍合照" title="自拍合照"></p><p>在柴油机的轰隆声，大概过了二十分钟，我们到达了 <strong>休闲农庄 </strong>。给大家看一下地图，<strong> 休闲农庄 </strong>的位置，它的所在地其实是一个半岛，如果从另外一个方向过去是可以直接开车的，但是从我们这个方向【兜率岛的位置】过去只能坐船。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721182628.png" alt="半岛上的农庄" title="半岛上的农庄"></p><p>到了休闲农庄，时间大概是 12:00，我们大部分人又累又饿，已经不想动了。在等午饭的过程中，我就躺在沙发上立即睡着了，大概迷迷糊糊睡了十几分钟。</p><p>到达农庄里的小宿舍，我在二楼看风景。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721183852.jpg" alt="我在二楼看风景" title="我在二楼看风景"></p><p>这里设施很齐全，有乒乓球桌、K 歌设备、麻将桌、吊床、躺椅、游泳池、自家果园，大家可以在这里面朝大湖，谈笑风声。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721182658.jpg" alt="面朝大湖谈笑风生" title="面朝大湖谈笑风生"></p><h1 id="吃午饭自由活动"><a href="# 吃午饭自由活动" class="headerlink" title="吃午饭自由活动"></a>吃午饭自由活动 </h1><p> 终于等到开饭了，时间大概是 13:00，非常丰盛，非常好吃，大家饱餐一顿。</p><p>吃完午饭，时间大概是 14:00，大家自由活动，可以回房间休息，可以去游泳，可以打牌，可以到周围逛一逛。</p><p>我实在是太累了，不想动了，把换掉的衣服简单洗了一下，然后就准备睡觉了。</p><p>衣服刚洗完，到走廊外面晾衣服，突然发现烈日消失了，天空开始出现了乌云，大风也刮起来了，看来是要下雨了，那些出去逛的小伙伴也要回来了吧。</p><p>用下面的几张照片来多角度展现当时的情景，乌云密布，简直就是 <strong>黑云压城城欲摧，山雨欲来风满楼 </strong>。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721191705.jpg" alt="乌云密布 1" title="乌云密布 1"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721191728.jpg" alt="乌云密布 2" title="乌云密布 2"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721191740.jpg" alt="乌云密布 3" title="乌云密布 3"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721191751.jpg" alt="乌云密布 4" title="乌云密布 4"></p><p>我下楼看了看，看着这湖里逐渐泛起了波浪，远处的乌云也已经压过来，一场风雨不可避免了。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721191837.jpg" alt="湖中的波浪" title="湖中的波浪"></p><p>接着我就撑不住了，回到房间倒在床上就睡着了，时间大概是 15:30。</p><h1 id="吃晚饭自由活动"><a href="# 吃晚饭自由活动" class="headerlink" title="吃晚饭自由活动"></a>吃晚饭自由活动 </h1><p> 我一觉睡了三个小时，到 18:30 才醒来，而且睡得很稳，睡眠质量超级好。接着刚洗漱完毕就听到有人喊下楼吃晚饭，时间大概是 19:00。</p><p>吃完晚饭又是自由活动，还有一部分人在玩喝酒游戏，还有两条大黄狗在趴着。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721191916.jpg" alt="吃完晚饭喝酒的人" title="吃完晚饭喝酒的人"></p><p>大部分人还是很累就回去继续休息了，准备明天的活动，剩下的人在 K 歌、打麻将、游泳、逗狗。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721191951.jpg" alt="K 歌的人" title="K 歌的人"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721191959.jpg" alt="打麻将的人" title="打麻将的人"></p><p>此时，吹着微风，听着水声，让人有一种 <strong>面朝大海，唱 K 打牌 </strong>的错觉。</p><p>大家玩到 00:00 左右，陆续有人回去休息了。</p><p>我大概 03:30 才睡，主要是下午睡太久了，睡不着，再加上聊天、唱歌、吃东西，变得有点亢奋。虽然身体上很累，但是精神上有点亢奋，回顾这一天的活动，真的感觉累成狗，还好现在年轻，还能撑得住。</p><p>看，农庄的两条大黄狗都困得不行，不理我们了。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721192041.jpg" alt="看狗困的 1" title="看狗困的 1"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721192051.jpg" alt="看狗困的 2" title="看狗困的 2"></p><h1 id="游泳晨跑去果园"><a href="# 游泳晨跑去果园" class="headerlink" title="游泳晨跑去果园"></a>游泳晨跑去果园 </h1><p> 第三天的早上我们定的行程是 09:00 出发，因为要坐船、坐大巴前往 <strong>郴州火车站 </strong>【预计两个小时】，赶 12:10 的火车，还要吃午饭。</p><p>本来是早上 07:00 吃早餐，然后自由活动，大家可以去跑步、逛果园、游泳，但是我太累了，早上醒来看到外面又在下雨，于是接着睡了。当然，他们大部分人还是起来了，进行各自的活动，只有包括我在内的几个人在睡觉。</p><p>我大概在 08:30 起床，然后被人催着吃早饭，啥也没玩，听说早上一直在下小雨，导致小部分人没起床，也就是直接睡到了饭点。</p><p>虽然下着小雨，风景还是不错，几个人在乡间的小路上跑步。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721192140.jpg" alt="早晨的风景 1" title="早晨的风景 1"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721192147.jpg" alt="早晨的风景 2" title="早晨的风景 2"></p><p>吃完早饭，09:00，大家收拾东西返程，准时出发，去赶火车。我们在返程的小船上再来一张合照。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190721192155.jpg" alt="返程合照" title="返程合照"></p><h1 id="返程"><a href="# 返程" class="headerlink" title="返程"></a>返程 </h1><p> 说真的，不知道为啥，吃早餐的时候天气还不错，然后从上船那一刻起，雨就变大了。在船上下雨，换乘大巴还在下雨，整个返程的路上一直在下雨，但是到了火车站雨就停了。</p><p>经过两个小时的舟车劳顿，我们大概在 11:20 到了 <strong>郴州火车站 </strong>，由于经费紧张，我们回程是坐普通火车，没有再坐高铁，预计需要四个半小时，在 16:40 可以到达 <strong>广州东站 </strong>，反正时间也比较充足。</p><p>到了火车站，大家各自吃午饭，或者买点零食、饮料带着。我和几个人一起去找了一个小店【佳兴鱼粉】，我吃了 <strong>招牌黄鸭叫鱼粉 </strong>，香辣口味的，真的有鱼，味道很好，汤很鲜。吃了一半我觉得有点辣也有点热，就配了一根油条，不得不说，人间美味。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190722010843.jpg" alt="美味的招牌黄鸭叫鱼粉" title="美味的招牌黄鸭叫鱼粉"></p><p>临走时，发现店里的 <strong>香辣猪脚 </strong>【或者叫猪蹄】才十二块钱一只，忍不住买了一只打包带着，准备在火车上吃。不得不说，真的买对了，太好吃了，比广州的还好吃。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190722010853.jpg" alt="美味的香辣猪脚" title="美味的香辣猪脚"></p><p>有一些小伙伴准时进站后，发现火车晚点了 20 分钟，然后先到的小伙伴就在群里通知了大家，让大家吃午饭的的速度慢下来，不要着急。</p><p><strong>郴州火车站 </strong>的车站面积很小，安检、检票、进站全程不到五分钟。</p><p>插播一个小意外，我在候车室拍视频，持续拍了几分钟，然后被工作人员拦下来，他拦了一下我的手机，提示我说：<strong> 收起来，在这里不要乱拍 </strong>。在我专心寻找画面的时候，这突如其来的提醒着实把我吓了一跳。</p><h1 id="到达广州"><a href="# 到达广州" class="headerlink" title="到达广州"></a>到达广州 </h1><p> 经过四个半小时的火车旅途，我们到达 <strong>广州东站 </strong>，由于火车晚点了二十分钟，我们到达火车站的时间大概是 17:00 。没想到刚出火车站，就是狂风大作、乌云密布，看样子又是一场暴风雨。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190722010904.jpg" alt="火车站的狂风乌云" title="火车站的狂风乌云"></p><p>由于住的地方离地铁站比较远，我一看这天气等会步行也不太方便，决定坐公交回去。在火车站广场走了一圈，发现以前的公交站消失了，取而代之的是一片施工围栏。我跟着人流走了一会，发现公交站搬迁了，原来的公交站位置被围栏围起来，听说在修地铁站。新的公交站在草暖公园，以前是常规的停车场，不过距离有点远，估计步行要十分钟以上。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190722010913.jpg" alt="新公交站在草暖公园" title="新公交站在草暖公园"></p><p>都已经走了这么远，也不能回去坐地铁，看着天气也快下雨了，于是加快步伐走向公交站，在路上看到几乎所有人都在奔跑。果然，刚到公交站，暴雨就来了，还好我已经上车了。</p><p>顺利到家，到家一下子就放松了。</p><h1 id="终结"><a href="# 终结" class="headerlink" title="终结"></a>终结 </h1><p> 此刻放下打字的键盘，需要好好休息，明天又要开始拿起打代码的键盘，回归工作。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;从 2019 年 06 月 21 日 18:30 点到 2019 年 06 月 23 日 18:30 点，我与公司部门的同事们进行了一次为期两天两夜的郴州东江湖之旅，一行总共 25 人，其中还有两位同事的老家就在东江湖周边，这也为此次旅途带来了一些特别的安排。以前每天在喧嚣的城市中工作，面对的都是闪烁霓虹的高楼大厦，车水马龙的街道，现在选择一个合适的时间点，为自己放一个小假，去拥抱大自然的风光，走走路动动腿，看看山山水水。本文简单记录这次旅途的过程，仅为存念，请读者跟着我的文字，带你们领略 &lt;strong&gt;小东江 &lt;/strong&gt;自然风光的旖旎。&lt;/p&gt;&lt;p&gt;注意，本文图片较多，我已经尽量把每张图片都压缩在几百 KB 的大小，浏览时请耐心等待。&lt;/p&gt;
    
    </summary>
    
      <category term="游玩" scheme="https://www.playpi.org/categories/have-for-fun/"/>
    
    
      <category term="Hunan" scheme="https://www.playpi.org/tags/Hunan/"/>
    
      <category term="Chenzhou" scheme="https://www.playpi.org/tags/Chenzhou/"/>
    
      <category term="fun" scheme="https://www.playpi.org/tags/fun/"/>
    
  </entry>
  
  <entry>
    <title>记一次愚蠢的 HBase 错误</title>
    <link href="https://www.playpi.org/2019061701.html"/>
    <id>https://www.playpi.org/2019061701.html</id>
    <published>2019-06-17T15:07:49.000Z</published>
    <updated>2019-06-18T15:07:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>最近在整理一个单独的 Maven 项目，是从其它项目迁移过来的，主要存放的是和业务强相关的代码，略显混乱的代码是必不可少的，我的职责就是把现存的代码抽象出来，尽量删除一些无用的代码，只保留少量的可复用的代码。在整理的过程中，我几乎把所有的代码全部删除了，只保留一些高复用性的 <code>util</code>、<code>constant</code> 之类的代码，但是在整理和 HBase 相关的代码时，遇到了一个诡异的问题，报错信息截取片段：<code>Cannot get replica 0 location for</code>，后来经过排查发现不是现象诡异，而是自己太愚蠢，本文记录这个过程。</p><a id="more"></a><h1 id="代码问题"><a href="# 代码问题" class="headerlink" title="代码问题"></a>代码问题 </h1><p> 代码逻辑很简单，根据批量的 <code>pk 值 </code> 去 <code>HBase</code> 表中查询数据，只需要查询指定的 <strong> 列簇 </strong>，然后对返回结果进行解析，按行输出为文本文件。</p><p>具体的代码逻辑：</p><ol><li>根据 <code>pk</code> 构造 <code>Get</code> 对象，并指定 <strong>列簇 </strong></li><li> 根据 <code>HBase</code> 表名称以及环境配置参数构造 <code>HTable</code> 对象 </li><li> 调用 <code>HTbale</code> 对象的 <code>get</code> 方法获取结果 </li><li> 解析 3 中返回的结果 </li></ol><p> 在测试的时候，发现总是在第 3 个步骤出现大量的异常信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-06-17_23:09:40 [Executor task launch worker-11] ERROR client.AsyncProcess:927: Cannot get replica 0 location for &#123;&quot;cacheBlocks&quot;:true,&quot;totalColumns&quot;:1,&quot;row&quot;:&quot;ef7e0077a525929788b387dda294b9bb&quot;,&quot;families&quot;:&#123;&quot;r&quot;:[&quot;publish_date&quot;]&#125;,&quot;maxVersions&quot;:1,&quot;timeRange&quot;:[0,9223372036854775807]&#125;</span><br></pre></td></tr></table></figure><p>此外我还看到一些 <code>HBase</code> 查询时的错误，只列出了 <code>HBase</code> 相关的片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.apache.hadoop.hbase.client.RetriesExhaustedWithDetailsException: Failed 1007 actions: IOException: 1007 times, </span><br><span class="line">at org.apache.hadoop.hbase.client.AsyncProcess$BatchErrors.makeException (AsyncProcess.java:228)</span><br><span class="line">at org.apache.hadoop.hbase.client.AsyncProcess$BatchErrors.access$1700 (AsyncProcess.java:208)</span><br><span class="line">at org.apache.hadoop.hbase.client.AsyncProcess$AsyncRequestFutureImpl.getErrors (AsyncProcess.java:1605)</span><br><span class="line">at org.apache.hadoop.hbase.client.HTable.batch (HTable.java:936)</span><br><span class="line">at org.apache.hadoop.hbase.client.HTable.batch (HTable.java:950)</span><br><span class="line">at org.apache.hadoop.hbase.client.HTable.get (HTable.java:911)</span><br></pre></td></tr></table></figure><p>而且是所有的查询请求全部都是这种错误，看起来像是查询不到数据，但是不知道为何如此。我一开始猜测是环境的原因，可能是哪里把环境参数的配置文件搞错了，于是检查了一遍配置文件，没有发现任何问题。后来猜测可能是集群的问题，但是检查了一遍，集群一直正常运行。</p><p>折腾了一个多小时，最终实在没有办法，只好把这段查询数据的逻辑代码单独拆出来，重新手写一遍，查询 2 条测试数据的发表时间：<code>publish_date</code>，并单步调试，看看究竟发生了什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void TestHBase () &#123;</span><br><span class="line">String string = &quot;XX_POST_TABLE_NAME&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">HTable hTable = new HTable (XxxConfig.getInstance (), TableName.valueOf (string));</span><br><span class="line">List&lt;Get&gt; getList = Lists.newArrayList ();</span><br><span class="line">Get get = new Get (Bytes.toBytes (&quot;0000135807e05492e830ade76a8a0c38x&quot;));</span><br><span class="line">get.addColumn (XxxConsts.R, &quot;publish_date&quot;.getBytes ());</span><br><span class="line">getList.add (get);</span><br><span class="line">Get get2 = new Get (Bytes.toBytes (&quot;0000135807e05492e830ade76a8a0c38&quot;));</span><br><span class="line">get.addColumn (XxxConsts.R, &quot;publish_date&quot;.getBytes ());</span><br><span class="line">getList.add (get2);</span><br><span class="line">Result [] resultArr = hTable.get (getList);</span><br><span class="line">for (Result result : resultArr) &#123;</span><br><span class="line">Cell cell = result.getColumnLatestCell (RhinoETLConsts.R, &quot;publish_date&quot;.getBytes ());</span><br><span class="line">if (null != cell) &#123;</span><br><span class="line">System.out.println (&quot;====&quot; + Bytes.toString (cell.getValueArray (), cell.getValueOffset (), cell.getValueLength ()));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println (&quot;====null&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace ();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190619000313.png" alt="手写代码单元测试" title="手写代码单元测试"></p><p>经过运行测试，发现是正常的，没有任何错误信息出现，需要的 <strong>发表时间 </strong>字段可以正常查询出来，我立即懵了，这可怎么办。懵了 3 秒，我立刻缓过神来，作为一个有三年工作经验的工程师，我觉得这都是小场面。</p><p>而且，此刻我的内心已经有了答案：<strong> 没出问题就说明有问题 </strong>，至于哪里有问题则很容易确认，要么是旧代码有问题，要么是我手写的新代码有问题，只要仔细对比一下真相就出来了。</p><p>接着我仔细对比了一下两份代码的不同之处，没用 3 分钟就发现了蹊跷之处，而且是很低级的错误，且看下一小节的分析。</p><h1 id="错误代码片段"><a href="# 错误代码片段" class="headerlink" title="错误代码片段"></a>错误代码片段 </h1><p> 在上面的开头我已经列出来了代码逻辑的 4 个步骤，本以为出错原因在第 3 个步骤，没想到真实原因在第 2 个步骤：根据 <code>HBase</code> 表名称以及环境配置参数构造 <code>HTable</code> 对象，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 获取 HBase 连接 </span><br><span class="line">     *</span><br><span class="line">     * @param htableStr</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">public static HTable getHTable (String htableStr) &#123;</span><br><span class="line">HTable hTable = null;</span><br><span class="line">try &#123;</span><br><span class="line">hTable = new HTable (XxxConfig.getInstance (), TableName.valueOf (htableStr));</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e) &#123;</span><br><span class="line">LOG.error (e.getMessage (), e);</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">if (null != hTable) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">hTable.close ();</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace ();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return hTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190619000540.png" alt="获取 HBase 表连接的代码片段" title="获取 HBase 表连接的代码片段"></p><p>代码乍一看好像没有问题，就那么几行，但是千万要留意 <code>finally</code> 代码块中的代码，它是在做什么？它把刚刚创建好的 <code>HTable</code> 链接关了，关闭之前还友好地判断了一下是不是为 <code>null</code>，我真是一口老血喷出来。</p><p>注意，这里的关闭操作完全不影响后续的查询请求，在代码层面是判断不出来有什么问题的，即不会产生 <strong>编译错误 </strong>，直到运行起来真正去查询的时候才发现报错，但是报错信息又很模糊，没有表明具体的原因。</p><h1 id="个人思考"><a href="# 个人思考" class="headerlink" title="个人思考"></a>个人思考 </h1><p> 我回顾了一下，这个问题明显是一个很低级的错误，但是为什么出现在我身上呢，总结原因有二：一是直接复制了别处的代码，稍做改动，结果改错了；二是在晚上整理的代码，已经工作了一天，状态不够好，容易犯小错误。</p><p>从小事中吸取教训，总结如下：</p><p>1、在状态不好的时候，还是先休息好最重要，否则坚持写出来的代码会有一些低级错误，而且还自信地认为没有问题，给后续的排查留下坑。同理，做其它事情也是一样，对于一些要求严格的事情，为了保证质量，一定要在一天中状态最好的时间段去处理，才能最大程度地避免出问题。</p><p>2、对自己写出的代码不要过于自信，特别是一些简单的代码，自己想当然地认为不可能有问题，不舍得花费几分钟检查一下，或者测试一下，这会为自己带来浪费时间的风险，就像现在这样，早晚要为自己的失误买单。做其它事情也是一样，一定要反复检查自己负责的部分，如果有时候局限于时间排期，没有充足的时间检查，无法保证可靠性的话，宁愿延期解决，也不要坑自己和别人。当然，也不要因此自卑或者退缩，该是自己负责的时候一定要积极，按时保质保量完成。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近在整理一个单独的 Maven 项目，是从其它项目迁移过来的，主要存放的是和业务强相关的代码，略显混乱的代码是必不可少的，我的职责就是把现存的代码抽象出来，尽量删除一些无用的代码，只保留少量的可复用的代码。在整理的过程中，我几乎把所有的代码全部删除了，只保留一些高复用性的 &lt;code&gt;util&lt;/code&gt;、&lt;code&gt;constant&lt;/code&gt; 之类的代码，但是在整理和 HBase 相关的代码时，遇到了一个诡异的问题，报错信息截取片段：&lt;code&gt;Cannot get replica 0 location for&lt;/code&gt;，后来经过排查发现不是现象诡异，而是自己太愚蠢，本文记录这个过程。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据技术知识" scheme="https://www.playpi.org/categories/big-data-technical-knowledge/"/>
    
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="HBase" scheme="https://www.playpi.org/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>一个诡异的 ES-Hadoop 问题</title>
    <link href="https://www.playpi.org/2019061301.html"/>
    <id>https://www.playpi.org/2019061301.html</id>
    <published>2019-06-13T13:41:49.000Z</published>
    <updated>2019-06-19T13:41:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>最近在处理 Elasticsearch 数据的时候，使用的是 ES-Hadoop 组件，方便快捷，但是今天遇到一个小问题，让我着实折腾了一番。折腾的原因在于我本以为一切顺利，确实没想到会有一些奇怪的事情发生，这也让我积累了经验，其中错误的核心内容为：<code>Incompatible types found in multi-mapping: Field [your_field] has conflicting types</code>，本文详细记录分析问题的过程，文中内容涉及的开发环境为 <code>Elasticsearch v5.6.8</code>、<code>Windows7 X64</code>。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 代码的逻辑很简单，使用 Spark 连接 Elasticsearch 集群【使用 ES-Hadoop 组件】，读取数据，然后简单处理一下就写入 HDFS 中，没有任何复杂的逻辑。但是在程序运行的过程中，出现了异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.elasticsearch.hadoop.EsHadoopIllegalArgumentException: Incompatible types found in multi-mapping: Field [query.bool.must.match.content] has conflicting types of [OBJECT] and [KEYWORD].</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190619230522.png" alt="异常信息日志" title="异常信息日志"></p><p>根据图中的异常信息，可以猜测是字段问题：类型冲突，下面来逐步分析。</p><h1 id="问题分析"><a href="# 问题分析" class="headerlink" title="问题分析"></a>问题分析 </h1><p> 看起来是存在不兼容的 <code>type</code>，根本原因是字段类型冲突，一个字段同时存在两种类型：OBJECT、KEYWORD，但是这个字段名称也太诡异了：<code>query.bool.must.match.content</code>，不用说，肯定是有人在查询时误把查询语句作为数据 <code>put</code> 到了 Elasticsearch 数据库中，导致产生了这种奇怪的字段名称，去数据库查询一下就知道。</p><h2 id="查询数据量"><a href="# 查询数据量" class="headerlink" title="查询数据量"></a>查询数据量 </h2><p> 由于从异常信息中无法得知其它有效信息，只能使用 <code>exists</code> 查询语句，看看有几条这种数据，查询语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;exists&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;query.bool.must.match.content&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190619230502.png" alt="查询数据结果" title="查询数据结果"></p><p>通过查询，可以看到有一条数据，这一看就是一条标准的查询语句，被作为数据存入了 Elasticsearch 数据库，应该是有人误操作。</p><p>可以看到，整个索引别名【底下可能会有多个真实索引名称】里面只有这一条数据，那为什么会冲突呢？其实，不能只看数据量，因为可能数据被删除了，但是 <code>mapping</code> 中仍旧保留着字段信息【Elasticsearch 的 <code>mapping</code> 无法针对字段粒度进行删除、更新】，所以要进一步查看索引别名下面的每个真实索引名称对应的 <code>mapping</code> 中是不是都有这个字段。因此，直接查看 <code>mapping</code> 更为准确。</p><h2 id="查看索引配置"><a href="# 查看索引配置" class="headerlink" title="查看索引配置"></a>查看索引配置 </h2><p> 这里需要特别注意一个问题，现在很多索引的 <code>mapping</code> 都是使用 <strong>匹配模版 </strong>构造的，即定义了一些规则【例如字段名称以什么开头、以什么结尾就会存储成对应的类型】，然后字段都以这些规则自动生成，例如如果写入一条数据，里面的内容字段以 <code>_content</code> 结尾，则会自动分词，方便检索。这种方式的好处是可以综合考虑多种情况，提前全部设置为模版，不仅管理起来方便，也为以后的字段扩展留下余地。</p><p>一般的模版信息格式如下，了解一下即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;your_index_name&quot;: &#123;</span><br><span class="line">            &quot;_source&quot;: &#123;</span><br><span class="line">                &quot;excludes&quot;: [</span><br><span class="line">                    &quot;content&quot;,</span><br><span class="line">                    &quot;author&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;dynamic_templates&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;template_1&quot;: &#123;</span><br><span class="line">                        &quot;mapping&quot;: &#123;</span><br><span class="line">                            &quot;index&quot;: &quot;not_analyzed&quot;,</span><br><span class="line">                            &quot;type&quot;: &quot;string&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;match&quot;: &quot;*&quot;,</span><br><span class="line">                        &quot;match_mapping_type&quot;: &quot;string&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;content1&quot;: &#123;</span><br><span class="line">                        &quot;mapping&quot;: &#123;</span><br><span class="line">                            &quot;analyzer&quot;: &quot;wordsEN&quot;,</span><br><span class="line">                            &quot;type&quot;: &quot;text&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;match&quot;: &quot;*_content&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;price&quot;: &#123;</span><br><span class="line">                        &quot;mapping&quot;: &#123;</span><br><span class="line">                            &quot;type&quot;: &quot;float&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;match&quot;: &quot;*_price&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190619230438.png" alt="查看模版信息" title="查看模版信息"></p><p>模版里面的内容其实是一个 JSON 数组，可以设置多个匹配规则，方便字段的规范管理。</p><p>接着使用 <code>head</code> 插件查看 <code>mapping</code>，把几个真实的索引下面的 <code>mapping</code> 都检查了一遍【一共四个】，只在两个索引下面找到了期望的 <code>mapping</code> 信息，如下：</p><p>第一处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">                &quot;bool&quot;: &#123;</span><br><span class="line">                    &quot;properties&quot;: &#123;</span><br><span class="line">                        &quot;must&quot;: &#123;</span><br><span class="line">                            &quot;properties&quot;: &#123;</span><br><span class="line">                                &quot;match&quot;: &#123;</span><br><span class="line">                                    &quot;properties&quot;: &#123;</span><br><span class="line">                                        &quot;content&quot;: &#123;</span><br><span class="line">                                            &quot;properties&quot;: &#123;</span><br><span class="line">                                                &quot;query&quot;: &#123;</span><br><span class="line">                                                    &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">                                                &#125;,</span><br><span class="line">                                                &quot;type&quot;: &#123;</span><br><span class="line">                                                    &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &quot;range&quot;: &#123;</span><br><span class="line">                                    &quot;properties&quot;: &#123;</span><br><span class="line">                                        &quot;publish_date&quot;: &#123;</span><br><span class="line">                                            &quot;properties&quot;: &#123;</span><br><span class="line">                                                &quot;from&quot;: &#123;</span><br><span class="line">                                                    &quot;type&quot;: &quot;long&quot;</span><br><span class="line">                                                &#125;,</span><br><span class="line">                                                &quot;include_lower&quot;: &#123;</span><br><span class="line">                                                    &quot;type&quot;: &quot;boolean&quot;</span><br><span class="line">                                                &#125;,</span><br><span class="line">                                                &quot;include_upper&quot;: &#123;</span><br><span class="line">                                                    &quot;type&quot;: &quot;boolean&quot;</span><br><span class="line">                                                &#125;,</span><br><span class="line">                                                &quot;to&quot;: &#123;</span><br><span class="line">                                                    &quot;type&quot;: &quot;long&quot;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190619230357.png" alt="第一处 mapping" title="第一处 mapping"></p><p>第二处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;query&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">                &quot;bool&quot;: &#123;</span><br><span class="line">                    &quot;properties&quot;: &#123;</span><br><span class="line">                        &quot;must&quot;: &#123;</span><br><span class="line">                            &quot;properties&quot;: &#123;</span><br><span class="line">                                &quot;match&quot;: &#123;</span><br><span class="line">                                    &quot;properties&quot;: &#123;</span><br><span class="line">                                        &quot;content&quot;: &#123;</span><br><span class="line">                                            &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &quot;term&quot;: &#123;</span><br><span class="line">                                    &quot;properties&quot;: &#123;</span><br><span class="line">                                        &quot;site_id&quot;: &#123;</span><br><span class="line">                                            &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190619230345.png" alt="第二处 mapping" title="第二处 mapping"></p><p>虽然只找到了两处，但是足够造成前面的异常，通过对比可以发现其中的细微不同之处，核心的地方在于 <code>content</code> 的类型不一致，对比如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- OBJECT</span><br><span class="line">&#123;</span><br><span class="line">    &quot;content&quot;: &#123;</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">            &quot;query&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;type&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-- KEYWORD</span><br><span class="line">&#123;</span><br><span class="line">    &quot;content&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，破案了，问题根本原因被找到，那么怎么解决呢？</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><p> 直接查看源码，先看看 ES-Hadoop 是怎么处理的，根据异常信息里面的方法调用，主要就是看 <code>MappingSet.addToFieldTable ()</code>，我的环境依赖的 ES-Hadoop 坐标为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch-hadoop&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.6.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>我查询到的源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings (&quot;unchecked&quot;)</span><br><span class="line">    private static void addToFieldTable (Field field, String parent, Map&lt;String, Object []&gt; fieldTable) &#123;</span><br><span class="line">String fullName = parent + field.name ();</span><br><span class="line">Object [] entry = fieldTable.get (fullName);</span><br><span class="line">if (entry == null) &#123;</span><br><span class="line">// Haven&apos;t seen field yet.</span><br><span class="line">if (FieldType.isCompound (field.type ())) &#123;</span><br><span class="line">//visit its children</span><br><span class="line">Map&lt;String, Object []&gt; subTable =  new LinkedHashMap&lt;String, Object []&gt;();</span><br><span class="line">entry = new Object []&#123;field, subTable&#125;;</span><br><span class="line">String prefix = fullName + &quot;.&quot;;</span><br><span class="line">for (Field subField : field.properties ()) &#123;</span><br><span class="line">addToFieldTable (subField, prefix, subTable);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//note that we saw it</span><br><span class="line">entry = new Object []&#123;field&#125;;</span><br><span class="line">&#125;</span><br><span class="line">fieldTable.put (fullName, entry);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// We&apos;ve seen this field before.</span><br><span class="line">Field previousField = (Field) entry [0];</span><br><span class="line">//ensure that it doesn&apos;t conflict</span><br><span class="line">if (!previousField.type ().equals (field.type ())) &#123;</span><br><span class="line">throw new EsHadoopIllegalArgumentException (&quot;Incompatible types found in multi-mapping: &quot; +</span><br><span class="line">                        &quot;Field [&quot;+fullName+&quot;] has conflicting types of [&quot;+previousField.type ()+&quot;] and [&quot;+</span><br><span class="line">                        field.type ()+&quot;].&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// If it does not conflict, visit it&apos;s children if it has them</span><br><span class="line">if (FieldType.isCompound (field.type ())) &#123;</span><br><span class="line">Map&lt;String, Object []&gt; subTable = (Map&lt;String, Object []&gt;) entry [1];</span><br><span class="line">String prefix = fullName + &quot;.&quot;;</span><br><span class="line">for (Field subField : field.properties ()) &#123;</span><br><span class="line">addToFieldTable (subField, prefix, subTable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190619230307.png" alt="源代码片段" title="源代码片段"></p><p>看到这里就没有什么办法了，因为 Elasticsearch 数据不规范【本来是正常的，后来人为因素破坏了 <code>mapping</code> 数据结构】，导致 ES-Hadoop 无法处理，从而抛出异常。</p><p>但是，仔细思考一下，ES-Hadoop 的这种处理逻辑显然有点问题，因为客户端在读取数据的时候，可以指定同一个索引下的多个类型，当然，也可以同时指定多个索引。然而，有时候为了方便，会把很多索引的别名设置成同一个，这样在查询或者取数的时候就不用指定索引名称的列表了。</p><p>如果是这样，多个索引下面的 <code>mapping</code> 不能保证一致，由于是手动设置的索引别名，索引数据可能多种多样【另一层面的知识点，Elasticsearch 官方是不允许同一个索引下的多个类型拥有不同的字段属性的，而且，6.x 取消了索引类型的概念】，但是客户端在读取数据的时候是可以过滤字段的，使用 <code>es.read.field.include</code>、<code>es.read.field.exclude</code> 参数分别设置必要的字段、过滤的字段。这样的话，开发者就可以把可能有问题的字段去除掉，避免影响程序的正常运行。然而可以看到，ES-Hadoop 没有给任何机会，遇到类型冲突的字段直接抛出异常，程序无法正常运行。</p><p>我觉得应该在日志中给出警告，提醒开发者可能出现的问题，但是程序仍旧可以正常运行，在运行的过程中，如果真的遇到字段冲突的问题【例如同时读取了不同索引中的相同字段，但是字段类型不一致，无法处理】，程序自会抛出运行时异常，而如果从头至尾没有任何字段问题，程序就可以正常运行了，开发者甚至毫无感知发生了什么。</p><p>于是，接着我找到一个 GitHub 的讨论帖子：<br><a href="https://github.com/elastic/elasticsearch-hadoop/issues/1074" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch-hadoop/issues/1074</a>、<br><a href="https://github.com/elastic/elasticsearch-hadoop/issues/1192" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch-hadoop/issues/1192</a>，<br>发现早就有人遇到同样的问题了，并且提出了建议，作者也把它作为开发特性，计划在以后的版本发布。目前来看，应该在 v6.4.2、v6.5.0 修复了这个问题，但是我使用的还是 v5.6.8，而且在帖子中也可以看到一些人同样是 v5.6.0、v5.6.1、v5.6.5 版本有问题。此时，我要么升级版本，要么更改源码，要么重建数据源，这些方式对于我来说都有未知的风险，我陷入了沉思。</p><p>突然，一阵灵光闪现，我觉得可以适当降低小版本号，可能以前 ES-Hadoop 是没有这个限制的，以防走弯路，同时我又参考了别的项目代码，发现 v5.5.0 可以使用。于是，我更改了构件的版本号，其它地方不用变动【要确保低版本的构件可以支持高板的 Elasticsearch】，测试了一下，果然可以，遇到字段冲突不会抛出异常，程序可以正常运行。此时，我再想查查源代码是怎么处理的，发现已经找不到 v5.6.8 那个 <code>MappingSet</code> 类了。</p><p>依赖构件坐标如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch-hadoop&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.5.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这种情况虽然看起来有潜在的危险，我也知道，但是我在自定义配置中，使用 <code>es.read.field.include</code> 参数只读取少量的字段，就可以保证有冲突的字段不影响我的业务处理逻辑，也认为对整个应用程序没有什么危害。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近在处理 Elasticsearch 数据的时候，使用的是 ES-Hadoop 组件，方便快捷，但是今天遇到一个小问题，让我着实折腾了一番。折腾的原因在于我本以为一切顺利，确实没想到会有一些奇怪的事情发生，这也让我积累了经验，其中错误的核心内容为：&lt;code&gt;Incompatible types found in multi-mapping: Field [your_field] has conflicting types&lt;/code&gt;，本文详细记录分析问题的过程，文中内容涉及的开发环境为 &lt;code&gt;Elasticsearch v5.6.8&lt;/code&gt;、&lt;code&gt;Windows7 X64&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据技术知识" scheme="https://www.playpi.org/categories/big-data-technical-knowledge/"/>
    
    
      <category term="Hadoop" scheme="https://www.playpi.org/tags/Hadoop/"/>
    
      <category term="Elasticsearch" scheme="https://www.playpi.org/tags/Elasticsearch/"/>
    
      <category term="es-hadoop" scheme="https://www.playpi.org/tags/es-hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Linux 让进程在后台运行的几种方法</title>
    <link href="https://www.playpi.org/2019051501.html"/>
    <id>https://www.playpi.org/2019051501.html</id>
    <published>2019-05-15T07:49:53.000Z</published>
    <updated>2019-06-08T07:49:53.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>在 <code>Linux</code> 系统中，运行程序时经常需要把进程放在后台运行，并且退出终端等待，也可以说是守护进程，<code>daemon</code> 的概念，可能过几个小时或者十几个小时之后再去观察。此种场景，需要把进程放入后台运行，并且为了防止进程挂起，也需要设置进程忽略挂起信号【使用 <code>nohup</code> 命令】，这样就可以保证进程在我退出终端后仍旧能正常运行，无论我多久之后再来观察，仍可以看到进程的运行信息。本文记录关于进程后台运行【<code>daemon</code>】的几种方法，并给出实际的操作示例，属于入门级别。</p><a id="more"></a><h1 id="回顾"><a href="# 回顾" class="headerlink" title="回顾"></a>回顾 </h1><p> 在我刚刚开始步入社会时，算是一个职场新手，很多东西都不会，可以说是一张白纸。经过一路上走弯路、披荆斩棘，现在总算积累了一些经验。</p><p>记得在刚刚开始工作时，经常碰到这样的场景，使用 <code>telnet</code> 或者 <code>ssh</code> 登录了远程的 <code>Linux</code> 服务器【很多工作需要在 <code>Linux</code> 上面完成】，在上面跑了几个 <code>Shell</code> 脚本，或者起了几个 <code>Java</code> 进程，而且这些脚本或者进程耗时都比较长，可能需要几个小时或者几天。我一开始的做法就是打开 <code>XShell</code> 工具的多个会话窗口，分别跑脚本或者起进程，不仅不能关掉，而且还要时刻担心网络问题导致与 <code>Linux</code> 的会话断开，这样一切工作就白费了。</p><p>我在操作过程中被其他同事看到了，他们说我这种做法太蠢了，是在浪费生命。经过他们指点，其实可以使用后台挂起的命令【即 <code>nohup</code> 加上 <code>&amp;</code>】，这样就可以让进程自由自在地在系统后台运行，我也可以安心地做其它事情了。</p><p>我第一次受到了经验方面的冲击，觉得这种方式太酷了，一开始我为什么不多思考一下、查询一下或者咨询一下同事。现在回想起来当时甚至都没有这方面的想法，只是知道埋头苦干，我想这些实用的知识点肯定还有很多，这也敦促了我从此以后我更加努力，多学多看多问。</p><p>在后来的工作或者生活当中，我又接触到了很多类似的知识点或者说是小技巧，不仅提高了我的工作效率，还丰富了我的认知。其中，基于进程的后台运行这个场景，还有很多很好的工具可以使用，而且还有很多实际操作的小技巧可以使用，以下的内容会一一介绍。</p><p>读者在继续阅读之前，最好先了解一下 <strong>信号 </strong>的概念，也可以直接参考我的另外一篇博文：<a href="https://www.playpi.org/2019042101.html">Linux 之 kill 命令入门实践 </a> ，里面会有一些入门级别的介绍。</p><h1 id="前言"><a href="# 前言" class="headerlink" title="前言"></a> 前言 </h1><p> 在工程师或者运维人员的职业生涯中，肯定会碰到这样的场景：使用 <code>ssh</code> 或者 <code>telnet</code> 登录了远程 <code>Linux</code> 服务器，然后在上面跑一些程序任务或者脚本。如果是临时任务或者几分钟就能搞定的任务，基本不会有什么问题，但是如果是耗时比较长的任务、需要在系统后台长期运行的任务，如果没有人为正确操作，就会因为网络不稳定或者手抖退出了连接会话，从而导致进程任务中断。最终还要从头再来，如果遇到这种问题，所有人都是崩溃的。</p><p>那么我不禁思考，有没有什么办法可以让进程任务在提交后不受网络中断、连接会话退出的影响呢，从而可以一直保持在后台稳定运行，直到结束。肯定是有的，读者在工作中一定也见过周围的技术大神同事操作，或者自己就是技术大神，下面列举一些常用的方式，读者可以参考，选择自己喜欢的方式使用。</p><p>内容中涉及到的 <code>SIGHUP</code> 信号，先来了解一下它的由来：</p><blockquote><p>在 <code>Unix</code> 的早期版本中，每个终端都会通过 <code>modem</code> 和系统通信，当用户 <code>logout</code> 时，<code>modem</code> 就会挂断（hang up）电话。同理，当 <code>modem</code> 断开连接时，就会给终端发送 <code>hangup</code> 信号来通知其关闭所有子进程。这里的子进程包含前台子进程、后台子进程，前台子进程是被直接关闭的（如果被手动设置了 <code>nohup</code> 则除外），后台子进程要根据操作系统的 <code>huponexit</code> 设置而定，不一定会被关闭。其中，这里的后台子进程还会包括正在运行的子进程（使用 <code>jobs</code> 工具查看 处于 <code>running</code> 状态）、暂停的子进程（使用 <code>jobs</code> 工具查看 处于 <code>stopped</code> 状态，处于这个状态的子进程无论有没有被手动设置 <code>nohup</code> 都会被关闭）。</p></blockquote><p>再看一下维基百科给它的定义：</p><blockquote><p><strong>nohup</strong> is a POSIX command to ignore the HUP (hangup) signal. The HUP signal is, by convention, the way a terminal warns dependent processes of logout.<br>Output that would normally go to the terminal goes to a file called nohup.out if it has not already been redirected.</p></blockquote><h1 id="直接忽略挂起信号"><a href="# 直接忽略挂起信号" class="headerlink" title="直接忽略挂起信号"></a>直接忽略挂起信号 </h1><p> 众所周知，当发生用户注销会话、网络断开等事件时，终端会收到 <code>SIGHUP</code> 信号从而关闭其所有的子进程，它是通过把 <code>SIGHUP</code> 信号发送给所有子进程实现。当然，<strong> 前台 </strong>子进程如果没有设置忽略 <code>SIGHUP</code> 信号直接会停掉，如果设置了会继续运行【父进程会变化】。但是 <strong>后台 </strong>子进程除了人为设置可能还会因为操作系统的设置而忽略 <code>SIGHUP</code> 信号【所以有些人会觉得莫名其妙，怎么退出了再登录发现有些进程还在】，而且还要区分后台子进程的状态【使用 <code>jobs</code> 命令查看，处于 <code>running</code>、<code>stopped</code> 等状态】。</p><p>梳理到这里，我就能想到两种解决方案：一是让进程忽略掉 <code>SIGHUP</code> 信号，二是让进程脱离会话父进程的运行，附属于其它父进程，从而不会接收到当前终端对应的进程发出的 <code>SIGHUP</code> 信号，这两种方法都可以让进程不受外界因素影响，稳定地运行。</p><p>下面逐一演示。</p><h2 id="nohup- 方式"><a href="#nohup- 方式" class="headerlink" title="nohup 方式"></a>nohup 方式 </h2><p> 思路有了，我首先能想到的就是 <code>nohup</code> 工具，顾名思义，<code>nohup</code> 这个工具的作用就是让进程忽略掉所有的 <code>SIGHUP</code> 信号，不受它的影响。</p><p>让我们先来看一下帮助文档信息，使用 <code>man nohup</code> 命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">NOHUP (1)                         User Commands                        NOHUP (1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       nohup - run a command immune to hangups, with output to a non-tty</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       nohup COMMAND [ARG]...</span><br><span class="line">       nohup OPTION</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Run COMMAND, ignoring hangup signals.</span><br><span class="line"></span><br><span class="line">       --help display this help and exit</span><br><span class="line"></span><br><span class="line">       --version</span><br><span class="line">              output version information and exit</span><br><span class="line"></span><br><span class="line">       If standard input is a terminal, redirect it from /dev/null.  If standard output is a terminal, append output to ‘nohup.out’ if possible, ‘$HOME/nohup.out’ otherwise.  If standard error is a terminal, redirect it to standard output.  To save output to FILE, use ‘nohup COMMAND &gt; FILE’.</span><br><span class="line"></span><br><span class="line">       NOTE: your shell may have its own version of nohup, which usually supersedes the version described here.  Please refer to your shell’s documentation for details about the options it supports.</span><br><span class="line"></span><br><span class="line">AUTHOR</span><br><span class="line">       Written by Jim Meyering.</span><br><span class="line"></span><br><span class="line">REPORTING BUGS</span><br><span class="line">       Report nohup bugs to bug-coreutils@gnu.org</span><br><span class="line">       GNU coreutils home page: &lt;http://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">       General help using GNU software: &lt;http://www.gnu.org/gethelp/&gt;</span><br><span class="line">       Report nohup translation bugs to &lt;http://translationproject.org/team/&gt;</span><br><span class="line"></span><br><span class="line">COPYRIGHT</span><br><span class="line">       Copyright © 2010 Free Software Foundation, Inc.  License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;.</span><br><span class="line">       This is free software: you are free to change and redistribute it.  There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line">SEE ALSO</span><br><span class="line">       The full documentation for nohup is maintained as a Texinfo manual.  If the info and nohup programs are properly installed at your site, the command</span><br><span class="line"></span><br><span class="line">              info coreutils &apos;nohup invocation&apos;</span><br><span class="line"></span><br><span class="line">       should give you access to the complete manual.</span><br><span class="line"></span><br><span class="line">GNU coreutils 8.4                December 2011                        NOHUP (1)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190831173014.png" alt="nohup 帮助文档信息" title="nohup 帮助文档信息"></p><p>从中可以挑出重点信息查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup COMMAND [ARG]...</span><br><span class="line">Run COMMAND, ignoring hangup signals.</span><br><span class="line">If  standard  output is a terminal, append output to ‘nohup.out’ if possible,‘$HOME/nohup.out’ otherwise.</span><br></pre></td></tr></table></figure><ul><li>使用方式：在执行的任务命令前面加上 <code>nohup</code> 即可。</li><li>作用：可以让执行的进程忽略 <code>SIGHUP</code> 信号。</li><li>输出：在终端执行的进程，输出信息会重定向到 <code>nohup.out</code> 文件。</li></ul><p>可见，<code>nohup</code> 的使用是十分简单方便的，标准输出和标准错误默认会被重定向到 <code>nohup.out</code> 文件中，此文件会自动生成于执行命令的当前目录。</p><p>但是要注意，一般我会在命令结尾加上 <code>&amp;</code> 来将任务进程放入后台运行，如果不加的话，进程会一直占用终端【其实就是标准输入一直等待终端的输入】，这样就没法在当前会话窗口进行其它操作了。</p><p>这里需要注意一点，如果把进程放在后台运行，由于进程不再占用会话窗口，它的本质其实是不再从标准输入【<code>stdin</code>】读取输入参数指令，如果此时进程中有从标准输入读取指令的代码逻辑，会导致暂停【处于 <code>stopped</code> 状态】。因此，对于一些交互式的任务，肯定不适合放在后台运行，况且本来就是交互式任务【与前台用户交互】，还放在后台运行干什么。如果非要放在后台运行，可以在执行任务时加上输入重定向【注意不是输出重定向】：<code>nohup command &lt; /dev/null &amp;</code>，这样遇到读取输入的逻辑就不会暂停，但是可能会从 <code>/dev/null</code> 接收一些奇怪的指令。</p><p>那么，为什么输出流没有这个问题呢，其实是 <code>nohup</code> 的功劳，它已经把标准输出、标准错误都重定向到 <code>nohup.out</code> 文件了。如果没有使用 <code>nohup</code>，而是直接执行 <code>command &lt; /dev/null &amp;</code>，同时退出了当前会话窗口【任务放在后台运行，退出会话不会影响任务继续运行】，则后台运行的任务已经失去了标准输出、标准错误这两个输出流。如果代码中有输出内容到标准输出或者标准错误的逻辑【例如打印日志】，会导致任务暂停【处于 <code>stopped</code> 状态】，但是当前会话窗口已经被关闭，进程找不到父进程，进而终止。所以，为了保证安全性，需要把输出信息输出到指定的文件，除了 <code>nohup</code> 默认的输出流，此时也可以使用 <code>command &gt;filename 2&gt;&amp;1 &amp;</code> 来更改默认的输出流，这样可以保证后台任务的正常运行，而且更方便观察每个进程的输出日志【全部输出到指定的文件】。</p><p>知识点绕的有点远了，言归正传，下面举一个例子，来演示 <code>nohup</code> 的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、nohup tail -f xx.log &amp;，提交一个后台进程，忽略 SIGHUP 信号 </span><br><span class="line">2、ps -ef |grep &apos;tail -f&apos; |grep -v grep，查看进程的状态 </span><br><span class="line">3、kill -SIGHUP 245058，手动发送 SIGHUP 信号 </span><br><span class="line">4、同 2 再查看进程的状态 </span><br></pre></td></tr></table></figure><p>依次执行上述步骤，输出信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[pengfei@dev2 ~]$ nohup tail -f xx.log &amp;</span><br><span class="line">[1] 245058</span><br><span class="line">[pengfei@dev2 ~]$ nohup: ignoring input and appending output to `nohup.out&apos;</span><br><span class="line"></span><br><span class="line">[pengfei@dev2 ~]$ </span><br><span class="line">[pengfei@dev2 ~]$ </span><br><span class="line">[pengfei@dev2 ~]$ ps -ef |grep &apos;tail -f&apos; |grep -v grep</span><br><span class="line">pengfei  245058 201491  0 01:36 pts/0    00:00:00 tail -f xx.log</span><br><span class="line">[pengfei@dev2 ~]$ </span><br><span class="line">[pengfei@dev2 ~]$ </span><br><span class="line">[pengfei@dev2 ~]$ kill -SIGHUP 245058</span><br><span class="line">[pengfei@dev2 ~]$ </span><br><span class="line">[pengfei@dev2 ~]$ ps -ef |grep &apos;tail -f&apos; |grep -v grep</span><br><span class="line">pengfei  245058 201491  0 01:36 pts/0    00:00:00 tail -f xx.log</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190831173717.png" alt="nohup 简单演示" title="nohup 简单演示"></p><p>可以看到，进程已经不受 <code>SIGHUP</code> 信号的影响了，并没有被杀死，仍旧在运行中。</p><h2 id="setsid- 方式"><a href="#setsid- 方式" class="headerlink" title="setsid 方式"></a>setsid 方式 </h2><p> 待整理。</p><h2 id="amp- 方式"><a href="#amp- 方式" class="headerlink" title="&amp; 方式"></a>&amp; 方式 </h2><p> 待整理。</p><h1 id="忽略挂起的后悔药"><a href="# 忽略挂起的后悔药" class="headerlink" title="忽略挂起的后悔药"></a>忽略挂起的后悔药 </h1><p> 有时候直接运行任务后，才发现没有手动设置忽略挂起，可能已经运行了一段时间，又不想停掉任务重新启动，那么有没有可以事后弥补的方案呢？有，当然有。</p><p>后台运行的例子，使用 <code>disown</code> 也可以达到效果。</p><p>使用 <code>Ctrl + z</code> 命令，把正在前台运行的进程暂停，并放在后台，程序并没有被杀死。其实这个组合快捷键是一种控制信号，编号为 <code>19</code>，标识为 <code>SIGSTOP</code>，读者可以参考我的另外一篇博文：<a href="https://playpi.org/2019042101.html" target="_blank" rel="noopener">Linux 之 kill 命令入门实践 </a> 。当然，如果使用终端工具，再开一个会话窗口，使用 <code>ps</code> 命令查询这个进程的 <code>pid</code> 编号，然后使用 <code>kill -19 pid</code> 命令发送一个 <code>SIGSTOP</code> 信号给进程也可以达到把程序暂停并放在后台的效果。</p><h1 id="批量管理进程"><a href="# 批量管理进程" class="headerlink" title="批量管理进程"></a> 批量管理进程 </h1><p> 前面的描述都是单个进程或者几个进程，管理起来也挺方便，但是如果遇到大量的进程需要管理，例如运维人员日常需要手动管理大量的进程，几百个几千个都是有可能的，那么怎么办呢。为了简化管理，并且保证进程能在后台稳定运行，此时就需要通过 <code>screen</code> 工具来操作，这是一个利器。</p><p>首先我们来看一下帮助文档信息，使用 <code>man screen</code> 命令输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xx</span><br></pre></td></tr></table></figure><p>图。。</p><h1 id="前台任务与后台任务"><a href="# 前台任务与后台任务" class="headerlink" title="前台任务与后台任务"></a>前台任务与后台任务 </h1><p> 本文中涉及了这两个概念：<strong> 前台任务 </strong>【<code>foreground job</code>】、<strong> 后台任务 </strong>【<code>background job</code>】，并且很多示例演示也离不开这两个概念，读者如果不了解这两个概念，就会对很多内容看的云里雾里。</p><p>下面会对这两个概念做一些总结介绍，以加深读者的认识，达到知其然知其所以然的地步。</p><h2 id="前台任务"><a href="# 前台任务" class="headerlink" title="前台任务"></a>前台任务 </h2><p> 如果直接启动一个进程或者脚本，例如 <code>sh example.sh</code>、<code>python example.py</code>、<code>java example.jar</code> 等，都可以提交一个 <strong>前台任务 </strong>。它会独自占用当前的会话窗口，导致在当前会话窗口什么都不能做【要么开启其它会话窗口继续操作、要么暂停当前任务、要么终止当前任务】，只有等它运行完成或者被用户手动终止，用户才能继续在当前会话窗口进行各种操作。</p><h2 id="后台任务"><a href="# 后台任务" class="headerlink" title="后台任务"></a>后台任务 </h2><p> 提交 <strong>后台任务 </strong>的方法很简单，在前台任务的提交命令末尾加上 <code>&amp;</code> 符号，例如 <code>sh example.sh &amp;</code>、<code>python example.py &amp;</code>、<code>java example.jar &amp;</code> 等，就表示把当前进程放在后台运行，变成后台任务，也可以说是守护进程【<code>daemon</code>】。</p><p>后台任务有两个特点：</p><ul><li>继承当前会话（session）的标准输出（stdout）、标准错误（stderr），因此，后台任务的所有输出仍然会同步地在当前会话窗口中显示（可见，如果关闭当前会话窗口，会引起任务暂停，但是由于父进程不存在，任务进而终止退出）。</li><li>不再继承当前会话（session）的标准输入（stdin），因此，用户无法再向这个任务输入参数指令了，如果任务试图去读取标准输入（可能代码中有这个逻辑），任务就会暂停执行（只是暂停，即 stopped 状态，不是终止）。</li></ul><p>可以看到，<strong> 后台任务 </strong>与 <strong>前台任务 </strong>的本质区别只有一个，那就是是否继承当前会话【<code>session</code>】的标准输入。从这个区别不难理解，在执行后台任务时，会话窗口没有被占用，用户可以继续在当前会话窗口进行其它操作。而在执行前台任务时，会话窗口被占用，用户无法继续使用这个会话窗口。</p><h2 id="状态互换"><a href="# 状态互换" class="headerlink" title="状态互换"></a>状态互换 </h2><p> 其实，<strong> 前台任务 </strong>和 <strong>后台任务 </strong>可以非常自如地切换，以满足用户的各种使用场景，否则就会显得难以使用。上文中已经非常详细地演示了几种方式，下面总结列举出来：</p><p>&amp;</p><p>ctrl+z 然后 bg</p><p>disown 大法 </p><h1 id="总结 -SIGHUP- 信号的问题"><a href="# 总结 -SIGHUP- 信号的问题" class="headerlink" title="总结 SIGHUP 信号的问题"></a> 总结 SIGHUP 信号的问题 </h1><p> 关于后台任务在会话【<code>session</code>】退出后，再次登录，为什么有的人看到任务还在运行，有的人看到任务已经终止，这是玄学吗，根本原因是什么呢？要想了解根本原因，必须先了解 <code>SIGHUP</code> 信号的知识点，以及 <code>Linux</code> 系统关于给后台任务发送信号的设置。</p><p>看看 <code>Linux</code> 系统是怎么设计的：</p><ul><li>用户准备退出会话【<code>session</code>】</li><li>用户退出会话，系统向该会话发送 <code>SIGHUP</code> 信号 </li></ul><h1 id="输入流输出流的问题"><a href="# 输入流输出流的问题" class="headerlink" title="输入流输出流的问题"></a> 输入流输出流的问题 </h1><p> 为了讲清楚让进程在后台运行的几种方法，上面的内容除了描述 <code>SIGHUP</code> 信号的问题，还夹杂着输入流、输出流的问题。其实，除了 <code>SIGHUP</code> 信号的影响，输入流、输出流也会影响着任务的运行状态，有时候虽然躲过了 <code>SIGHUP</code> 信号的攻击，但是却一不小心败给了输入流、输出流。</p><h2 id="输入流"><a href="# 输入流" class="headerlink" title="输入流"></a>输入流 </h2><p> 如果进程的代码逻辑中需要读取用户输入的指令，例如从键盘中读取指令，再执行对应的操作，这种询问应答的交互模式很常见。这里面就涉及了输入流的概念，进程需要一个输入流用来传输用户的指令，默认就是标准输入，即 <code>stdin</code> 。</p><h2 id="输出流"><a href="# 输出流" class="headerlink" title="输出流"></a>输出流 </h2><p> 如果进程的代码逻辑中需要输出信息，例如打印日志，报错信息输出，这里就涉及了输出流的概念，默认有两个，分别是：标准输出、标准错误，即 <code>stdout</code> 与 <code>stderr</code>。</p><h2 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h2><p> 这里只考虑一种特殊的场景：当用户退出会话。此时，进程会受到 <code>SIGHUP</code> 信号的影响，前面已经详细说明并且演示，假设进程躲过了所有的 <code>SIGHUP</code> 信号并一直保持正常运行。</p><p>那么问题来了，如果这个正常运行的进程与 <code>标准 IO</code> 有交互的话，他还是会终止，可能不是立即终止，只有执行到与 <code>标准 IO</code> 进行交互的代码才会终止。读者是不是很惊讶，其实这与前台任务、后台任务的流继承有关，前面已经详细说明了，下面会更具体地举一个例子。</p><p>假如有一个任务，使用 <code>nohup command &amp;</code> 执行，然后退出当前会话。我来分析一下：输出默认被重定向到 <code>nohup.out</code> 文件，忽略 <code>SIGHUP</code> 信号，任务放入后台运行，看起来是不是很完美。</p><p>但是如果任务与标准输入有交互，即需要从 <code>stdin</code> 读取指令，那么就完了。由于会话已经被关闭，<code>stdin</code> 已经不存在，任务会先进入 <code>stopped</code> 状态，紧接着退出。【即使用户不退出会话，任务也会永久处于 <code>stopped</code> 状态，无法再次激活正常运行】</p><p>如果任务与标准输出有交互，不需要多虑，因为 <code>nohup</code> 已经默默地把输出重定向到文件了。</p><p>如果启动任务使用的是 <code>setsid command &amp;</code> 命令，也不需要考虑输入流、输出流这个问题，因为 <code>setsid</code> 已经把启动进程的父进程变更为 <code>init</code> 进程，当退出会话后，输入流、输出流都会被重定向到 <code>init</code> 进程所属的。【我猜测是 <code>/dev/console</code>、<code>/dev/null</code> 之类的设备，我测试发现如果有输入进程会卡住，有输出进程会正常把信息输出到当前会话窗口，如果关闭窗口看不到输出但是也不影响进程的正常运行，状态仍旧是 <code>running</code>，说明输出流在关闭会话后变更了。这个问题暂时存疑。】</p><h1 id="备注"><a href="# 备注" class="headerlink" title="备注"></a>备注 </h1><h2 id="关于挂起的测试"><a href="# 关于挂起的测试" class="headerlink" title="关于挂起的测试"></a> 关于挂起的测试 </h2><p> 我使用 <code>XShell</code> 测试退出终端时，发现并不会挂起普通的后台进程【说明后台进程没有接收到 <code>SIGHUP</code> 信号，或者接收到但是忽略了】，反而把进程的父进程设置为了 <code>init</code>【进程号为 1】，这样进程就不会退出，下次登录的时候还能查看。但是这个现象违反了前面的知识点：退出终端时所有子进程会收到 <code>SIGHUP</code> 信号，后来我发现，原来这个操作是针对 <strong>前台任务 </strong>而言的，如果是 <strong>后台任务 </strong>则不一定，要看系统的参数设置：<code>shopt | grep huponexit</code>，<code>huponexit</code> 这个参数决定了是否向后台任务发送 <code>SIGHUP</code> 信号。而在大多数 <code>Linux</code> 系统中，这个参数一般默认是关闭的，所以才出现了终端退出后台进程没有挂起的现象。</p><p>这里面还有两个有趣的现象。</p><h3 id="前台任务 -1"><a href="# 前台任务 -1" class="headerlink" title="前台任务"></a>前台任务 </h3><p> 一是 <strong>前台任务 </strong>如果被人为设置了 <code>nohup</code>，则在会话关闭时会忽略掉 <code>SIGHUP</code> 信号，从而一直保持运行。下面演示一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、tail -f xx.log</span><br><span class="line">2、断开网络或者关闭会话窗口 </span><br><span class="line">3、nohup tail -f yy.log</span><br><span class="line">4、断开网络或者关闭会话窗口 </span><br><span class="line">5、重新登录，使用 ps 工具查看进程：ps -ef |grep &apos;tail -f&apos; |grep -v grep</span><br></pre></td></tr></table></figure><p>输出信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[pengfei@dev2 ~]$ ps -ef |grep &apos;tail -f&apos; |grep -v grep</span><br><span class="line">pengfei  199496      1  0 01:16 ?        00:00:00 tail -f yy.log</span><br></pre></td></tr></table></figure><p>图。。</p><p>使用上述步骤依次操作，可以发现 <code>nohup tail -f yy.log</code> 对应的进程还在，而 <code>tail -f xx.log</code> 对应的进程已经不在了，这就是因为前者在执行命令时手动添加了 <code>nohup</code>，从而可以保障不受因会话关闭发送的 <code>SIGHUP</code> 信号影响，而后者直接被杀死。</p><p>可能读者会怀疑这个没被杀死的进程是出于运行状态码，会不会处于暂停状态，这个很容易证明，直接使用 <code>pstack</code> 工具可以查看：<code>pstack pid</code>。例如我这里的进程号是 199496 ，则使用 <code>pstack 199496</code> 查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[pengfei@dev2 ~]$ pstack 199496</span><br><span class="line">#0  0x00000031fd8db7f0 in __read_nocancel () from /lib64/libc.so.6</span><br><span class="line">#1  0x0000000000408df6 in ?? ()</span><br><span class="line">#2  0x0000000000403b56 in ?? ()</span><br><span class="line">#3  0x0000000000404ae0 in ?? ()</span><br><span class="line">#4  0x00000031fd81ed20 in __libc_start_main () from /lib64/libc.so.6</span><br><span class="line">#5  0x0000000000401959 in ?? ()</span><br><span class="line">#6  0x00007ffdc74bdb48 in ?? ()</span><br><span class="line">#7  0x000000000000001c in ?? ()</span><br><span class="line">#8  0x0000000000000003 in ?? ()</span><br><span class="line">#9  0x00007ffdc74be606 in ?? ()</span><br><span class="line">#10 0x00007ffdc74be60b in ?? ()</span><br><span class="line">#11 0x00007ffdc74be60e in ?? ()</span><br><span class="line">#12 0x0000000000000000 in ?? ()</span><br></pre></td></tr></table></figure><p>图。。</p><p>可以看到，进程仍旧在运行中，如果是暂停状态的进程，会显示 <code>stopped</code> 标记，下面的例子会演示这个，请读者继续往下看。</p><h3 id="后台任务 -1"><a href="# 后台任务 -1" class="headerlink" title="后台任务"></a>后台任务 </h3><p>【废弃】二是 <strong> 后台任务 </strong>如果处于 <code>stopped</code> 状态，尽管会话关闭时不会导致进程被杀死，但是它仍旧处于 <code>stopped</code> 状态，等下次登录时它的父进程已经变为 <code>init</code> 进程，这就导致使用 <code>jobs</code> 工具无法查到，也无法使用 <code>fg</code> 工具激活任务。总之，这个任务永远处于 <code>stopped</code> 状态，对于我来说已经没有意义，只能等待操作系统把它停掉。下面演示一下。</p><p>二是 <strong>后台任务 </strong>如果处于 <code>stopped</code> 状态，无论有没有设置 <code>nohup</code>，在会话关闭或者网络断开时，进程会被杀死。而如果是处于 <code>ruuning</code> 状态，无论有没有设置 <code>nohup</code>，在会话关闭或者网络断开时，进程都不会被杀死。下面举两个例子演示一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、tail -f xx.log &amp;，这里只是简单后台运行，并没有设置 nohup，所以发送 SIGHUP 信号可以杀死进程 </span><br><span class="line">2、断开网络或者关闭会话窗口 </span><br><span class="line">3、nohup tail -f yy.log，然后使用 ctrl + z 暂停任务，状态处于 stopped，并置于后台 </span><br><span class="line">4、使用 jobs 工具查看进程状态 </span><br><span class="line">5、断开网络或者关闭会话窗口 </span><br><span class="line">6、重新登录，使用 ps 工具查看进程：ps -ef |grep &apos;tail -f&apos; |grep -v grep</span><br></pre></td></tr></table></figure><p>使用 <code>jobs</code> 工具查看进程状态输出信息如下，可见是 <code>stopped</code> 状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[pengfei@dev2 ~]$ nohup tail -f yy.log</span><br><span class="line">nohup: ignoring input and appending output to `nohup.out&apos;</span><br><span class="line">^Z</span><br><span class="line">[1]+  Stopped                 nohup tail -f yy.log</span><br><span class="line">[pengfei@dev2 ~]$ </span><br><span class="line">[pengfei@dev2 ~]$ jobs</span><br><span class="line">[1]+  Stopped                 nohup tail -f yy.log</span><br></pre></td></tr></table></figure><p>图。。</p><p>再次使用上面的 <code>pstack</code> 工具查看：<code>pstack pid</code>，我这里的进程号是 98537 ，则使用 <code>pstack 98537</code> 查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[pengfei@dev2 ~]$ pstack 98537</span><br><span class="line">#0  0x00000031fd8db7f0 in __read_nocancel () from /lib64/libc.so.6</span><br><span class="line">#1  0x0000000000408df6 in ?? ()</span><br><span class="line">#2  0x0000000000403b56 in ?? ()</span><br><span class="line">#3  0x0000000000404ae0 in ?? ()</span><br><span class="line">#4  0x00000031fd81ed20 in __libc_start_main () from /lib64/libc.so.6</span><br><span class="line">#5  0x0000000000401959 in ?? ()</span><br><span class="line">#6  0x00007fff911d07e8 in ?? ()</span><br><span class="line">#7  0x000000000000001c in ?? ()</span><br><span class="line">#8  0x0000000000000003 in ?? ()</span><br><span class="line">#9  0x00007fff911d1606 in ?? ()</span><br><span class="line">#10 0x00007fff911d160b in ?? ()</span><br><span class="line">#11 0x00007fff911d160e in ?? ()</span><br><span class="line">#12 0x0000000000000000 in ?? ()</span><br><span class="line"></span><br><span class="line">[1]+  Stopped                 nohup tail -f yy.log</span><br></pre></td></tr></table></figure><p>图。。</p><p>也可以看到是 <code>stopped</code> 状态。</p><p>接着我在关闭会话时【我使用 XShell 的 ctrl + d 快捷键】，可以看到第一次提醒我有暂停的进程：<code>There are stopped jobs.</code>，第二次才真正退出。</p><p>图。。</p><p>接着重新登录使用 <code>ps</code> 工具查看进程输出信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[pengfei@dev2 ~]$ ps -ef |grep &apos;tail -f&apos; |grep -v grep</span><br><span class="line">pengfei   20331      1  0 01:45 ?        00:00:00 tail -f xx.log</span><br></pre></td></tr></table></figure><p>图。。</p><p>使用上述步骤依次操作，可以发现 <code>nohup tail -f yy.log</code> 对应的进程已经不在了，尽管我手动给它设置了 <code>nohup</code>，也无济于事。而对于 <code>tail -f xx.log &amp;</code> 对应的进程，我并没有手动设置 <code>nohup</code>，可以认定是操作系统的设置导致会话关闭时不会给后台进程发送 <code>SIGHUP</code> 信号，当前父进程已经是 <code>init</code>，这个可以理解。</p><p>【废弃】可以看到，进程仍旧处在 <code>stopped</code> 状态，而且根据上面 <code>ps</code> 工具查看的结果，父进程是 <code>init</code>【进程号是 1】，所以使用 <code>jobs</code>、<code>fg</code>、<code>bg</code> 都是无效的，因此我也没有办法把它重新置于前台运行。</p><h2 id="继续探索其它高效的工具"><a href="# 继续探索其它高效的工具" class="headerlink" title="继续探索其它高效的工具"></a>继续探索其它高效的工具 </h2><p> 读者可以继续探索一下 <code>tmux</code> 工具的使用，这类工具可以更加高效、安全地帮助我们管理后台进程，从而让我们脱离手动管理后台程序的苦海。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在 &lt;code&gt;Linux&lt;/code&gt; 系统中，运行程序时经常需要把进程放在后台运行，并且退出终端等待，也可以说是守护进程，&lt;code&gt;daemon&lt;/code&gt; 的概念，可能过几个小时或者十几个小时之后再去观察。此种场景，需要把进程放入后台运行，并且为了防止进程挂起，也需要设置进程忽略挂起信号【使用 &lt;code&gt;nohup&lt;/code&gt; 命令】，这样就可以保证进程在我退出终端后仍旧能正常运行，无论我多久之后再来观察，仍可以看到进程的运行信息。本文记录关于进程后台运行【&lt;code&gt;daemon&lt;/code&gt;】的几种方法，并给出实际的操作示例，属于入门级别。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据技术知识" scheme="https://www.playpi.org/categories/big-data-technical-knowledge/"/>
    
    
      <category term="Linux" scheme="https://www.playpi.org/tags/Linux/"/>
    
      <category term="nohup" scheme="https://www.playpi.org/tags/nohup/"/>
    
      <category term="setsid" scheme="https://www.playpi.org/tags/setsid/"/>
    
      <category term="disown" scheme="https://www.playpi.org/tags/disown/"/>
    
      <category term="screen" scheme="https://www.playpi.org/tags/screen/"/>
    
      <category term="daemon" scheme="https://www.playpi.org/tags/daemon/"/>
    
  </entry>
  
  <entry>
    <title>指南页面的自动收集</title>
    <link href="https://www.playpi.org/2019050401.html"/>
    <id>https://www.playpi.org/2019050401.html</id>
    <published>2019-05-03T17:45:06.000Z</published>
    <updated>2019-05-04T17:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>最近给博客站点增加了一个独立的页面：<strong> 指南 </strong>，用来记录本站点的所有文章，包括发表时间与文章链接，并按照发表时间倒序排列，仅供快速查找以及核对使用。其中，还会有一个文章编号，就是 url 的数字部分，由日期与编号组成，例如 2019050201 表示 2019 年 05 月 02 日发表的第 1 篇文章，这个文章编号对我来说很有用，用来核对查重。但是，为了简化这个页面的整理工作以及后续的自动生成，我需要把这个流程自动化，本文记录实现思路与实现方式。</p><a id="more"></a><h1 id="实现思路"><a href="# 实现思路" class="headerlink" title="实现思路"></a>实现思路 </h1><p> 为了简化难度，我准备使用 Shell 解决这个问题。大概思路：遍历目录的文件、解析 id 与 title、搜索匹配指南 index 文件、替换或者追加。</p><p>1、遍历指定目录【_post 目录】中的所有 markdown 文件，对每个文件执行 2。</p><p>2、对单个文件，使用 <strong>grep</strong> 正则搜索： <strong>^id: [0-9]{10}</strong>，使用 <strong>awk</strong> 获取 id 值，判断 id 值是否在 index 文件中，在则跳过，否则执行 3。</p><p>3、再使用 <strong>grep</strong> 正则搜索： <strong>^title: </strong>，使用 <strong>awk</strong> 获取 title 值，执行 4，把 id 值和 title 值追加到 index 文件中。</p><p>4、先使用 <strong>grep id 值 index 文件 </strong>搜索 3 中的 id 是否已经在 index 文件中，不在才能追加进去。追加 index 文件时，先重命名 index 文件为 index_bak，逐行读取。对每一行数据使用 <strong>grep</strong> 正则搜索：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $line | grep -E &apos;^- [0-9]&#123;10&#125;，\[&apos; | awk -F&apos;，&apos; &apos;&#123;print $1;&#125;&apos; | awk -F&apos; &apos; &apos;&#123;print $2;&#125;&apos;</span><br></pre></td></tr></table></figure><p>如果搜索无内容的直接将当前行写入新文件，命名为 index。再结合使用 <strong>awk</strong> 获取当前行的 id 值，只要 3 中的 id 值大于此 id 值并且年份一致，则将 3 中的 id 值和 title 值写入新文件【构造特定格式的数据行】，接着再将当前行写入新文件。如果年份一致且 3 中的 id 值最小，则按照 5 写入当年的数据最后一行。</p><p>5、相同年份作一个标记，是否已经写入新文件作一个标记，如果遇到读取的下一行已经不是当年的数据【正则搜索无结果】，则把构造的特定格式的数据行写入新文件，再把当前行写入新文件。</p><p>6、4 中的文件逐行读取完成后，把 4 中一开始重命名的文件 index_bak 删除，只保留新文件 index，此时 index 文件中已经增加了一行新内容。</p><h1 id="具体实现"><a href="# 具体实现" class="headerlink" title="具体实现"></a>具体实现 </h1><p>Shell 脚本内容参考如下，注释都已经标明处理逻辑，通俗易懂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># index 文件 </span><br><span class="line">index=./source/guide/index.md</span><br><span class="line">index_bak=./source/guide/index_bak.md</span><br><span class="line"># 文本格式 </span><br><span class="line">content_pattern=&apos;- id，[title](https://www.playpi.org/id.html)&apos;</span><br><span class="line"># 遍历文件夹内的所有文件 </span><br><span class="line">for file in ./source/_posts/*.md</span><br><span class="line">do</span><br><span class="line">  if [-f $file]; then</span><br><span class="line">    # 获取单个文件的 id【在第 3 行】 和 title【在第 2 行】</span><br><span class="line">    echo &apos;================================================================&apos;</span><br><span class="line">    # echo &apos;====read file:&apos; $file</span><br><span class="line">    var1=$(grep -nE &apos;^id: [0-9]&#123;10&#125;&apos; $file | grep -E &apos;^3:id: [0-9]&#123;10&#125;&apos; | awk -F&apos;: &apos; &apos;&#123;print $2;&#125;&apos;)</span><br><span class="line">    # echo &apos;====read id:&apos; $var1</span><br><span class="line">    var2=$(grep -n &apos;^title: &apos; $file | grep &apos;^2:title: &apos; | awk -F&apos;: &apos; &apos;&#123;print $2;&#125;&apos;)</span><br><span class="line">    # echo &apos;====read title:&apos; $var2</span><br><span class="line">    # 判断非空必须使用双引号，否则逻辑错误 </span><br><span class="line">    if [-n &quot;$var1&quot;] &amp;&amp; [-n &quot;$var2&quot;]; then</span><br><span class="line">      has=$(grep $var1 $index)</span><br><span class="line">      # 为空，表示 id 不在 index 文件中，has 变量切记使用双引号 </span><br><span class="line">      if [-z &quot;$has&quot;]; then</span><br><span class="line">        # 字符串搜索替换，待搜索字符串是变量，不是字符串本身，// 表示替换所有 </span><br><span class="line">        content=$&#123;content_pattern//id/$var1&#125;</span><br><span class="line">        content=$&#123;content/title/$var2&#125;</span><br><span class="line">        # 追加到 index 文件中 </span><br><span class="line">        echo &apos;====prepare append to index:&apos; $content</span><br><span class="line">        # 重命名 index 文件 </span><br><span class="line">        mv $index $index_bak</span><br><span class="line">        # 标记是否写入 / 是否同一年份 </span><br><span class="line">        has_write=&apos;&apos;</span><br><span class="line">        is_same_year=&apos;&apos;</span><br><span class="line">        while read line</span><br><span class="line">        do</span><br><span class="line">          match_id=$(echo $line | grep -E &apos;^- [0-9]&#123;10&#125;，\[&apos; | awk -F&apos;，&apos; &apos;&#123;print $1;&#125;&apos; | awk -F&apos; &apos; &apos;&#123;print $2;&#125;&apos;)</span><br><span class="line">          # 搜索到匹配内容并且还没写入 </span><br><span class="line">          if [-n &quot;$match_id&quot;] &amp;&amp; [-z &quot;$has_write&quot;]; then</span><br><span class="line">            # echo &apos;====compare,match_id:&apos; $match_id</span><br><span class="line">            # 判断是否相同年份 </span><br><span class="line">            if [$&#123;var1:0:4&#125; == $&#123;match_id:0:4&#125;]; then</span><br><span class="line">              is_same_year=&apos;1&apos;</span><br><span class="line">              # 比较大小 </span><br><span class="line">              if [$var1 -gt $match_id]; then</span><br><span class="line">                echo &apos;====gt match_id append to index:&apos; $content</span><br><span class="line">                echo $content &gt;&gt; $index</span><br><span class="line">                echo $line &gt;&gt; $index</span><br><span class="line">                has_write=&apos;1&apos;</span><br><span class="line">              else</span><br><span class="line">                echo $line &gt;&gt; $index</span><br><span class="line">              fi</span><br><span class="line">            else</span><br><span class="line">              echo $line &gt;&gt; $index</span><br><span class="line">            fi</span><br><span class="line">          elif [-n &quot;$is_same_year&quot;] &amp;&amp; [-z &quot;$has_write&quot;]; then</span><br><span class="line">            # 当前行没有搜索到匹配内容，并且同一年份，并且还没写入，说明已经是当前年份的最后一行了，直接写入即可 </span><br><span class="line">            echo &apos;====last append to index:&apos; $content</span><br><span class="line">            echo $content &gt;&gt; $index</span><br><span class="line">            echo $line &gt;&gt; $index</span><br><span class="line">            has_write=&apos;1&apos;</span><br><span class="line">          else</span><br><span class="line">            # 没有搜索到匹配内容，或者不同年份，或者已经写入，直接写入即可 </span><br><span class="line">            echo $line &gt;&gt; $index</span><br><span class="line">          fi</span><br><span class="line">        done &lt; $index_bak</span><br><span class="line">        # 删除 index_bak 文件，此时只有最新的 index 文件 </span><br><span class="line">        rm $index_bak</span><br><span class="line">      else</span><br><span class="line">      # 在 index 文件中已经存在，无需处理 </span><br><span class="line">      echo &apos;====index has:&apos; $var1</span><br><span class="line">      fi</span><br><span class="line">    else</span><br><span class="line">    echo &apos;!!!!invalid var:&apos; $var1 $var2</span><br><span class="line">    fi</span><br><span class="line">  else</span><br><span class="line">  echo &apos;!!!!invalid file:&apos; $file</span><br><span class="line">  fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p> 执行脚本时会打印解析出来的每条 id 与 title，以及写入的原因【比较后写入、最后一条写入】，第一次执行脚本耗时久一点，后续执行会自动跳过已经收集过的，耗时可以忽略。</p><p>由于实现思路简化了，所以要求 index 文件在每一年都至少已经有一个完整的记录，否则没法对比写入。</p><p>注意，正则搜索时在必要情况下使用 <strong>-E</strong> 选项开启扩展模式，否则正则无效，仍旧是普通的字符串。</p><p>日期格式的字符串比较大小，由于格式规范，都是十位数字，可以直接转为数字比较，大的就代表日期最新。</p><p>当然，日期格式的字符串比较大小，也可以先转为时间戳数字，再进行比较，示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date +% s -d &apos;2019010101&apos;</span><br></pre></td></tr></table></figure><p>虽然这种格式得到的结果不是真正的时间戳，但是只要是数字就可以比较了。另外，经过查找帮助手册，没有发现可以指定格式的参数选项，也就是无法把 <strong>YYMMddHH</strong> 格式的日期字符串转为对应的真实时间戳。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近给博客站点增加了一个独立的页面：&lt;strong&gt; 指南 &lt;/strong&gt;，用来记录本站点的所有文章，包括发表时间与文章链接，并按照发表时间倒序排列，仅供快速查找以及核对使用。其中，还会有一个文章编号，就是 url 的数字部分，由日期与编号组成，例如 2019050201 表示 2019 年 05 月 02 日发表的第 1 篇文章，这个文章编号对我来说很有用，用来核对查重。但是，为了简化这个页面的整理工作以及后续的自动生成，我需要把这个流程自动化，本文记录实现思路与实现方式。&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://www.playpi.org/categories/building/"/>
    
    
      <category term="guide" scheme="https://www.playpi.org/tags/guide/"/>
    
      <category term="Shell" scheme="https://www.playpi.org/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>使用 Java 代码迁移微博图床到 GitHub 图床</title>
    <link href="https://www.playpi.org/2019050201.html"/>
    <id>https://www.playpi.org/2019050201.html</id>
    <published>2019-05-01T18:12:24.000Z</published>
    <updated>2019-05-02T18:12:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>由于微博图床开启了防盗链，导致我的博客里面的图片全部不可见，因此要切换图床。当然，一开始我使用的是极其简单的方法，直接设置博客页面的 <strong>referer</strong> 属性即可【设置为 noreferrer】，这样微博图床就检测不到引用来源，也就不会拒绝访问了。但是后续又遇到了其它问题，这些内容我在前几天的博客里面都记录了：<a href="https://www.playpi.org/2019042701.html">解决微博图床防盗链的问题 </a> 。后来我实在找不到更为恰当的解决方案，于是决定直接迁移图床。本来一开始准备使用 PicGo 这个工具，但是发现有问题，在我比较着急的情况下，决定自己写一写代码，完成迁移操作。本文就记录这些代码的逻辑。</p><a id="more"></a><h1 id="依赖构件"><a href="# 依赖构件" class="headerlink" title="依赖构件"></a> 依赖构件 </h1><p> 为了减少代码量，精简代码，需要引入几个第三方 jar 包，当然不引入也行，如果不引入有一些繁琐而又简单的业务逻辑需要自己实现，有点浪费时间了。</p><p>主要要依赖几个 <code>jar</code> 包：处理文件的 <code>io</code> 包、处理网络请求的 <code>httpclient</code> 包、处理 <code>git</code> 的 <code>jgit</code> 包，<code>pom.xml</code> 配置文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.5.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.8.0.201706111038-r&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="代码结构"><a href="# 代码结构" class="headerlink" title="代码结构"></a>代码结构 </h1><p> 写代码也比较简单，主要有四个步骤：读取 <code>Markdown</code> 文件内容并利用正则抽取微博图床的图片链接、下载所有图片并上传至 <code>GitHub</code>、替换内容中抽取出的所有图片链接为 <code>GitHub</code> 的图片链接、内容写回新文件。</p><p>使用 <code>Java</code> 处理不需要多少代码，大概有不到 200 行代码，真正的业务逻辑代码更少，当然，关于网络请求的部分还是不够精简，目前我觉得能用就行。代码放在 <code>GitHub</code> 上面，仅供参考：<a href="https://github.com/iplaypi/iplaypistudy/tree/master/iplaypistudy-normal/src/main/java/org/playpi/study/migratepic" target="_blank" rel="noopener">MigratePic.java</a> ，搜索 <strong>MigratePic</strong> 类即可。</p><p>代码主体调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main (String [] args) &#123;</span><br><span class="line">    //        String dir = &quot;e:\baktest&quot;;</span><br><span class="line">    //        String outDir = &quot;e:\baktest-out&quot;;</span><br><span class="line">    String dir = &quot;e:\bak&quot;;</span><br><span class="line">    String outDir = &quot;e:\bak-out&quot;;</span><br><span class="line">    Set&lt;File&gt; fileSet = getAllFiles (dir);</span><br><span class="line">    LOGGER.info (&quot;==== 文件个数:&quot; + fileSet.size ());</span><br><span class="line">    for (File file : fileSet) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 1 - 读取文件，抽取微博图床的链接与图片名称 </span><br><span class="line">            String content = FileUtils.readFileToString (file, &quot;utf-8&quot;);</span><br><span class="line">            Map&lt;String, String&gt; imgMap = extractImg (content);</span><br><span class="line">            // 2 - 下载图片并上传至 GitHub</span><br><span class="line">            Map&lt;String, String&gt; urlMap = uploadGithub (imgMap);</span><br><span class="line">            // 3 - 替换所有链接 </span><br><span class="line">            content = replaceUrl (content, urlMap);</span><br><span class="line">            // 4 - 内容写回新文件 </span><br><span class="line">            String outFile = outDir + File.separator + file.getName ();</span><br><span class="line">            FileUtils.writeStringToFile (new File (outFile), content, &quot;utf-8&quot;);</span><br><span class="line">            LOGGER.info (&quot;==== 处理文件完成:&#123;&#125;, 获取新浪图床链接个数:&#123;&#125;, 上传 GitHub 个数:&#123;&#125;&quot;, file.getAbsolutePath (), imgMap.size (), urlMap.size ());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要指定输入、输出目录。</p><p>截图如下：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190504004133.png" alt="代码主体调用" title="代码主体调用"></p><p>其中，<strong>getAllFiles</strong> 方法是获取指定目录的所有文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 获取指定文件夹内的所有文件 </span><br><span class="line">     *</span><br><span class="line">     * @param dir</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">private static Set&lt;File&gt; getAllFiles (String dir) &#123;</span><br><span class="line">    Set&lt;File&gt; fileSet = new HashSet&lt;&gt;();</span><br><span class="line">    File file = new File (dir + File.separator);</span><br><span class="line">    for (File textFile : file.listFiles ()) &#123;</span><br><span class="line">        fileSet.add (textFile.getAbsoluteFile ());</span><br><span class="line">    &#125;</span><br><span class="line">    return fileSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码的细节中，可以看到我是每个文件单独处理的，比较耗时间的就是下载图片、上传到 <code>GitHub</code> 这两个过程，而且由于我是文件分开处理，所以总的时间更长了。如果想节约点时间，可以一次性把所有的图片全部下载完成，最后一次提交到 <code>GitHub</code> 即可，这样就节约了多次频繁地与 <code>GitHub</code> 建立连接、断开连接所消耗的时间，如果是几次提交无所谓，但是几十次提交就多消耗很多时间了。例如按照我这个量，78 个文件，500-600 张图片，运行程序消耗了十几分钟，但是我估计如果一次性处理完成，时间应该在 5 分钟以内。</p><p>接下来分别描述四个步骤。</p><h2 id="读取文件抽取图片链接"><a href="# 读取文件抽取图片链接" class="headerlink" title="读取文件抽取图片链接"></a>读取文件抽取图片链接 </h2><p><code>Markdown</code> 文件其实也就是普通的文本文件，没有特殊的格式，这就给程序处理带来了极大方便，直接使用工具包读取就行。此外，抽取微博图床的图片链接需要使用正则表达式，代码内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static Pattern PATTERN = Pattern.compile (&quot;https://[0-9a-zA-Z]&#123;3&#125;\.sinaimg\.cn/large/[0-9a-zA-Z]&#123;8,50&#125;\.jpg&quot;);</span><br><span class="line">/**</span><br><span class="line">     * 抽取微博图床的图片链接与图片文件名 </span><br><span class="line">     *</span><br><span class="line">     * @param string</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">private static Map&lt;String, String&gt; extractImg (String string) &#123;</span><br><span class="line">    Map&lt;String, String&gt; imgMap = new HashMap&lt;&gt;();</span><br><span class="line">    Matcher matcher = PATTERN.matcher (string);</span><br><span class="line">    while (matcher.find ()) &#123;</span><br><span class="line">        String oldUrl = matcher.group ();</span><br><span class="line">        int index = oldUrl.lastIndexOf (&quot;/&quot;);</span><br><span class="line">        if (0 &lt; index) &#123;</span><br><span class="line">            String imgName = oldUrl.substring (index + 1);</span><br><span class="line">            imgMap.put (oldUrl, imgName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return imgMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里列举一个图片链接的例子：<br><a href="https://ws1.sinaimg.cn/large/b7f2e3a3gy1g2hlkwnfm9j214a0hr75v.jpg" target="_blank" rel="noopener">https://ws1.sinaimg.cn/large/b7f2e3a3gy1g2hlkwnfm9j214a0hr75v.jpg</a> 。</p><h2 id="下载图片并上传新图床"><a href="# 下载图片并上传新图床" class="headerlink" title="下载图片并上传新图床"></a>下载图片并上传新图床 </h2><p> 这是一个很重要的步骤，需要把上一个步骤完成后获取到的图片下载下来，并且提交到 <code>GitHub</code> 上面去【提交可以不使用代码，直接手动提交也行】，然后获取新图片链接。</p><p>为了完成这个步骤，需要先在 <code>GitHub</code> 上面新建一个项目，专门用来存放图片，然后把这个项目 <code>clone</code> 到本地，用来存放下载的图片，最后直接提交即可。</p><p>下载图片并提交到 <code>GitHub</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static String githubUrl = &quot;https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/&quot;;</span><br><span class="line">/**</span><br><span class="line">     * 提交本地的图片到 GitHub, 并拼接新的图片链接 </span><br><span class="line">     *</span><br><span class="line">     * @param imgMap</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">private static Map&lt;String, String&gt; uploadGithub (Map&lt;String, String&gt; imgMap) &#123;</span><br><span class="line">    String imgDir = &quot;E:\img\img-playpi\img\old\&quot;;</span><br><span class="line">        Map&lt;String, String&gt; urlMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : imgMap.entrySet ()) &#123;</span><br><span class="line">            String oldUrl = entry.getKey ();</span><br><span class="line">            String imgName = entry.getValue ();</span><br><span class="line">            boolean isSuc = downloadImg (oldUrl, imgDir, imgName);</span><br><span class="line">            if (isSuc) &#123;</span><br><span class="line">                String newUrl = githubUrl + imgName;</span><br><span class="line">                urlMap.put (oldUrl, newUrl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info (&quot;==== 开始上传文件到 GitHub, size: &#123;&#125;&quot;, urlMap.size ());</span><br><span class="line">        // 统一上传到 GitHub, 这一步骤可以省略，留到最后手动提交即可 </span><br><span class="line">        boolean gitSuc = JGitUtil.commitAndPush (&quot;add and commit by Java client,img size: &quot; + urlMap.size ());</span><br><span class="line">        if (!gitSuc) &#123;</span><br><span class="line">            urlMap.clear ();</span><br><span class="line">        &#125;</span><br><span class="line">        return urlMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意下载图片需要指定本地项目的路径，方便提交到 <code>GitHub</code>，例如我这里是 <strong>E:\img\img-playpi\img\old\</strong>，拼接 <code>GitHub</code> 的图片链接时需要指定固定的域名部分、用户名、分支名、子目录，例如我这里是：<br><strong><a href="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/" target="_blank" rel="noopener">https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/</a> </strong>。</p><p>这里列举一个 <code>GitHub</code> 图片链接的例子：<br><a href="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/20190502183444.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/20190502183444.png</a> 。</p><p>下载图片的详细逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 下载图片到指定的文件目录 </span><br><span class="line">     */</span><br><span class="line">public static Boolean downloadImg (String url, String dir, String fileName) &#123;</span><br><span class="line">    Boolean isSuc = false;</span><br><span class="line">    HttpClient httpclient = null;</span><br><span class="line">    int retry = 5;</span><br><span class="line">    while (0 &lt; retry--) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            httpclient = new DefaultHttpClient ();</span><br><span class="line">            HttpGet httpget = new HttpGet (url);</span><br><span class="line">            httpget.setHeader (&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.79 Safari/537.1&quot;);</span><br><span class="line">            httpget.setHeader (&quot;Accept&quot;, &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;);</span><br><span class="line">            HttpResponse resp = httpclient.execute (httpget);</span><br><span class="line">            if (HttpStatus.SC_OK == resp.getStatusLine ().getStatusCode ()) &#123;</span><br><span class="line">                HttpEntity entity = resp.getEntity ();</span><br><span class="line">                InputStream in = entity.getContent ();</span><br><span class="line">                isSuc = savePicToDisk (in, dir, fileName);</span><br><span class="line">                return isSuc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">            LOGGER.error (&quot;!!!! 下载失败，重试一次 & quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            httpclient.getConnectionManager ().shutdown ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isSuc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 根据输入流，保存内容到指定的目录文件 </span><br><span class="line">     *</span><br><span class="line">     * @param in</span><br><span class="line">     * @param dirPath</span><br><span class="line">     * @param filePath</span><br><span class="line">     */</span><br><span class="line">private static Boolean savePicToDisk (InputStream in, String dirPath, String filePath) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        File dir = new File (dirPath);</span><br><span class="line">        if (dir == null || !dir.exists ()) &#123;</span><br><span class="line">            dir.mkdirs ();</span><br><span class="line">        &#125;</span><br><span class="line">        // 拼接文件完整路径 </span><br><span class="line">        String realPath = dirPath.concat (filePath);</span><br><span class="line">        File file = new File (realPath);</span><br><span class="line">        if (file == null || !file.exists ()) &#123;</span><br><span class="line">            file.createNewFile ();</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream fos = new FileOutputStream (file);</span><br><span class="line">        byte [] buf = new byte [1024];</span><br><span class="line">        int len = 0;</span><br><span class="line">        while ((len = in.read (buf)) != -1) &#123;</span><br><span class="line">            fos.write (buf, 0, len);</span><br><span class="line">        &#125;</span><br><span class="line">        fos.flush ();</span><br><span class="line">        fos.close ();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace ();</span><br><span class="line">        LOGGER.error (&quot;!!!! 写入文件失败 & quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            in.close ();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交图片到 <code>GitHub</code> 的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 提交并推送代码至远程服务器 </span><br><span class="line"> *</span><br><span class="line"> * @param desc 提交描述 </span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static boolean commitAndPush (String desc) &#123;</span><br><span class="line">    boolean commitAndPushFlag = false;</span><br><span class="line">    try (Git git = Git.open (new File (LOCAL_REPOGIT_CONFIG))) &#123;</span><br><span class="line">        UsernamePasswordCredentialsProvider provider = new UsernamePasswordCredentialsProvider (GIT_USERNAME, GIT_PASSWORD);</span><br><span class="line">        git.add ().addFilepattern (&quot;.&quot;).call ();</span><br><span class="line">        // 提交 </span><br><span class="line">        git.commit ().setMessage (desc).call ();</span><br><span class="line">        // 推送到远程，不报错默认为成功 </span><br><span class="line">        git.push ().setCredentialsProvider (provider).call ();</span><br><span class="line">        commitAndPushFlag = true;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace ();</span><br><span class="line">        LOGGER.error (&quot;Commit And Push error!&quot; + e.getMessage ());</span><br><span class="line">    &#125;</span><br><span class="line">    return commitAndPushFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里需要指定本地项目的配置文件路径，例如我的是 <strong>E:\img\img-playpi\.git</strong>，与前面的下载路径是在同一个父目录，另外还需要指定用户名密码。</p><h2 id="使用新链接替换旧链接"><a href="# 使用新链接替换旧链接" class="headerlink" title="使用新链接替换旧链接"></a>使用新链接替换旧链接 </h2><p> 如果前面的步骤完成，就说明图片已经被成功迁移到 <code>GitHub</code> 上面，并且获取到了新的图片链接，接着直接替换掉旧链接即可。</p><p>代码逻辑如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 替换所有的图片链接 </span><br><span class="line"> *</span><br><span class="line"> * @param string</span><br><span class="line"> * @param urlMap</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static String replaceUrl (String string, Map&lt;String, String&gt; urlMap) &#123;</span><br><span class="line">    for (Map.Entry&lt;String, String&gt; entry : urlMap.entrySet ()) &#123;</span><br><span class="line">        String oldUrl = entry.getKey ();</span><br><span class="line">        String newUrl = entry.getValue ();</span><br><span class="line">        string = string.replaceAll (oldUrl, newUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替换后内容写回新文件"><a href="# 替换后内容写回新文件" class="headerlink" title="替换后内容写回新文件"></a>替换后内容写回新文件 </h2><p> 写入新文件是很简单的，直接调用 <code>io</code> 包即可完成，但是为了安全起见，文件放在新的目录中，不要直接替换掉原来的文件，否则程序出现意外就麻烦了。</p><h1 id="迁移结果"><a href="# 迁移结果" class="headerlink" title="迁移结果"></a>迁移结果 </h1><p> 随意打开一篇博客，使用文件对比工具查看替换前后的区别，可以看到除了图片链接被替换掉，其它内容没有任何变化。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190504004204.png" alt="替换文件对比" title="替换文件对比"></p><p>在本地仓库查看，图片已经全部下载。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190504004224.png" alt="在本地仓库查看" title="在本地仓库查看"></p><p>在 <code>GitHub</code> 的仓库中查看，图片全部推送。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190504004216.png" alt="在 GitHub 的仓库中查看" title="在 GitHub 的仓库中查看"></p><p>任意打开一篇博客，里面的图片已经可以全部正常显示，只不过有一些太大的图片【超过 1MB 的】加载速度有点慢，还可以接受。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;由于微博图床开启了防盗链，导致我的博客里面的图片全部不可见，因此要切换图床。当然，一开始我使用的是极其简单的方法，直接设置博客页面的 &lt;strong&gt;referer&lt;/strong&gt; 属性即可【设置为 noreferrer】，这样微博图床就检测不到引用来源，也就不会拒绝访问了。但是后续又遇到了其它问题，这些内容我在前几天的博客里面都记录了：&lt;a href=&quot;https://www.playpi.org/2019042701.html&quot;&gt;解决微博图床防盗链的问题&lt;/a&gt; 。后来我实在找不到更为恰当的解决方案，于是决定直接迁移图床。本来一开始准备使用 PicGo 这个工具，但是发现有问题，在我比较着急的情况下，决定自己写一写代码，完成迁移操作。本文就记录这些代码的逻辑。&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://www.playpi.org/categories/building/"/>
    
    
      <category term="GitHub" scheme="https://www.playpi.org/tags/GitHub/"/>
    
      <category term="weibo" scheme="https://www.playpi.org/tags/weibo/"/>
    
      <category term="image" scheme="https://www.playpi.org/tags/image/"/>
    
  </entry>
  
  <entry>
    <title>解决微博图床防盗链的问题</title>
    <link href="https://www.playpi.org/2019042701.html"/>
    <id>https://www.playpi.org/2019042701.html</id>
    <published>2019-04-27T08:57:20.000Z</published>
    <updated>2019-04-27T08:57:20.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>对于不少自己搭建博客的人来说，图床的选择可真是一个大难点，以前还有各种免费好用的图床工具，例如七牛云、又拍云、SM.MS、Imgur、GitHub、微博图床等，当然还有腾讯云、阿里云的云存储服务，但是免费的意味着不稳定，说不定哪天图片就没有了，有一些国外的访问速度又不行，国内的云存储服务商收费又比较高，还有的必须绑定认证的域名才能使用。本来搭建一个小小的博客，只为了记录知识，传播技术，遇到耗财或者耗精力的这种问题，都比较头疼。</p><p>后来纠结了好几天，最终决定使用免费的 <strong>微博图床 </strong>，一是因为新浪微博这家厂商体量大，微博图床短期内应该不会出问题，二是看到好多网友说他们已经稳定使用微博图床 3-5 年了，没有出过问题。我大概使用的时间还没有一年，以前都是本地化的，没有整理成完整的文章，后来开始慢慢整理并部署上线。没想到最近【2019 年 4 月 24 日左右发现】微博图床出问题了，访问图片链接全部是返回 403 状态码，表示拒绝访问，其实是微博图床开启了防盗链，本文就记录这个现象以及可行的解决方案。</p><a id="more"></a><h1 id="微博图床防盗链开启"><a href="# 微博图床防盗链开启" class="headerlink" title="微博图床防盗链开启"></a>微博图床防盗链开启 </h1><h2 id="初始现象"><a href="# 初始现象" class="headerlink" title="初始现象"></a> 初始现象 </h2><p> 在 2019 年 4 月 24 日的时候，我发现一个严重的问题，我的博客里面的图片显示不出来了，并不是被封了，如果被封也会显示图片的，只不过是马赛克图片。发现这个问题的缘由是新写了一篇博客，本地生成测试的时候，发现图片全部不显示了，一开始还以为是网络问题。</p><p>博客里面的图片全部无法正常显示 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hfpnoi01j20lc0i00tr.jpg" alt="图片全部无法正常显示" title="图片全部无法正常显示"></p><p> 接着我随机抽了一些图片链接在浏览器中直接打开看，发现是可以看到图片的，然后在博客中还是看不到图片，如果在博客中选择图片链接，使用右键 <strong>在新标签页中打开 </strong>，也是不能看到。这就说明微博图床开始检测请求的合法性了，对于不正常的请求统统拒绝。</p><p>当然，如果直接使用图片的链接在浏览器中单独打开，是可以看到图片的，紧接着在博客中就可以看到对应的图片了，但是这并不是说明图片可以使用了，其实是浏览器的缓存作用，如果及时清除浏览器的缓存，发现又不能使用了。</p><p>复制图片地址在浏览器中打开，图片可以正常显示 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hfpvew8yj212p0k2q3i.jpg" alt="在浏览器中打开图片可以正常显示" title="在浏览器中打开图片可以正常显示"></p><h2 id="分析现象"><a href="# 分析现象" class="headerlink" title="分析现象"></a> 分析现象 </h2><p> 接着使用浏览器的调试工具查看详细的请求信息，按 <strong>F12</strong> 按键，调出调试工具，刷新网页，使用 <strong>jpg</strong> 过滤无效内容，可以看到所有的图片访问请求结果都是 403，也就是拒绝访问。</p><p>随便点开一个链接的请求信息，查看 Status Code 为 403，也就是拒绝访问，注意查看请求头的 <strong>Referer</strong> 参数，值是一个链接，表示当前请求所属的页面，即 <strong>引用来源 </strong>，而新浪微博恰好会检测这个参数，拒绝所有的外链请求，即不是从新浪的站点发送的图片请求。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hfqpbdc6j20rd0g1abk.jpg" alt="403 拒绝访问" title="403 拒绝访问"></p><p>原来，近期微博图床对图片 CDN 添加了引用来源【Referer】检测，非微博站内引用将会返回 403 错误码，即拒绝访问。那能不能伪造或者清除这个参数呢，其实是可以的，只不过伪造、清除都需要增加一些 Javascript 动态脚本来处理，需要一些技术支持。</p><p>如果选择清除 Referer 参数，可以先验证一下，把图片的链接直接复制到浏览器中访问，就不会有这个参数，发现可以正常访问，没有 403 错误。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hfroxnhfj20oa0ijq3w.jpg" alt="单独在浏览器中访问" title="单独在浏览器中访问"></p><p>注意，一开始我发现使用浏览器能直接访问，紧着着博客里面的图片也能访问了，我还以为是需要单独访问一次图片，然后就可以任意访问了，后来发现其实是浏览器缓存的作用，空欢喜一场。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hfsl0troj20ph0dujsl.jpg" alt="缓存欺骗了我" title="缓存欺骗了我"></p><p>也看到有说法是，微博图床仅仅针对开启 SSL 的链接【即 HTTPS】实行站外禁止访问，而普通的 HTTP 链接仍旧安然无恙，这种说法是错误的【但是确实有这种现象出现】。我测试了一下，的确是有这样的现象，前提是来源页面开启了 SSL，而图床链接使用基本的 HTTP，这样的话由于 <strong>Referer</strong> 的特性，请求图片链接时不会传输 <strong>Referer</strong> 这个参数的值【即来源页面的信息不会传递给请求页面】，微博图床自然也就无法检测了。所以最简单的方案就是把所有微博图床的链接全部由 HTTPS 替换为 HTTP，但是由于我的博客全面开启了 SSL，为了加绿锁，因此不引用普通的 HTTP 链接，这种简单的方案我就无法采用了，只能遗憾舍弃。</p><h1 id="解决方案"><a href="# 解决方案" class="headerlink" title="解决方案"></a>解决方案 </h1><p> 考虑切换图床，免费的已经基本没有了，收费的比较贵，或者找到方案先临时使用，不然会给查看博客的人带来很大困扰，毕竟没有图片的博客怎么能看，这也影响博客的质量与声誉。</p><h2 id="尝试清除来源引用"><a href="# 尝试清除来源引用" class="headerlink" title="尝试清除来源引用"></a>尝试清除来源引用 </h2><p> 在静态网页的 <strong>头部 </strong>代码中【即 head 标记】添加如下配置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</span><br></pre></td></tr></table></figure><p>它的作用就是阻止浏览器发送 <strong>Referer</strong> 信息，对整个页面的所有链接生效【当然也有针对单个链接设置的方法：&lt;a rel=”noreferrer” href=”your-website-url” /&gt;，这里不采用】，这样一来微博图床就不知道请求的引用来源了，可以达到和直接在浏览器中访问一样的效果。<strong> 但是要注意，不是每种浏览器都支持这种语法的，此设置对有的浏览器来说无效。</strong></p><p>那么在 Hexo 框架中怎么增加呢，显然不会有相关配置项，只能更改源代码，而且使用了 Next 主题，应该要更改主题的源代码，以保证 Hexo 在渲染静态页面为每个页面都增加这个配置。查阅文档，了解了渲染模板所在位置，打开 <strong>themes/next/layout/_partials/head.swig</strong> 文件，在里面添加 meta 标记就行。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hit3tj2sj20nn07eq3f.jpg" alt="修改 head.swig 文件" title="修改 head.swig 文件"></p><p>修改完成后查看页面的源代码，已经有这个属性了，并且所有的图片都可以正常访问了，完美。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hiusk7jqj20tu091gmn.jpg" alt="查看页面的源代码" title="查看页面的源代码"></p><p>但是我觉得这肯定不是长久之计，以后说不定还会有幺蛾子出现，所以要随时准备着。</p><h2 id="尝试其他方案"><a href="# 尝试其他方案" class="headerlink" title="尝试其他方案"></a>尝试其他方案 </h2><p> 先观察一段时间，这段时间要考虑其他方案的可行性和成本。</p><h2 id="建议"><a href="# 建议" class="headerlink" title="建议"></a>建议 </h2><p> 微博图床开启防盗链，个人博客对于新浪图床的依赖时代基本要告别了，虽然有其他免费图床可以使用，但稳定性和可持续性上显然无法与大企业维护的图床相比。为了博客内容稳定考虑，还是考虑后续逐渐把图片迁移到其他云存储空间，费用方面能承受就行。</p><h1 id="其他知识点"><a href="# 其他知识点" class="headerlink" title="其他知识点"></a>其他知识点 </h1><h2 id="微博图床简单介绍"><a href="# 微博图床简单介绍" class="headerlink" title="微博图床简单介绍"></a> 微博图床简单介绍 </h2><p> 对于大多数个人博客维护者而言，免费的图床既节省成本，也能够提升页面访问的速度，而新浪微博图床则成了首选。</p><p>新浪微博由于本身体量大，其图床免费无限容量，只需要有一个微博账号就可使用。同时具备全网 CDN 加速，支持 HTTPS，无论是国内还是国外网络访问，速度都很不错。而且新浪如此企业，不会像其他个人或者团队经营的免费图床一样随时可能会关掉。</p><p>基于这些优势，不少人会优先选择新浪微博图床作为网站提供图片服务。毕竟直接挂 CDN 或者自建图床的话，也是一个持久的付费维护，如果一旦被攻击，更是造成费用暴增。</p><h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><p><strong>Referer</strong> 首部包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 <strong>Referer</strong> 首部识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。同时也让服务器能够发现过时的和错误的链接并及时维护。</p><p>需要注意的是 <strong>referer</strong> 实际上是 <strong>referrer</strong> 的误拼写，它可能是 HTTP 协议中第一个被拼写错误的标准头，为保持向下兼容就将错就错了。可以参见 RFC 文档的 Referer 的介绍：<br><a href="https://tools.ietf.org/html/rfc2616#section-14.36" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616#section-14.36</a> ，原文有这样的描述：</p><blockquote><p>the “referrer”, although the header field is misspelled.</p></blockquote><p>此外还可以参考维基百科的相关介绍：<br><a href="https://zh.wikipedia.org/wiki/HTTP% E5%8F%83% E7%85% A7% E4% BD%8D% E5%9D%80" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/HTTP% E5%8F%83% E7%85% A7% E4% BD%8D% E5%9D%80</a> 。</p><p>在以下几种情况下，<strong>Referer</strong> 不会被发送 </p><ul><li> 来源页面采用的协议为表示本地文件的 file 或者 data URI</li><li>当前请求页面采用的是非安全协议，而来源页面采用的是安全协议【HTTPS】</li><li>为整个页面设置 &lt;meta name=”referrer” content=”no-referrer” /&gt;</li><li>为单个链接设置 &lt;a rel=”noreferrer” href=”your-website-url” /&gt;</li></ul><p>注意第二种情况，如果你的博客开启了 SSL，可以使用 HTTP 的图片链接，就可以正常访问了。但是要牺牲你的博客的安全性，因为浏览器会检测到你的博客内容里面有普通的 HTTP 链接，就会导致不可信【尽管存在有效的证书，也没有用】，小绿锁会消失，并给出警告。</p><p>例如我的博客，为了测试，使用了一个 HTTP 图片链接，其它的图片都是 HTTPS 链接，可以发现 HTTP 的图片可以正常访问，其它的图片仍旧被拒绝访问了。此时，发现博客的小绿锁已经没有了，并且给出了警告提示。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2hlkwnfm9j214a0hr75v.jpg" alt="不安全的方案" title="不安全的方案"></p><h1 id="后记"><a href="# 后记" class="headerlink" title="后记"></a>后记 </h1><p> 使用上述的解决方案后，我又发现了一个严重的问题，由于清除了引用来源 referer，博客文章的地址就不会发送出去，导致我的 <strong>不蒜子 </strong>统计失效，也就是每篇文章的阅读数、整个站点的访问量【pv】、整个站点的访客数【uv】都会停止统计。这会导致整个博客的动态流量不可见，对于写博客的我来说内心会有一点点失落，所以我要想办法解决这个问题。</p><p>已经知道问题的根源了，解决起来也是很容易的，直接开启引用来源 referer 即可，但是由于和微博图床的图片防盗链冲突，不能同时开启。也就是说除了微博图床的防盗链要关闭 referer，其它的链接仍旧正常开启，看看能不能想办法只把微博图床的链接关闭 referer。</p><p>标记 a 可以增加 ref=”noreferrer” 属性，但是在 Hexo 中我无法找到合适的方式来完成这个操作。本来准备在 <strong>_macro/post.swig</strong> 中对渲染后的标记属性进行替换，示例 swig 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; post.content|replace (&apos;group&apos;, &apos;noreferrer&apos;, &apos;g&apos;) &#125;&#125;</span><br></pre></td></tr></table></figure><p>把 <strong>ref=”group”</strong> 替换为 <strong>ref=”noreferrer”</strong>，但是测试后发现行不通，传递过来的 <strong>content</strong> 只包含 p 标记，并没有 a 标记，也就是说明 a 标记是在其它地方渲染的。</p><p>而如果直接在渲染标记 a 的地方进行选择性替换，发现微博图床的图片链接，就把 ref 属性替换掉，需要去更改 Hexo 的源代码，其中有一个 <strong>markdown (str)</strong> 方法，显然这种临时方案不合理，也很麻烦。</p><p>为了稳定地解决这个问题，我还是决定更换图床，然后使用第三方工具进行图片迁移。</p><h2 id="更换图床"><a href="# 更换图床" class="headerlink" title="更换图床"></a>更换图床 </h2><p> 和以前一样，挑选了一圈，也是很纠结，最终还是下定决心直接使用 GitHub 了，稳定又方便。其实就是新建一个仓库，专门用来存放图片，只不过需要考虑一下图片过多、图片过大会不会被 GitHub 限制。</p><p>去 GitHub 搜索帮助文档，<a href="https://help.github.com/en/articles/what-is-my-disk-quota" target="_blank" rel="noopener">帮助文档信息 </a> ，可以得知仓库最大为 100GB，但是官方建议保持在 1GB 以下，单个文件低于 100MB，因此用来存放文件绰绰有余。另外需要注意，仓库文件超过 1GB 时会收到 GitHub 的提醒邮件，超过 75GB 时，每次在提交时都会收到警告。</p><p> 原文描述如下：</p><blockquote><p>We recommend repositories be kept under 1GB each. Repositories have a hard limit of 100GB. If you reach 75GB you’ll receive a warning from Git in your terminal when you push. This limit is easy to stay within if large files are kept out of the repository. If your repository exceeds 1GB, you might receive a polite email from GitHub Support requesting that you reduce the size of the repository to bring it back down.</p></blockquote><blockquote><p>In addition, we place a strict limit of files exceeding 100 MB in size.</p></blockquote><p>既然有这种限制，最好还是把图片压缩一下，推荐使用图片压缩工具：<a href="https://github.com/meowtec/Imagine" target="_blank" rel="noopener">Imagine</a> ，这个工具可以实时看到压缩效果，而且压缩率还不错，能到 50%。但是，如果想要保持图片的色彩度、还原度，压缩效果肯定是不行的，甚至有时候压缩后的图片比压缩前的还大。</p><p>压缩图片示例 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/20190502183444.png" alt="压缩图片示例" title="压缩图片示例"></p><h2 id="迁移图片"><a href="# 迁移图片" class="headerlink" title="迁移图片"></a> 迁移图片 </h2><p> 迁移图片本来是个很麻烦的事情，要把图片迁移、博客文章里面的链接替换掉，但是还好有现成的工具可以使用，在这里推荐：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a> ，这个工具本来不是做图片迁移的，仅仅是图片上传生成链接而已，但是有人开发了插件，专门用来迁移 markdown 文件里面的图片，会自动迁移图片并且更新 markdown 里面的图片链接。这个插件是：<a href="https://github.com/PicGo/picgo-plugin-pic-migrater" target="_blank" rel="noopener">picgo-plugin-pic-migrater</a> ，而且，还可以支持批量迁移，指定一个文件夹，直接迁移文件夹里面的所有 markdown 文件。</p><h2 id="迁移过程"><a href="# 迁移过程" class="headerlink" title="迁移过程"></a>迁移过程 </h2><p> 详细的迁移步骤就不再记录，几个重要的步骤：在 GitHub 建立仓库、使用 PicGo 工具迁移图片，重新整理 markdown 文件。操作前切记备份好自己的 markdown 文件，以免迁移出现问题导致文件丢失。</p><p>在使用 PicGo 的过程中，发现总是迁移失败，重试了多次之后确定是因为在 markdown 语法中增加了注释，相当于给图片链接增加了 alt 属性【生成时图片会有一个 img 标记】，导致 PicGo 的插件识别不了，迁移失败。我已经在 GitHub 的项目中提了 issue：<a href="https://github.com/PicGo/picgo-plugin-pic-migrater/issues/1" target="_blank" rel="noopener">https://github.com/PicGo/picgo-plugin-pic-migrater/issues/1</a> ，作者也回复了，后续会修复。而我比较着急，等不了，又不可能把这些注释全部清除，也不好，所以我决定自己迁移，通过 Java 写代码解决。</p><p>写代码也比较简单，主要有四个步骤：读取 markdown 文件内容并利用正则抽取微博图床的图片链接、下载所有图片并上传至 GitHub、替换内容中抽取出的所有图片链接为 GitHub 的图片链接、内容写回新文件。</p><p>使用 Java 处理不需要多少代码，主要要依赖几个 jar 包：处理文件的 io 包、处理网络请求的 httpclient 包、处理 git 的 jgit 包。详细内容可以参考我的另外一篇博客：<a href="https://www.playpi.org/2019050201.html">使用 Java 代码迁移微博图床到 GitHub 图床 </a> 。</p><h2 id="小细节"><a href="# 小细节" class="headerlink" title="小细节"></a> 小细节 </h2><p> 针对 PicGo 的使用还有一些小细节可以注意一下：自定义域名、子文件夹路径、图片压缩【不压缩针对 GitHub 速度会很慢，能压缩到 200KB 最好】、文件重命名。</p><h2 id="未来考虑"><a href="# 未来考虑" class="headerlink" title="未来考虑"></a>未来考虑 </h2><p> 迁移完成之后，以后新的图片就直接使用 PicGo 上传到 GitHub 图床了，同时需要注意区分子文件夹。在 GitHub 仓库中，暂时每年新建一个文件夹，以年份数字为名称。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;对于不少自己搭建博客的人来说，图床的选择可真是一个大难点，以前还有各种免费好用的图床工具，例如七牛云、又拍云、SM.MS、Imgur、GitHub、微博图床等，当然还有腾讯云、阿里云的云存储服务，但是免费的意味着不稳定，说不定哪天图片就没有了，有一些国外的访问速度又不行，国内的云存储服务商收费又比较高，还有的必须绑定认证的域名才能使用。本来搭建一个小小的博客，只为了记录知识，传播技术，遇到耗财或者耗精力的这种问题，都比较头疼。&lt;/p&gt;&lt;p&gt;后来纠结了好几天，最终决定使用免费的 &lt;strong&gt;微博图床 &lt;/strong&gt;，一是因为新浪微博这家厂商体量大，微博图床短期内应该不会出问题，二是看到好多网友说他们已经稳定使用微博图床 3-5 年了，没有出过问题。我大概使用的时间还没有一年，以前都是本地化的，没有整理成完整的文章，后来开始慢慢整理并部署上线。没想到最近【2019 年 4 月 24 日左右发现】微博图床出问题了，访问图片链接全部是返回 403 状态码，表示拒绝访问，其实是微博图床开启了防盗链，本文就记录这个现象以及可行的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://www.playpi.org/categories/building/"/>
    
    
      <category term="https" scheme="https://www.playpi.org/tags/https/"/>
    
      <category term="weibo" scheme="https://www.playpi.org/tags/weibo/"/>
    
      <category term="referer" scheme="https://www.playpi.org/tags/referer/"/>
    
  </entry>
  
  <entry>
    <title>mapreduce 错误之 bin bash-line 0-fg-no job control</title>
    <link href="https://www.playpi.org/2019042401.html"/>
    <id>https://www.playpi.org/2019042401.html</id>
    <published>2019-04-24T14:50:17.000Z</published>
    <updated>2019-04-24T14:50:17.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>今天在开发 mapreduce 程序的过程中，为了快速开发，程序的整体框架是从别的业务复制过来的，自己增加一些数据处理逻辑以及环境的参数配置。接着就遇到问题，在本地本机测试的时候，Job 作业无法启动，总是抛出异常，然后进程退出。本机系统为 Windows 7 X64。</p><p>异常错误信息简略如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exit code: 1</span><br><span class="line">Exception message: /bin/bash: line 0: fg: no job control</span><br></pre></td></tr></table></figure><p>本文记录这个现象以及解决方案。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 在本地本机启动 Job 时无法正常运行作业，直接抛出异常后退出进程，完整错误信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Diagnostics: Exception from container-launch.</span><br><span class="line">Container id: container_e18_1550055564059_0152_02_000001</span><br><span class="line">Exit code: 1</span><br><span class="line">Exception message: /bin/bash: line 0: fg: no job control</span><br><span class="line"></span><br><span class="line">Stack trace: ExitCodeException exitCode=1: /bin/bash: line 0: fg: no job control</span><br><span class="line"></span><br><span class="line">at org.apache.hadoop.util.Shell.runCommand (Shell.java:576)</span><br><span class="line">at org.apache.hadoop.util.Shell.run (Shell.java:487)</span><br><span class="line">at org.apache.hadoop.util.Shell$ShellCommandExecutor.execute (Shell.java:753)</span><br><span class="line">at org.apache.hadoop.yarn.server.nodemanager.DefaultContainerExecutor.launchContainer (DefaultContainerExecutor.java:212)</span><br><span class="line">at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call (ContainerLaunch.java:303)</span><br><span class="line">at org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher.ContainerLaunch.call (ContainerLaunch.java:82)</span><br><span class="line">at java.util.concurrent.FutureTask.run (FutureTask.java:266)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run (ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run (Thread.java:748)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Container exited with a non-zero exit code 1</span><br><span class="line">Failing this attempt. Failing the application.</span><br><span class="line">2019-04-22_22:46:04 [main] INFO mapreduce.Job:1385: Counters: 0</span><br></pre></td></tr></table></figure><p>其中的重点在于：<strong>Exception message: /bin/bash: line 0: fg: no job control</strong>，由于我不了解这种错误，只能靠搜索引擎解决了。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><p> 问题解决很容易，在 Job 的配置中增加一项：mapreduce.app-submission.cross-platform，取值为 true，截取代码片段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Configuration conf = job.getConfiguration ();</span><br><span class="line">conf.set (&quot;mapreduce.job.running.map.limit&quot;, &quot;50&quot;);</span><br><span class="line">// 本机环境测试加上配置，否则会抛出异常退出：ExitCodeException: /bin/bash: line 0: fg: no job control</span><br><span class="line">conf.set (&quot;mapreduce.app-submission.cross-platform&quot;, &quot;true&quot;);</span><br></pre></td></tr></table></figure><p>这个配置的含义就是跨平台，保障 Job 作业可以在 Windows 平台顺利运行。</p><h1 id="备注"><a href="# 备注" class="headerlink" title="备注"></a>备注 </h1><p> 参考：<a href="https://stackoverflow.com/questions/24075669/mapreduce-job-fail-when-submitted-from-windows-machine" target="_blank" rel="noopener">stackoverflow 讨论一例</a> 。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天在开发 mapreduce 程序的过程中，为了快速开发，程序的整体框架是从别的业务复制过来的，自己增加一些数据处理逻辑以及环境的参数配置。接着就遇到问题，在本地本机测试的时候，Job 作业无法启动，总是抛出异常，然后进程退出。本机系统为 Windows 7 X64。&lt;/p&gt;&lt;p&gt;异常错误信息简略如下：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Exit code: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Exception message: /bin/bash: line 0: fg: no job control&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;本文记录这个现象以及解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑系列" scheme="https://www.playpi.org/categories/series-of-fixbug/"/>
    
    
      <category term="mapreduce" scheme="https://www.playpi.org/tags/mapreduce/"/>
    
  </entry>
  
  <entry>
    <title>关于  httpcore 的 Maven 依赖冲突问题解决</title>
    <link href="https://www.playpi.org/2019042201.html"/>
    <id>https://www.playpi.org/2019042201.html</id>
    <published>2019-04-22T12:17:45.000Z</published>
    <updated>2019-04-22T12:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>今天，又遇到一个 Maven 冲突的问题，这种问题我遇到的多了，每次都是因为项目依赖管理混乱或者为新功能增加依赖之后影响了旧功能，这次就是因为后者，新增加的依赖的传递依赖覆盖了原有的依赖，导致了问题的产生。大家如果搜索我的博客，搜索关键词 maven 或者 mvn，应该可以看到好几篇类似的文章，每次的情况都略有不同，每次解决问题的过程也是很崩溃。不过，每次崩溃之后都是一阵喜悦，毕竟感觉自己的经验又扩充了一些，以后遇到此类问题可以迅速解决。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 写了一个 mapReduce 程序从 HBase 读取数据，写入到 Elasticsearch 中，整体的框架是从别的项目复制过来的，自己重写了处理逻辑以及环境相关的参数，但是跑起来的时候，map 过程很顺利，几百个 task 全部成功完成，但是 reduce 过程直接挂了，几十个 task 全部失败，重试了还是失败。</p><p>我只能去查看日志，去 Hadoop 监控界面，看到对应任务的报错日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">2019-04-22 16:01:30,469 ERROR [main] com.datastory.banyan.spark.ScanFlushESMRV2$FlushESReducer: org/apache/http/message/TokenParser</span><br><span class="line">java.lang.NoClassDefFoundError: org/apache/http/message/TokenParser</span><br><span class="line">at org.apache.http.client.utils.URLEncodedUtils.parse (URLEncodedUtils.java:280)</span><br><span class="line">at org.apache.http.client.utils.URLEncodedUtils.parse (URLEncodedUtils.java:237)</span><br><span class="line">at org.apache.http.client.utils.URIBuilder.parseQuery (URIBuilder.java:111)</span><br><span class="line">at org.apache.http.client.utils.URIBuilder.digestURI (URIBuilder.java:181)</span><br><span class="line">at org.apache.http.client.utils.URIBuilder.&lt;init&gt;(URIBuilder.java:91)</span><br><span class="line">at org.apache.http.client.utils.URIUtils.rewriteURI (URIUtils.java:185)</span><br><span class="line">at org.apache.http.impl.nio.client.MainClientExec.rewriteRequestURI (MainClientExec.java:494)</span><br><span class="line">at org.apache.http.impl.nio.client.MainClientExec.prepareRequest (MainClientExec.java:529)</span><br><span class="line">at org.apache.http.impl.nio.client.MainClientExec.prepare (MainClientExec.java:156)</span><br><span class="line">at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl.start (DefaultClientExchangeHandlerImpl.java:125)</span><br><span class="line">at org.apache.http.impl.nio.client.InternalHttpAsyncClient.execute (InternalHttpAsyncClient.java:129)</span><br><span class="line">at org.elasticsearch.client.RestClient.performRequestAsync (RestClient.java:343)</span><br><span class="line">at org.elasticsearch.client.RestClient.performRequestAsync (RestClient.java:325)</span><br><span class="line">at org.elasticsearch.client.RestClient.performRequestAsync (RestClient.java:268)</span><br><span class="line">at org.elasticsearch.client.RestHighLevelClient.performRequestAsync (RestHighLevelClient.java:445)</span><br><span class="line">at org.elasticsearch.client.RestHighLevelClient.performRequestAsyncAndParseEntity (RestHighLevelClient.java:423)</span><br><span class="line">at org.elasticsearch.client.RestHighLevelClient.bulkAsync (RestHighLevelClient.java:206)</span><br><span class="line">at com.datastory.banyan.client.es.ESBulkProcessor.lambda$new$0 (ESBulkProcessor.java:154)</span><br><span class="line">at org.elasticsearch.action.bulk.Retry$RetryHandler.execute (Retry.java:230)</span><br><span class="line">at org.elasticsearch.action.bulk.Retry.withAsyncBackoff (Retry.java:87)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkRequestHandler$AsyncBulkRequestHandler.execute (BulkRequestHandler.java:138)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkProcessor.execute (BulkProcessor.java:350)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkProcessor.executeIfNeeded (BulkProcessor.java:341)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkProcessor.internalAdd (BulkProcessor.java:276)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkProcessor.add (BulkProcessor.java:259)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkProcessor.add (BulkProcessor.java:255)</span><br><span class="line">at org.elasticsearch.action.bulk.BulkProcessor.add (BulkProcessor.java:241)</span><br><span class="line">at com.datastory.banyan.client.es.ESBulkProcessor.addIndexRequest (ESBulkProcessor.java:237)</span><br><span class="line">at com.datastory.banyan.spark.ScanFlushESMRV2$FlushESReducer.reduce (ScanFlushESMRV2.java:212)</span><br><span class="line">at com.datastory.banyan.spark.ScanFlushESMRV2$FlushESReducer.reduce (ScanFlushESMRV2.java:158)</span><br><span class="line">at org.apache.hadoop.mapreduce.Reducer.run (Reducer.java:171)</span><br><span class="line">at org.apache.hadoop.mapred.ReduceTask.runNewReducer (ReduceTask.java:627)</span><br><span class="line">at org.apache.hadoop.mapred.ReduceTask.run (ReduceTask.java:389)</span><br><span class="line">at org.apache.hadoop.mapred.YarnChild$2.run (YarnChild.java:168)</span><br><span class="line">at java.security.AccessController.doPrivileged (Native Method)</span><br><span class="line">at javax.security.auth.Subject.doAs (Subject.java:422)</span><br><span class="line">at org.apache.hadoop.security.UserGroupInformation.doAs (UserGroupInformation.java:1709)</span><br><span class="line">at org.apache.hadoop.mapred.YarnChild.main (YarnChild.java:162)</span><br></pre></td></tr></table></figure><p>截图如下：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brjd9bl2j210d0j9q4k.jpg" alt="异常日志信息" title="异常日志信息"></p><p>看到关键部分：<strong>java.lang.NoClassDefFoundError: org/apache/http/message/TokenParser</strong>，表面看是类未定义，但是真实情况是什么还要继续探索，例如依赖缺失、依赖冲突导致的类不匹配等。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><h2 id="初步分析"><a href="# 初步分析" class="headerlink" title="初步分析"></a> 初步分析 </h2><p> 先搜索类 <strong>TokenParser</strong> 吧，看看能不能搜索到，在 IDEA 中搜索，我的环境是使用 <strong>ctrl + shift + t</strong> 快捷键，搜索之后发现存在这个类，记住对应的 jar 包坐标以及版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.httpcomponents:httpcore:jar:4.3.2</span><br></pre></td></tr></table></figure><p>这里需要注意一点，如果你的项目是由多个子项目聚合而成的，此时使用 IDEA 的搜索功能并不准确，会搜索出来其它子项目的同名依赖，从而误导你的视线，所以还是使用依赖分析插件比较好，例如：depedency，下面也会讲到。</p><p>既然类已经存在，说明有极大可能是依赖冲突导致的 <strong>NoClassDefFoundError</strong>。继续从错误日志中寻找蛛丝马迹，看到 <strong>at org.apache.http.client.utils.URLEncodedUtils.parse (URLEncodedUtils.java:280)</strong> 这里，接着搜索类 <strong>URLEncodedUtils</strong> 并查看第 280 行的 <strong>parse</strong> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.httpcomponents:httpclient:jar:4.5.2</span><br></pre></td></tr></table></figure><p>上面是依赖坐标以及版本，看到这里有经验的工程师已经可以发现问题所在了：两个同类型的依赖 jar 包版本差别太大，这里暂且不分析。</p><p>接着查看源码：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brkjzrvrj20v50djt9j.jpg" alt="URLEncodedUtils 源码" title="URLEncodedUtils 源码"></p><p>好，到这里已经把基本情况分析清楚了，程序异常里面的 <strong>NoClassDefFoundError</strong> 并不是类缺失，所以没有报错 <strong>ClassNotFound</strong>。根本原因是类版本不对，导致 <strong>URLEncodedUtils</strong> 找不到自己需要的特定版本的类，尽管有一个同名的低版本的类存在，但是对于 Java 虚拟机来说这是完全不同的两个类，这也是容易误导人的地方。</p><p>再延伸一下话题，如果真的是类不存在，使用 IDEA 查看源码时会显示红色字体提示的，如图：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brle6hgjj20zc0ieq49.jpg" alt="类不存在错误提示" title="类不存在错误提示"></p><h2 id="详细分析"><a href="# 详细分析" class="headerlink" title="详细分析"></a>详细分析 </h2><p> 接下来就使用依赖分析插件 <strong>dependency</strong> 来分析这两个 jar 包的来源以及版本差异，在项目的根目录执行 <strong>mvn dependency:tree -Dverbose &gt; tree.txt</strong> ，把依赖树信息重定向到 tree.txt 文件中，里面的 -Dverbose 参数可以使我们更为清晰地看到版本冲突的 jar 包以及实际使用的 jar 包。</p><p>找到 httpclient 和 httpcore 的来源，依赖树片段截取如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] +- com.company.commons3:ds-commons3-es-rest:jar:1.2:compile</span><br><span class="line">[INFO] |  +- org.apache.httpcomponents:httpclient:jar:4.5.2:compile</span><br><span class="line"></span><br><span class="line">...... 省略 </span><br><span class="line"></span><br><span class="line">[INFO] |  +- org.apache.httpcomponents:httpasyncclient:jar:4.0.2:compile</span><br><span class="line">[INFO] |  |  +- org.apache.httpcomponents:httpcore:jar:4.3.2:compile</span><br><span class="line">[INFO] |  |  +- (org.apache.httpcomponents:httpcore-nio:jar:4.3.2:compile - omitted for duplicate)</span><br><span class="line">[INFO] |  |  +- (org.apache.httpcomponents:httpclient:jar:4.3.5:compile - omitted for conflict with 4.5.2)</span><br><span class="line">[INFO] |  |  \- (commons-logging:commons-logging:jar:1.1.3:compile - omitted for duplicate)</span><br></pre></td></tr></table></figure><p>可以看到 <strong>httpclient</strong> 来自于 <strong>ds-commons3-es-rest</strong>，版本为 4.5.2，而 <strong>httpcore</strong> 来自于 <strong>httpasyncclient</strong>，版本为 4.3.2。</p><p>特别注意：<strong>httpasyncclient</strong> 里面还有一个 4.3.5 版本的 <strong>httpclient</strong> 由于版本冲突被忽略了，这也是导致问题的元凶。</p><p>依赖树片段截图如下：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brlwy34ij210404e74q.jpg" alt="依赖树片段 1" title="依赖树片段 1"></p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brm3rutxj211508h0tr.jpg" alt="依赖树片段 2" title="依赖树片段 2"></p><p>到这里已经可以知道问题所在了，<strong>httpclient</strong>、<strong>httpcore</strong> 这两个依赖的版本差距太大，前者 4.5.2，后者 4.3.2，导致前者的类 URLEncodedUtils 在调用后者的类 TokenParser 时，找不到满足条件的版本，于是抛出异常：NoClassDefFoundError。</p><h2 id="解决方案"><a href="# 解决方案" class="headerlink" title="解决方案"></a>解决方案 </h2><p> 那这个问题也是很容易解决的，指定版本接近的两个依赖即可，但是还是要根据实际情况而来。本来最简单的方案就是移除所有相关依赖，然后在 pom.xml 中显式地指定这两个依赖的版本。但是这么做太简单粗暴了，因为这两个依赖不是一级依赖，而是传递依赖，不必手动管理。所以要适当地移除某一些传递依赖，保留另一些传递依赖，让它们不要交叉出现。</p><p>我的做法就是移除 <strong>ds-commons3-es-rest</strong> 里面的传递依赖，保持 <strong>httpasyncclient</strong> 里面的传递依赖，这样它们的版本号接近，而且是同一个依赖里面传递的，基本不可能出错。</p><p>pom.xml 配置如图：<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brnorbdej211p0amaaq.jpg" alt="修复后的 pom 配置" title="修复后的 pom 配置"></p><p>httpclient 的小版本号是可以比 httpcore 高一点的，继续查看依赖树，可以看到 httpclient 的版本为 4.3.5，httpcore 的版本为 4.3.2。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g2brntqakfj20rp021aa1.jpg" alt="修复后的 http 依赖版本号" title="修复后的 http 依赖版本号"></p><h2 id="引申插件"><a href="# 引申插件" class="headerlink" title="引申插件"></a>引申插件 </h2><p> 除了 dependency 插件外，还有另外一个插件也非常好用：enforcer，插件的坐标如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 帮助分析依赖冲突的插件，可以在编译时期找到依赖问题 --&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-enforcer-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.4.1&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;enforce-ban-duplicate-classes&lt;/id&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;enforce&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;!-- 设置规则，否则没法检查 --&gt;</span><br><span class="line">                &lt;rules&gt;</span><br><span class="line">                    &lt;!-- 检查重复类 --&gt;</span><br><span class="line">                    &lt;banDuplicateClasses&gt;</span><br><span class="line">                        &lt;!-- 忽略一些类 --&gt;</span><br><span class="line">                        &lt;ignoreClasses&gt;</span><br><span class="line">                            &lt;ignoreClass&gt;javax.*&lt;/ignoreClass&gt;</span><br><span class="line">                            &lt;ignoreClass&gt;org.junit.*&lt;/ignoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.aspectj.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.jboss.netty.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.apache.juli.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.apache.commons.logging.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.apache.log4j.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.objectweb.asm.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.parboiled.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.apache.xmlbeans.xml.stream.*&lt;/ingoreClass&gt;</span><br><span class="line">                            &lt;ingoreClass&gt;org.json.JSONString&lt;/ingoreClass&gt;</span><br><span class="line">                        &lt;/ignoreClasses&gt;</span><br><span class="line">                        &lt;!-- 除了上面忽略的类，检查所有的类 --&gt;</span><br><span class="line">                        &lt;findAllDuplicates&gt;true&lt;/findAllDuplicates&gt;</span><br><span class="line">                    &lt;/banDuplicateClasses&gt;</span><br><span class="line">                    &lt;!-- JDK 在 1.8 以上 --&gt;</span><br><span class="line">                    &lt;requireJavaVersion&gt;</span><br><span class="line">                        &lt;version&gt;1.8.0&lt;/version&gt;</span><br><span class="line">                    &lt;/requireJavaVersion&gt;</span><br><span class="line">                    &lt;!-- Maven 在 3.0.5 以上 --&gt;</span><br><span class="line">                    &lt;requireMavenVersion&gt;</span><br><span class="line">                        &lt;version&gt;3.0.5&lt;/version&gt;</span><br><span class="line">                    &lt;/requireMavenVersion&gt;</span><br><span class="line">                &lt;/rules&gt;</span><br><span class="line">                &lt;fail&gt;true&lt;/fail&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">    &lt;!-- 官方的默认规则 --&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;extra-enforcer-rules&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-beta-6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>这个插件需要配置在 pom.xml 中，并且绑定 Maven 的生命周期，默认是绑定在 compile 上面，然后需要给 enforcer 配置一些规则，例如检查重复的类。接着在编译期间，enforcer 插件就会检验项目的依赖中所有的类【可以设置忽略容器中的类，例如作用域为 provided 的依赖包】，如果有重复的类，就会报错，编译不会通过。</p><p>注意，这个插件除了可以检查依赖、类的冲突【通过设置规则 rule 来实现】，还可以设置一些其它的开发规范，例如规定 JDK 版本、开发系统环境必须为 Windows、使用的 Maven 版本等等。此外，官方也提供了一些规则列表可以参考：<a href="http://maven.apache.org/enforcer/enforcer-rules/index.html" target="_blank" rel="noopener">http://maven.apache.org/enforcer/enforcer-rules/index.html</a> ，而且还有 API 允许我们自定义规则，非常灵活。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结 </h1><h2 id="抽象总结"><a href="# 抽象总结" class="headerlink" title="抽象总结"></a> 抽象总结 </h2><p> 总结一下现象，其实就是项目本来依赖了 B 包，B 包里面有传递依赖包 1、包 2，由于包 1、包 2 都来自于 B 包，所以版本差别不大，很适配。包 1 的类调用包 2 的类很顺利，不会有问题。</p><p>后来由于其它功能需要，项目又加入了 A 包，此时没有注意到 A 包里面也有包 1，而且比 B 包里面的包 1 版本高，这本来不是问题，只是潜在风险。但是，编译打包时 A 包里面的包 1 把 B 包里面的包 1 覆盖了，包 2 仍旧是来自于 B 包，这就出问题了，风险变成灾难了。当程序运行时包 1 需要调用包 2，由于版本差别过大，找不到符合条件的类了，抛出异常：NoClassDefFoundError。</p><p>这里面的验证机制浅显地描述就是每个类都会有自己的序列化编号，如果有严格要求同版本依赖的类，调用方法时会严格验证。</p><h2 id="关于编译的疑问"><a href="# 关于编译的疑问" class="headerlink" title="关于编译的疑问"></a>关于编译的疑问 </h2><p> 到这里，读者会有疑问，为什么编译不报错，能顺利通过呢？其实从上面就能看到答案了，这种依赖包之间相互引用的类，类是存在的，只是版本不一致而已，编译时并不能检测出来。如果是你自己写的类源码，引用了别的依赖包的类，同时对版本要求严格的话，编译是一定会报错的。</p><p>但是，如果你提前知道了是哪个类，一般不可能知道，只有报错了才会知道，而且会有不止一个类，这也是令人头疼的地方。</p><p>如果进一步分析异常信息，发现它归属于 ERROR，并不是运行时异常，更不用谈编译时异常了，这种错误和 OutOfMemoryError 类似，是虚拟机运行时出现问题，比较严重。</p><h2 id="感悟"><a href="# 感悟" class="headerlink" title="感悟"></a>感悟 </h2><p> 找到这种问题的原因是没有什么难度的，一眼就可以看出来是依赖冲突。但是解决过程可谓是难度极大，而且可以让人崩溃，对于初学者来说可以放弃了，折腾三天可能都不会有结果的。特别在依赖庞大的情况下，几百个依赖包，几百 M 大小，这时候找起来特别麻烦，有时候改动了一点会影响到其它的依赖，引起连锁反应，可能问题还没解决，又引发了其它问题。</p><p>所以，在项目开发的初始阶段，一定要管理好项目的依赖，并且在依赖变更时要一起讨论，否则后患无穷。</p><p>此外，在解决依赖冲突的过程中，有 2 个插件工具很好用：dependency、enforcer。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天，又遇到一个 Maven 冲突的问题，这种问题我遇到的多了，每次都是因为项目依赖管理混乱或者为新功能增加依赖之后影响了旧功能，这次就是因为后者，新增加的依赖的传递依赖覆盖了原有的依赖，导致了问题的产生。大家如果搜索我的博客，搜索关键词 maven 或者 mvn，应该可以看到好几篇类似的文章，每次的情况都略有不同，每次解决问题的过程也是很崩溃。不过，每次崩溃之后都是一阵喜悦，毕竟感觉自己的经验又扩充了一些，以后遇到此类问题可以迅速解决。&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑系列" scheme="https://www.playpi.org/categories/series-of-fixbug/"/>
    
    
      <category term="httpcore" scheme="https://www.playpi.org/tags/httpcore/"/>
    
      <category term="maven" scheme="https://www.playpi.org/tags/maven/"/>
    
      <category term="dependency" scheme="https://www.playpi.org/tags/dependency/"/>
    
      <category term="enforcer" scheme="https://www.playpi.org/tags/enforcer/"/>
    
  </entry>
  
  <entry>
    <title>Linux 之 kill 命令入门实践</title>
    <link href="https://www.playpi.org/2019042101.html"/>
    <id>https://www.playpi.org/2019042101.html</id>
    <published>2019-04-21T14:35:27.000Z</published>
    <updated>2019-04-21T14:35:27.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>最近在实际应用场景中，需要使用 <code>Linux</code> 系统的 <strong>kill</strong> 命令来控制程序的生命周期，例如 <strong>ctrl + c</strong>、<strong>ctrl + z</strong>、<strong>kill -9 pid</strong> 等，而这些命令在日常的工作当中也是非常常见的并且很好用。为了多了解一些 <code>Linux</code> 中信号常量的知识点，以及 <code>kill</code> 命令的基本原理，我整理了这一篇博客。</p><p>本文中涉及的 <code>c</code> 语言脚本已经被我上传至 <code>GitHub</code>，读者可以提前下载查看：<a href="https://github.com/iplaypi/iplaypistudy/tree/master/iplaypistudy-normal/src/bin/20190421" target="_blank" rel="noopener">signal 相关脚本 </a> ，脚本命名与下文中描述一致。</p><a id="more"></a><h1 id="基础知识"><a href="# 基础知识" class="headerlink" title="基础知识"></a> 基础知识 </h1><h2 id="信号"><a href="# 信号" class="headerlink" title="信号"></a> 信号 </h2><p> 根据 <code>kill</code> 的实际使用来初步了解一下信号的概念。</p><p>首先要清楚一个基本知识点：<code>kill</code> 命令只是用来向进程发送信号的，而不是直接杀死进程的，实际操控进程生命的仍旧是系统内核以及信号常量的规范动作【进程本身注册的信号动作：默认、忽略、捕捉自定义】。</p><blockquote><p>kill 命令使用户能够向进程发送信号，信号是发送给进程以中断进程并使其作出反应的信息。如果进程被设计为对发送给它的该类型信号作出反应，则它将作出反应；否则，该进程将终止。</p></blockquote><p>对于进程对信号做出正常反应的情况，例如对一个进程发送编号为 9 的信号，则该进程会终止。而对一个进程发送编号为 19 的信号【<code>SIGSTOP</code>】，则该进程会退到后台暂停，接着使用编号为 18 的信号【<code>SIGCONT</code>】可以激活进程继续运行【也可以直接使用 <code>fg /bg</code> 这一对命令】。</p><p>对于进程不能对信号做出反应而终止的情况，例如对一个进程发送编号为 10 的信号【<code>SIGUSR1</code>】，这个信号本来是给用户自定义的，而普通的进程没有被设计为对这个信号做出反应，因此进程将终止运行【另一方面，在 <code>PHP</code> 中，后台进程会对这个信号做出反应，是因为官方发布的程序实现了这个信号的指令，并为进程注册了这个信号】。</p><blockquote><p>对于 Linux 来说，实际上信号是软中断，许多重要的程序都需要处理信号。信号，为 Linux 提供了一种处理异步事件的方法。</p></blockquote><p>每个信号都有一个名字和编号，这些名字都以 <strong>SIG</strong> 开头，例如 <strong>SIGINT</strong>、<strong>SIGKILL</strong> 等等。信号定义在 <strong>signal.h</strong>【<code>/usr/include/asm/signal.h</code>】头文件中，信号编号都定义为正整数，从 1 开始。当然，也有编号为 0 的信号，但是它对于 kill 有特殊的应用。</p><p>使用 <strong>kill -l</strong> 可以查看所有的信号常量列表，其中，前面 32 个是基本的，后面 32 个是扩展的【做底层驱动开发时能用到】。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518213523.png" alt="kill 命令查看信号常量" title="kill 命令查看信号常量"></p><h2 id="常用信号常量"><a href="# 常用信号常量" class="headerlink" title="常用信号常量"></a>常用信号常量 </h2><p> 以下列举一些常用的信号常量以及解释说明：</p><table><thead><tr><th style="text-align:center">信号编号 </th><th style="text-align:center"> 信号名称 </th><th style="text-align:center"> 信号解释 </th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">SIGHUP</td><td style="text-align:center"> 挂起信号【hang up】，终端断线，经常在退出系统前使用，会终止进程。但是，一般启动程序时为了让程序继续运行，会指定 nohup 就是为了不让程序接收挂起信号而终止，这样在退出系统时程序仍旧能正常运行 </td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">SIGINT</td><td style="text-align:center"> 中断【与键盘快捷键 ctrl + c 对应】，表示与键盘中断 </td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">SIGQUIT</td><td style="text-align:center"> 退出【与键盘快捷键 ctrl + \ 对应】</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">SIGKILL</td><td style="text-align:center">强制终止，程序必须终止【无需清除】，只有进程属主或者超级用户发出该命令时才起作用 </td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">SIGTERM</td><td style="text-align:center"> 停止，要求进程自己退出【需要先清除】，所以可能停止失败，只有进程属主或者超级用户发出该命令时才起作用 </td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">SIGUSR1</td><td style="text-align:center"> 用户自定义信号 1</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">SIGSEGV</td><td style="text-align:center">段错误信号，在操作内存、硬盘资源出错时会出现，例如硬盘空间不足、内存读取无权限时 </td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">SIGUSR2</td><td style="text-align:center"> 用户自定义信号 2</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">SIGCONT</td><td style="text-align:center">继续【与命令 fg/bg 对应，搭配 jobs 一起使用】</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">SIGSTOP</td><td style="text-align:center">暂停【与键盘快捷键 ctrl + z 对应】，可以使用信号 18 来继续运行，或者使用 fg/bg 来调度到前 / 后台继续运行【搭配 jobs 一起使用】</td></tr></tbody></table><p>也可以在 <code>Linux</code> 机器上面使用 <strong>man 7 signal</strong> 可以查看帮助文档，有更为详细的解释说明。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518213623.png" alt="man 7 signal 查看帮助文档" title="man 7 signal 查看帮助文档"></p><p>在所有的信号中，只有编号为 9 的信号【<code>SIGKILL</code>】才可以 <strong>无条件终止 </strong>进程，编号为 15 的信号【<code>SIGTERM</code>】也可以 <strong>停止 </strong>进程，但是可能终止失败。对于编号为 9 的信号【<code>SIGKILL</code>】和编号为 19 的信号【<code>SIGSTOP</code>】，进程无法选择忽略，必须做出反应，而对于其它的信号，进程都有权利选择忽略。</p><h2 id="信号处理动作详解"><a href="# 信号处理动作详解" class="headerlink" title="信号处理动作详解"></a>信号处理动作详解 </h2><p> 对于信号的处理有三种方式：忽略、捕捉、默认。</p><blockquote><p>忽略信号，大多数信号可以使用这个方式来处理，但是有两种信号不能被忽略：9 号【SIGKILL】、19 号【SIGSTOP】。因为这两个信号向内核和超级用户提供了 <strong>终止 </strong>和 <strong>停止 </strong>的 <strong>可靠 </strong>方法，如果被忽略了，那么这个进程就变成了没人能管理的的进程，显然这是内核设计者不希望看到的场景。</p></blockquote><blockquote><p>捕捉信号，需要告诉内核，程序希望如何处理某一种信号，其实就是写一个信号处理函数，里面写上自定义的处理逻辑，然后将这个函数告诉内核【注册函数】。当该信号产生时，由内核来调用用户的自定义函数，以此来实现某种信号的自定义处理。说到底，就是进程捕捉信号，自定义处理，不使用内核默认的处理方式。</p></blockquote><blockquote><p>系统默认动作，对于每个信号来说，系统都对应有默认的处理动作。当发生了该信号，系统会自动执行。不过，对系统来说，大部分的处理方式都比较粗暴，就是直接杀死该进程。</p></blockquote><h2 id="信号的实际使用"><a href="# 信号的实际使用" class="headerlink" title="信号的实际使用"></a>信号的实际使用 </h2><p> 以上把信号的基本概念了解清楚了，但是在实际中程序是怎么使用的呢？为了配合使用，必须有两方面程序：一是信号发送方【即负责发送信号的工具，例如 <code>kill</code> 就可以】，另一方是接收方【即能接收信号并且做出反应的程序，基本所有运行在 <code>Linux</code> 上的程序都可以】。</p><p>接下来就以 <code>c</code> 语言编程，写两个例子，模拟发送方【封装 <code>kill</code>】、接收方【信号处理函数注册】，来观察一下信号的实际应用。</p><h3 id="信号处理函数注册"><a href="# 信号处理函数注册" class="headerlink" title="信号处理函数注册"></a>信号处理函数注册 </h3><p> 信号处理函数的注册，使用入门版的接口，<code>signal</code> 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal (<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br></pre></td></tr></table></figure><p>根据函数原型可以看出，由两部分组成，一个是真正处理信号的函数，另一个是注册函数。对于 <strong>sighandler_t signal (int signum, sighandler_t handler)</strong> 函数来说，<code>signum</code> 显然是信号的编号，<code>handler</code> 是处理函数的指针。同样地，在 <strong>typedef void (*sighandler_t)(int)</strong> 这个处理函数的原型中，有一个参数是 <code>int</code> 类型，显然也是信号的编号，在实现函数时要根据信号的编号进行不同的操作。</p><p>只需要实现真正的处理信号的方法即可，以下是示例【脚本文件名：<code>signal_test.c</code>】，信号处理只是打印，方便观察：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理函数只把接收到的信号编号打印出来 </span></span><br><span class="line">    <span class="keyword">if</span>(signum == SIGIO)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SIGIO signal: % d\n"</span>, signum);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(signum == SIGUSR1)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"SIGUSR1 signal: % d\n"</span>, signum);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略 SIGINT, 默认处理 SIGTERM, 其它信号不注册都会导致程序退出 </span></span><br><span class="line">    signal (SIGIO, handler);</span><br><span class="line">    signal (SIGUSR1, handler);</span><br><span class="line">    signal (SIGINT, SIG_IGN);</span><br><span class="line">    signal (SIGTERM, SIG_DFL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SIGIO=% d,SIGUSR1=% d,SIGINT=% d,SIGTERM=% d\n"</span>, SIGIO, SIGUSR1, SIGINT, SIGTERM);</span><br><span class="line">    <span class="comment">// 以下是无限循环 </span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        sleep (<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>gcc</code> 编译器编译【如果 <code>Linux</code> 环境不带需要自行安装】：<code>gcc -o signal_test signal_test.c</code> ，然后就可以执行了：<code>./signal_test</code> 。</p><p>接着使用 <code>ctrl + c</code> 快捷键【被进程忽略】，使用 <code>kill</code> 命令发送 29 号信号【被接收并打印出来编号】、10 号信号【被接收并打印出来编号】、2 号【被接收并忽略】、15 号【被接收并按照系统默认动作停止进程】，具体看下面的两张图片。</p><p>使用 <code>kill</code> 命令发送信号 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518222351.png" alt="使用 kill 命令发送信号" title="使用 kill 命令发送信号"></p><p> 进程接收信号的处理方式 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518222402.png" alt="进程接收信号的处理方式" title="进程接收信号的处理方式"></p><p> 接着演示 <code>kill</code> 发送一个程序没有注册的信号 12 号【<code>SIGUSR2</code>】，可以观察到程序直接退出。</p><p><code>kill</code> 发送 12 号信号 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518223015.png" alt="kill 发送 12 号信号" title="kill 发送 12 号信号"></p><p> 进程直接退出 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518223037.png" alt="进程直接退出" title="进程直接退出"></p><h3 id="信号发送工具模拟"><a href="# 信号发送工具模拟" class="headerlink" title="信号发送工具模拟"></a> 信号发送工具模拟 </h3><p> 信号发送工具比较简易，其实就是模拟封装 <code>kill</code>，观察效果，先看一下 <code>kill</code> 函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到函数原型很简单，有两个参数，<code>pid</code> 是信号接受者的 <code>pid</code>，<code>sig</code> 是信号编号，接着就实现一个简单的脚本【脚本文件名：<code>signal_kill.c</code>】，里面直接调用 <code>kill</code> 函数，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 接收的参数个数不足 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">3</span> != argc)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[Arguments ERROR!]\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tUsage:\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\t\t% s &lt;Target_PID&gt; &lt;Signal_Number&gt;\n"</span>, argv [<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pid = atoi (argv [<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> sig = atoi (argv [<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 这里增加一个对编号判断的逻辑 </span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span> &amp;&amp; sig &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        kill (pid, sig);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Target_PID or Signal_Number MUST bigger than 0!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此特殊说明一下，关于 <code>pid</code> 的取值范围，上述代码示例把 <code>pid</code> 限制在正整数，防止出错。其实 <code>pid</code> 的取值范围很广，各有特殊含义，请参考文末的备注。</p><p>使用 <code>gcc</code> 编译后【<code>gcc -o signal_kill signal_kill.c</code>】直接运行，观察能否把信号正常发送给运行的进程。</p><p>运行脚本发送信号 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518224421.png" alt="运行脚本发送信号" title="运行脚本发送信号"></p><p> 运行的进程可以正常接收到信号 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518224412.png" alt="运行的进程可以正常接收到信号" title="运行的进程可以正常接收到信号"></p><p> 经过观察，是可以的，至此信号函数的使用演示完成。</p><h1 id="操作实践"><a href="# 操作实践" class="headerlink" title="操作实践"></a>操作实践 </h1><p> 详细认识信号的基本知识后，接下来进行实践会更加知其所以然，那就回归到正题，我来使用 <code>kill</code> 命令进行实践操作一下，演示一下常用的信号以及处理效果。</p><p>在日常工作中，一般会使用信号 1、信号 3、信号 3、信号 9、信号 15，这五个比较常用，就不再演示，只是需要留意一下它们对应的键盘快捷键，信号 2 是 <code>ctrl + c</code>，信号 3 是 <code>ctrl + \</code> 。</p><p>我想重点演示一下信号 18、信号 19 以及 <code>bg、fg、jobs</code> 命令。</p><h2 id="演示"><a href="# 演示" class="headerlink" title="演示"></a>演示 </h2><p> 开启三个进程，分别使用 <code>ctrl + z</code> 命令暂停它们的运行，在暂停时输出的日志中会有 <code>Stopped</code> 标记，并且会有进程的编号分配，在方括号中的就是【有时候暂停时还会有 <strong>核心已转储 </strong>、<strong>core dumped</strong> 的提示】。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518231714.png" alt="开启三个进程分别暂停" title="开启三个进程分别暂停"></p><p>使用 <code>jobs</code> 命令查看暂停的进程，此时每个进程会有编号，此时的三个进程分别是 2、3、4。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518231705.png" alt="jobs 查看暂停的进程" title="jobs 查看暂停的进程 v"></p><p>使用 <code>kill</code> 发送 18 号信号给编号为 4 的暂停进程，然后再次使用 <code>jobs</code> 命令查看，发现这个进程的状态已经由 <code>Stopped</code> 变为了 <code>Running</code>，说明这个进程继续运行了【但是是后台运行，没有占用终端】。</p><p>发送 18 号信号 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518232545.png" alt="发送 18 号信号" title="发送 18 号信号"></p><p> 编号为 4 的进程后台运行中 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518232554.png" alt="编号为 4 的进程后台运行中" title="编号为 4 的进程后台运行中"></p><p> 接着使用 <code>fg</code>、<code>bg</code> 命令把编号为 4 的进程调到前台运行、返回后台运行。此时可以发现，<code>fg</code>、<code>bg</code> 命令和信号 18 的作用是等价的，而且更为丰富，可以把进程在前台【占用终端】、后台【不占用终端】之间调换。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190518233026.png" alt="使用 fg、bg 命令" title="使用 fg、bg 命令"></p><h2 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h2><p> 总结一下：</p><p>对于正在运行的进程，并且等待终端的输入，此时如果使用 <strong>ctrl + c</strong> 就会导致进程退出，所以可以使用 <strong>ctrl + z</strong> 让进程暂停，并退到后台等待，此时终端被释放，可以继续输入命令。</p><p>接着可以使用 <strong>jobs</strong> 命令查看有哪些被暂停的进程【此时进程会有编号，从 1 开始】，可以使用 <strong>bg num</strong> 命令让第 <code>num</code> 个进程在后台运行，可以使用 <strong>fg num</strong> 让第 <code>num</code> 个进程在前台运行【继续占用终端】。当然，如果使用 <code>bg</code>、<code>fg</code> 时不加序号参数，则默认对最后一个进程操作。</p><h1 id="备注"><a href="# 备注" class="headerlink" title="备注"></a>备注 </h1><h2 id="段错误"><a href="# 段错误" class="headerlink" title="段错误"></a> 段错误 </h2><p> 在某一次的实际场景中，想从本地上传文件到远程服务器，具体的操作是登录远程服务器后，在终端中使用 <strong>lrz</strong> 命令【环境为 <code>CentOS</code> 系统，需要自行安装这个工具】，然后在弹出的文件浏览器中选择本地的文件。</p><p>在上传的过程中，刚刚开始没多久就报错：<strong> 段错误 (core dumped)</strong>【如果使用英文表示，为：<code>Segmentation fault</code>，后面括号里面的 <code>core dumped</code> 是核心已转储，在进程退出或者暂停时会出现】，紧接着上传进度中断，上传进程停止。</p><p>然后检查发现服务器上传文件指定目录的硬盘空间已经没有了，使用 <strong>df -h</strong> 命令查看，磁盘使用率 100%，所以无法再继续上传文件。</p><p>上面的错误： <strong>段错误 (core dumped)</strong>，我猜测可能是和信号 <strong>SIGSEGV</strong> 有关，下面就以 <code>c</code> 语言为基础写一个简单的例子，在代码中特意非法操作内存，让内核主动发送 <strong>SIGSEGV</strong> 信号给进程。</p><p>代码示例如下【脚本文件名：<code>seg_error.c</code>】，已经写好注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="comment">// 非法赋值，想改变字符串内存地址的字符串值，不被允许 </span></span><br><span class="line">    *str = <span class="string">'h'</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"% s\n"</span>, str);</span><br><span class="line">    <span class="comment">// 新定义字符串就可以 </span></span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">"world"</span>; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"% s\n"</span>, str2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>gcc</code> 编译：<strong>gcc -o seg_error seg_error.c</strong>，然后运行：<strong>./seg_error</strong>，就可以发现报错：<strong>Segmentation fault</strong>。</p><p><code>Segmentation fault</code> 报错截图 <br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190521233505.png" alt="Segmentation fault 报错截图" title="Segmentation fault 报错截图"></p><p> 如果不确定是哪几行代码出了问题，可以简单调试一下，重新编译时加上 <strong>-g</strong> 参数，再使用 <code>gdb</code> 调试器工具：<strong>gdb seg_error</strong>，开启调试模式，然后输入 <strong>r</strong> 运行，接着就可以看到具体的报错信息以及报错位置。</p><p>从下图中可以看到，程序在运行中接收到 <strong>SIGSEGV</strong> 信号而退出，并抛出 <strong>Segmentation fault</strong> 错误信息，异常代码在第 6 行：<strong>*str = ‘h’;</strong>，这 1 行代码在非法操作内存【字符串是不可改变的量，被分配在内存区域的数据段，当向该只读数据区域进行写操作即为非法】，操作系统内核【<code>kernel</code>】会通过 <code>kill</code> 命令向进程发送编号为 11 的信号，即 <code>SIGSEGV</code>【段错误】信号，进程被内核终止。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190521234109.png" alt="Segmentation 调试" title="Segmentation 调试"></p><p>除了内核在检测到非法操作时发送这个信号给进程，如果我手动发送这个信号给进程会发生什么呢，不妨试一下。随便起动一个进程【我使用 <code>tail -f seg_error.c</code> 查看文件内容】，然后使用 <code>kill</code> 命令发送 <code>SIGSEGV</code> 信号给这个进程。</p><p><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/2019/20190521235126.png" alt="手动发送 SIGSEGV 信号给进程" title="手动发送 SIGSEGV 信号给进程"></p><p>可以从上图中看到，进程由于接收到 <strong>SIGSEGV</strong> 信号而退出。</p><h2 id="进程号取值"><a href="# 进程号取值" class="headerlink" title="进程号取值"></a>进程号取值 </h2><p> 在使用 <code>kill</code> 命令时，<code>pid</code> 参数就是系统给进程分配的编号，但是这个参数除了正常的正整数之外，其它的取值有各自特殊的含义。</p><ul><li>pid 大于 0，将信号发送给进程 id 为 pid 的进程 </li><li>pid 等于 0，将信号发送给与发送进程属于同一进程组的所有进程【即进程组 id 相等的进程】</li><li>pid 等于 - 1，将该信号发送给系统内所有的进程【前提是有发送信号权限的，并且不包括系统进程集中的进程】</li><li>pid 小于 - 1，将该信号发送给其进程组 id 等于 pid 绝对值的所有进程【针对进程组】</li></ul><h2 id="可靠信号与不可靠信号"><a href="# 可靠信号与不可靠信号" class="headerlink" title="可靠信号与不可靠信号"></a> 可靠信号与不可靠信号 </h2><p> 以上内容在讨论信号的知识点与实际演示时，都没有考虑到信号的可靠性问题，默认都是能送达的。但是，信号是区分可靠信号、不可靠信号的。</p><ul><li>不可靠信号，信号可能会丢失，而一旦信号丢失【多次信号不排队】，进程是无法接收这个信号的。Linux 的信号机制基本上是从 Unix 系统中继承过来的，早期 Unix 系统中的信号机制比较简单和原始，后来在实践中逐渐暴露出一些问题。因此，把那些建立在早期 Unix 信号机制上的信号叫做 <strong>不可靠信号 </strong>，信号值小于 SIGRTMIN【不同系统会有微小的差别，例如在 CentOS 中是 34】的信号都是不可靠信号。</li><li>可靠信号，也称为阻塞信号，当发送了一个阻塞信号，并且该信号的动作是系统默认动作或捕捉该信号，则信号从发出以后会一直保持未决的状态，直到该进程对此信号解除了阻塞，或将对此信号的动作更改为忽略。随着时间的发展，实践证明了有必要对信号的原始机制加以改进和扩充。所以，后来出现的各种 Unix 版本分别在这方面进行了研究，力图实现 <strong>可靠信号 </strong>。由于原来定义的信号已有许多应用，不好再做改动，最终只好又新增加了一些信号，并在一开始就把它们定义为可靠信号，这些信号支持排队，不会丢失，信号值的范围在 SIGRTMIN 和 SIGRTMAX 之间。同时，信号的发送和安装也出现了新版本：信号发送函数 sigqueue () 以及信号的安装函数 sigaction () 。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近在实际应用场景中，需要使用 &lt;code&gt;Linux&lt;/code&gt; 系统的 &lt;strong&gt;kill&lt;/strong&gt; 命令来控制程序的生命周期，例如 &lt;strong&gt;ctrl + c&lt;/strong&gt;、&lt;strong&gt;ctrl + z&lt;/strong&gt;、&lt;strong&gt;kill -9 pid&lt;/strong&gt; 等，而这些命令在日常的工作当中也是非常常见的并且很好用。为了多了解一些 &lt;code&gt;Linux&lt;/code&gt; 中信号常量的知识点，以及 &lt;code&gt;kill&lt;/code&gt; 命令的基本原理，我整理了这一篇博客。&lt;/p&gt;&lt;p&gt;本文中涉及的 &lt;code&gt;c&lt;/code&gt; 语言脚本已经被我上传至 &lt;code&gt;GitHub&lt;/code&gt;，读者可以提前下载查看：&lt;a href=&quot;https://github.com/iplaypi/iplaypistudy/tree/master/iplaypistudy-normal/src/bin/20190421&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;signal 相关脚本&lt;/a&gt; ，脚本命名与下文中描述一致。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux 命令系列" scheme="https://www.playpi.org/categories/series-of-linux-cmd/"/>
    
    
      <category term="Linux" scheme="https://www.playpi.org/tags/Linux/"/>
    
      <category term="kill" scheme="https://www.playpi.org/tags/kill/"/>
    
      <category term="jobs" scheme="https://www.playpi.org/tags/jobs/"/>
    
  </entry>
  
  <entry>
    <title>JNI 字段描述符基础知识</title>
    <link href="https://www.playpi.org/2019041301.html"/>
    <id>https://www.playpi.org/2019041301.html</id>
    <published>2019-04-13T09:12:45.000Z</published>
    <updated>2019-04-14T09:12:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>平时在做 Java 开发的时候，难免遇到异常信息中包含一种特殊的表达字符串，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method: createWorker signature: (Ljava/util/concurrent/Executor;) Lorg/jboss/netty/channel/socket/nio/AbstractNioWorker;</span><br></pre></td></tr></table></figure><p>或者 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: com.fasterxml.jackson.databind.JavaType.isReferenceType () Z</span><br></pre></td></tr></table></figure><p> 可以看到，异常信息中有一种特殊的字符串出现了：<strong>L 后面跟着类名 </strong>、<strong> 方法后面跟了一个 Z</strong>。其实，这就是 <strong>JNI 字段描述符【Java Native Interface FieldDescriptors】</strong>，它是一种对 Java 数据类型、数组、方法的编码。此外，在 Android 逆向分析中，通过反汇编得到的 smali 文件，里面的代码也会遵循这种方式，即 Dalvik 字节码。本文就记录一些数据类型、数组、方法的编码方式以及解释说明，方便以后查阅。</p><a id="more"></a><h1 id="基本概念"><a href="# 基本概念" class="headerlink" title="基本概念"></a>基本概念 </h1><p> 这种编码方式把 Java 中的基本数据类型、数组、对象都使用一种规范来表示：</p><ul><li>八种基本数据类型都使用一个大写字母表示 </li><li>void 使用 V 表示</li><li> 数组使用左方括号表示 </li><li> 方法使用一组圆括号表示，参数在括号里，返回类型在括号右侧 </li><li> 对象使用 L 开头，分号结束，中间是类的完整路径，包名使用正斜杠分隔 </li></ul><h1 id="基本编码"><a href="# 基本编码" class="headerlink" title="基本编码"></a> 基本编码 </h1><p> 基本编码如下表格，并配有解释说明：</p><table><thead><tr><th style="text-align:center">Java 类型 </th><th style="text-align:center">JNI 字段描述符</th></tr></thead><tbody><tr><td style="text-align:center">boolean</td><td style="text-align:center">Z</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">B</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">S</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">I</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">J</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">F</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">D</td></tr><tr><td style="text-align:center">void</td><td style="text-align:center">V</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center"> 以 L 开头，以；结尾，中间是使用 / 隔开的完整包名、类型。例如：Ljava/lang/String;。如果是内部类，添加 $ 符号分隔，例如：Landroid/os/FileUtils$FileStatus;。</td></tr><tr><td style="text-align:center">数组 </td><td style="text-align:center">[</td></tr><tr><td style="text-align:center"> 方法 </td><td style="text-align:center"> 使用 () 表示，参数在圆括号里，返回类型在圆括号右侧，例如：(II) Z，表示 boolean func (int i,int j)。</td></tr></tbody></table><h1 id="举例说明"><a href="# 举例说明" class="headerlink" title="举例说明"></a>举例说明 </h1><h2 id="数据类型"><a href="# 数据类型" class="headerlink" title="数据类型"></a> 数据类型 </h2><p>1、<strong>[I</strong>：表示 int 一维数组，即 <strong>int []</strong>。<br>2、<strong>Ljava/lang/String;</strong>：表示 String 类型，即 <strong>java.lang.String</strong>。<br>3、<strong>[Ljava/lang/Object;</strong>：表示 Object 一维数组，即 <strong>java.lang.Object []</strong>。<br>4、<strong>Z</strong>：表示 boolean 类型。<br>5、<strong>V</strong>：表示 void 类型。</p><h2 id="方法"><a href="# 方法" class="headerlink" title="方法"></a> 方法</h2><p>1、<strong>() V</strong>：表示参数列表为空，返回类型为 void 的方法，即 <strong>void func ()</strong>。<br>2、<strong>(II) V</strong>：表示参数列表为 int、int，返回类型为 void 的方法，即 <strong>void func (int i,int j)</strong>。<br>3、<strong>(Ljava/lang/String;Ljava/lang/String;) I</strong>：表示参数列表为 String、String，返回类型为 int 的方法，即 <strong>int func (String i,String j)</strong>。<br>4、<strong>([B) V</strong>：表示参数列表为 byte []，返回类型为 void 的方法，即 <strong>void func (byte [] bytes)</strong>。<br>5、<strong>(ILjava/lang/Class;) J</strong>：表示参数列表为 int、Class，返回类型为 long 的方法，即 <strong>long func (int i,Class c)</strong>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;平时在做 Java 开发的时候，难免遇到异常信息中包含一种特殊的表达字符串，例如：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;method: createWorker signature: (Ljava/util/concurrent/Executor;) Lorg/jboss/netty/channel/socket/nio/AbstractNioWorker;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;或者&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.lang.NoSuchMethodError: com.fasterxml.jackson.databind.JavaType.isReferenceType () Z&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;可以看到，异常信息中有一种特殊的字符串出现了：&lt;strong&gt;L 后面跟着类名 &lt;/strong&gt;、&lt;strong&gt; 方法后面跟了一个 Z&lt;/strong&gt;。其实，这就是 &lt;strong&gt;JNI 字段描述符【Java Native Interface FieldDescriptors】&lt;/strong&gt;，它是一种对 Java 数据类型、数组、方法的编码。此外，在 Android 逆向分析中，通过反汇编得到的 smali 文件，里面的代码也会遵循这种方式，即 Dalvik 字节码。本文就记录一些数据类型、数组、方法的编码方式以及解释说明，方便以后查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="JNI" scheme="https://www.playpi.org/tags/JNI/"/>
    
      <category term="字段描述符" scheme="https://www.playpi.org/tags/JNI-chn/"/>
    
  </entry>
  
  <entry>
    <title>预估 Mysql 数据表的数据大小和索引大小</title>
    <link href="https://www.playpi.org/2019041001.html"/>
    <id>https://www.playpi.org/2019041001.html</id>
    <published>2019-04-10T08:27:18.000Z</published>
    <updated>2019-04-13T08:27:18.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>最近接到一个小的新需求，需求很容易实现，就是定时把一些分析得出的指标从 Elasticsearch 中离线存储到 Mysql 数据库中，方便以后查询。离线存储的原因是因为资源不足，Elasticsearch 会自动删除 15 天以前的原始数据，而且 Elasticsearch 每天都会新产生数十万到数百万的数据，依据这些原始数据只会产生几十条分析结果，显然离线存储到 Mysql 中更为合理。在处理这个需求时，接着就遇到了一个小问题，当前业务组没有数据库资源，需要申请，而且由于资源不足，不能随便申请，要给出合理的预估值。这样，就涉及到数据库占用空间大小的预估了，本文记录一种简单的方法。</p><a id="more"></a><h1 id="数据大小和索引大小预估"><a href="# 数据大小和索引大小预估" class="headerlink" title="数据大小和索引大小预估"></a>数据大小和索引大小预估 </h1><p> 我当前使用的是 Mysql 数据库，其它数据库产品查询方式可能会有所不同，请根据实际情况操作。</p><p>在数据库中，使用系统数据库的表 <strong>TABLES</strong> 进行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT data_length,index_length</span><br><span class="line">FROM information_schema.TABLES t</span><br><span class="line">WHERE table_schema=&apos;your_db_name&apos;</span><br><span class="line">AND table_name = &apos;your_table_name&apos;;</span><br></pre></td></tr></table></figure><p>其中，系统数据库是 <strong>information_schema</strong>，存储表信息的表是 <strong>TABLES</strong>，<strong>data_length</strong>、<strong>index_length</strong> 这 2 个字段表示数据大小、索引大小，单位是字节 B。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g228n8cy91j20cd06gq2x.jpg" alt="SQL 查询数据空间大小" title="SQL 查询数据空间大小"></p><p>当然，如果使用可视化的数据库连接管理工具，也可以通过管理工具直接鼠标点击查看，其实背后的逻辑仍旧是查询 <strong>TABLES</strong> 表，例如我通过 <strong>Navicat</strong> 工具查看。<br><img src="https://raw.githubusercontent.com/iplaypi/img-playpi/master/img/old/b7f2e3a3gy1g228nw2hx5j20er0c1t8y.jpg" alt="Navicat 查看表信息" title="Navicat 查看表信息"></p><p>可见，无论使用哪种方式，都可以把需要的信息查询出来，然后就可以预估数据大小了。我截图的信息显示，数据大小 <strong>8.5MB</strong>，索引大小 <strong>0MB</strong>，还要结合数据条数，我查了一下有 10000 条数据，因此可以粗略估计每条数据的大小为 <strong>0.85KB</strong>。这里需要注意一下，预估数据大小之前要保证数据的字段取值接近真实情况，最好能有数据示例可以参考，而且数据量要尽量大一些，例如几万条，不能只有几十条、几百条。</p><p>如果确实没有数据示例参考，需要自己模拟生成，尽量把字段的取值多生成一些实际中可能出现的值。例如字符串类型如果是 <strong>vachar</strong>，要把每种长度的取值都生成一些，或者根据实际场景，某些长度的字符串出现的可能性大一点，那就多生成一些。</p><p>如果觉得这样计算比较麻烦的话，其实还有一种更简单的方法，直接查询 <strong>avg_row_length</strong> 字段，这个字段表示数据表的平均行大小，和上面自己计算的结果类似。</p><p>总之，就是为了接近真实，才能更为准确地预估出数据占用的空间大小，实际去申请资源时才能有理有据。</p><p>此外，这个 <strong>TABLES</strong> 表里面的内容很丰富的，有需要的可以查询一下，查看数据表的字段信息 SQL 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW COLUMNS FROM TABLES;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近接到一个小的新需求，需求很容易实现，就是定时把一些分析得出的指标从 Elasticsearch 中离线存储到 Mysql 数据库中，方便以后查询。离线存储的原因是因为资源不足，Elasticsearch 会自动删除 15 天以前的原始数据，而且 Elasticsearch 每天都会新产生数十万到数百万的数据，依据这些原始数据只会产生几十条分析结果，显然离线存储到 Mysql 中更为合理。在处理这个需求时，接着就遇到了一个小问题，当前业务组没有数据库资源，需要申请，而且由于资源不足，不能随便申请，要给出合理的预估值。这样，就涉及到数据库占用空间大小的预估了，本文记录一种简单的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Mysql" scheme="https://www.playpi.org/tags/Mysql/"/>
    
      <category term="数据库" scheme="https://www.playpi.org/tags/database-chn/"/>
    
      <category term="database" scheme="https://www.playpi.org/tags/database/"/>
    
      <category term="space" scheme="https://www.playpi.org/tags/space/"/>
    
  </entry>
  
  <entry>
    <title>使用 JDK 命令行工具分析内存泄漏或内存溢出问题</title>
    <link href="https://www.playpi.org/2019040301.html"/>
    <id>https://www.playpi.org/2019040301.html</id>
    <published>2019-04-03T10:14:23.000Z</published>
    <updated>2019-04-20T10:14:23.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --><p>最近遇到一个棘手的问题，有业务方在调用存储系统封装的 SDK 取数的过程中，遇到了 OOM 问题，但是数据量很小，只有 12000 条。同时进程启动时申请的内存高达 12g，使用 Xmx、Xms 参数控制，实际指定参数取值为：-Xms12g -Xmx12g。但是如果只看报错日志信息，抛出异常的代码位置指向了 SDK 的内部代码。根据这个现象，我猜测可能是业务方的处理逻辑问题、SDK 内部处理逻辑问题、申请的内存过小问题，这些问题归根结底，要么是内存不够【内存溢出】，要么是内存不当使用【内存泄漏】。所以，我要在 Java 虚拟机参数方面或者业务方代码逻辑方面入手，一步一步测试，找出问题的元凶。本文就记录这一过程，以及适当引申一些关于 JVM 的知识。</p><p>解释说明一下，上述中的 SDK 表示存储系统独立封装的取数、查询接口，它屏蔽了 Elasticsearch 自带的接口，并封装成公共组件，提供给各个业务方使用。各个业务方在使用前，需要申请开通 token 验证码，存储系统会根据业务方的使用量分配合适的资源，业务方在调用时需要传入 token 验证。这样做的好处，一是可以监控所有的业务方的取数、查询情况，收集所有的请求日志，统计一些常用的指标，然后反过来指导存储系统的改进，例如根据业务方的调用情况进行资源分配的伸缩、针对常用的数据类型进行索引优化。二是可以保障整个数据库集群的正常运行，由于屏蔽了 Elasticsearch 自带的接口，业务方不能随意操作超大额的数据量，SDK 会做限制，因此不会产生某些不合理的查询、取数请求，从而不对数据库造成巨大的压力。三是限制了一些不需要的查询、取数方式，在保障业务方基本需求的情况下又可以保障数据库集群的稳定，例如多层聚合、日期聚合等操作，这些操作不合理，而且会对数据库集群造成压力【无论数据量大小都可能会出事】。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 简单描述现象，查看日志，猜测可能的原因。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><h2 id="分析现象"><a href="# 分析现象" class="headerlink" title="分析现象"></a> 分析现象 </h2><p> 一开始没有指定 JVM 参数，因为使用的是 JDK1.7 版本的参数，不会生效，这就导致分配的默认堆取值偏小。</p><p>JVM 参数设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA=$&#123;JAVA_HOME&#125;/bin/java</span><br><span class="line"># 设置 jvm 的参数 </span><br><span class="line">#HEAP_OPTS=&quot;-Xms12g -Xmx12g&quot;</span><br><span class="line">HEAP_OPTS=&quot;-Xms6g -Xmx6g -Xmn2g&quot;</span><br><span class="line"># JDK8 以后取消了 PermSize</span><br><span class="line">#PERM_OPTS=&quot;-XX:PermSize=1024M -XX:MaxPermSize=2048m -XX:+UseConcMarkSweepGC -XX:+UseParNewGC&quot;</span><br><span class="line">#JDK8 的 MetaspaceSize</span><br><span class="line">PERM_OPTS=&quot;-XX:MetaspaceSize=1024m -XX:MaxMetaspaceSize=2048m -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+HeapDumpOnOutOfMemoryError&quot;</span><br></pre></td></tr></table></figure><p>待整理，重试，重现现象，确保问题准确复现。</p><h2 id="掌握内存分析工具"><a href="# 掌握内存分析工具" class="headerlink" title="掌握内存分析工具"></a>掌握内存分析工具 </h2><p> 待整理。各种工具介绍，举例，截图。</p><h2 id="对症下药解决问题"><a href="# 对症下药解决问题" class="headerlink" title="对症下药解决问题"></a>对症下药解决问题 </h2><p> 待整理。减小内存，使用普通的 list。<br>重试，使用命令行工具查看现象，截图。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结 </h1><h2 id="不同版本的参数不一致"><a href="# 不同版本的参数不一致" class="headerlink" title="不同版本的参数不一致"></a> 不同版本的参数不一致 </h2><p> 主要是针对 JDK 来说的，不同的 JDK 版本的参数会有一些不同，例如以下 2 个虚拟机参数，在 JDK1.8 的环境中是 <strong>-XX:MetaspaceSize=1024m -XX:MaxMetaspaceSize=2048m</strong>，已经不是 <strong>-XX:PermSize=1024M -XX:MaxPermSize=2048m</strong> 了【JDK 1.7 以及以前的版本】，在进程启动的时候查看日志会有警告信息的，提示参数设置无效，会被忽略。</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>占用内存，待整理。</p><h2 id="模拟内存溢出"><a href="# 模拟内存溢出" class="headerlink" title="模拟内存溢出"></a>模拟内存溢出 </h2><p> 待整理。</p><h2 id="进程已杀死问题"><a href="# 进程已杀死问题" class="headerlink" title="进程已杀死问题"></a>进程已杀死问题 </h2><p> 加大内存，机器内存不够分配，进程异常退出，待整理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Sep 01 2019 21:42:52 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近遇到一个棘手的问题，有业务方在调用存储系统封装的 SDK 取数的过程中，遇到了 OOM 问题，但是数据量很小，只有 12000 条。同时进程启动时申请的内存高达 12g，使用 Xmx、Xms 参数控制，实际指定参数取值为：-Xms12g -Xmx12g。但是如果只看报错日志信息，抛出异常的代码位置指向了 SDK 的内部代码。根据这个现象，我猜测可能是业务方的处理逻辑问题、SDK 内部处理逻辑问题、申请的内存过小问题，这些问题归根结底，要么是内存不够【内存溢出】，要么是内存不当使用【内存泄漏】。所以，我要在 Java 虚拟机参数方面或者业务方代码逻辑方面入手，一步一步测试，找出问题的元凶。本文就记录这一过程，以及适当引申一些关于 JVM 的知识。&lt;/p&gt;&lt;p&gt;解释说明一下，上述中的 SDK 表示存储系统独立封装的取数、查询接口，它屏蔽了 Elasticsearch 自带的接口，并封装成公共组件，提供给各个业务方使用。各个业务方在使用前，需要申请开通 token 验证码，存储系统会根据业务方的使用量分配合适的资源，业务方在调用时需要传入 token 验证。这样做的好处，一是可以监控所有的业务方的取数、查询情况，收集所有的请求日志，统计一些常用的指标，然后反过来指导存储系统的改进，例如根据业务方的调用情况进行资源分配的伸缩、针对常用的数据类型进行索引优化。二是可以保障整个数据库集群的正常运行，由于屏蔽了 Elasticsearch 自带的接口，业务方不能随意操作超大额的数据量，SDK 会做限制，因此不会产生某些不合理的查询、取数请求，从而不对数据库造成巨大的压力。三是限制了一些不需要的查询、取数方式，在保障业务方基本需求的情况下又可以保障数据库集群的稳定，例如多层聚合、日期聚合等操作，这些操作不合理，而且会对数据库集群造成压力【无论数据量大小都可能会出事】。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="JDK" scheme="https://www.playpi.org/tags/JDK/"/>
    
      <category term="内存泄漏" scheme="https://www.playpi.org/tags/memory-leak-chn/"/>
    
      <category term="内存溢出" scheme="https://www.playpi.org/tags/memory-overflow-chn/"/>
    
      <category term="jvm" scheme="https://www.playpi.org/tags/jvm/"/>
    
  </entry>
  
</feed>
