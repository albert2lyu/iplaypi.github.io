<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虾丸派</title>
  
  <subtitle>烂笔头</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.playpi.org/"/>
  <updated>2019-02-11T11:47:12.000Z</updated>
  <id>https://www.playpi.org/</id>
  
  <author>
    <name>playpi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>鸡蛋饼做法总结</title>
    <link href="https://www.playpi.org/2019021001.html"/>
    <id>https://www.playpi.org/2019021001.html</id>
    <published>2019-02-10T11:47:12.000Z</published>
    <updated>2019-02-11T11:47:12.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>鸡蛋饼算是一种小吃，做法多种多样，可以煎，可以烙，可以蒸；吃法也多种多样，有的地方会卷配菜吃，有的地方会配粥吃，有的地方会直接吃。总而言之，鸡蛋饼算是一种万能美食，全国各地都有，大家也都喜欢吃，本文就记录鸡蛋煎饼的做法总结，本文记录的做法是采用煎的方式，另外还会额外放点葱花。</p><a id="more"></a><h1 id="食材准备"><a href="# 食材准备" class="headerlink" title="食材准备"></a>食材准备 </h1><p> 以下准备的食材可以煎 15 个鸡蛋饼左右：</p><p>1、鸡蛋 4 个（喜欢的话多放点也可以）；</p><p>2、200-300 克面粉（可以煎 15 个左右，面粉不能确定量，是因为如果面糊没有配好，就适量加水或者加面，调整好为止，具体会用到多少看情况了）；</p><p>3、小葱 5 根（根据个人口味添加，多点少点都行）；</p><p>适量的食材 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1g02zsjak5uj229s29sb2a.jpg" alt="适量的食材" title="适量的食材"></p><h1 id="制作步骤"><a href="# 制作步骤" class="headerlink" title="制作步骤"></a> 制作步骤 </h1><p> 制作步骤很简单，只要能煎好一张饼，重复进行就行了，煎好一张饼大概需要 3 分钟。当然，如果是第一次煎饼，可能煎前面几张饼的时候需要练习一下，也可能需要重新调制面糊，所以时间会长一点，但是为了煎饼成功，麻烦一点也值了。</p><p>调制面糊的过程就不记录了，就是加盐（4 勺）、葱花、面粉、鸡蛋、水（最好可以用凉白开，别直接使用自来水）搅拌即可，如果里面有很多面疙瘩，不用担心，静置 10 分钟搅拌一次，重复 3 次左右面疙瘩即全部溶于水。</p><p>面糊调制初步，还有很多面疙瘩 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1g02zsyhqz9j229s29sx6p.jpg" alt="面糊调制初步" title="面糊调制初步"></p><p> 面糊调制完成 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1g02zt8lieaj229s29s1ky.jpg" alt="面糊调制完成" title="面糊调制完成"></p><p> 粘稠度大概这样，不会很粘稠，和液体差不多 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1g02ztjniz7j229s29s1ky.jpg" alt="粘稠度大概这样" title="粘稠度大概这样"></p><p>1，锅里加油烧热，只要半勺即可（吃饭的那种小汤勺），多了会腻，然后火力转小火，并一直持续小火。</p><p> 半勺油的量 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1g02zttlh5dj229s29su0x.jpg" alt="半勺油的量" title="半勺油的量"></p><p>2，放入一汤勺面糊（烧汤那种大汤勺，或者电饭煲自带的那种粥勺），如果发现煎出来的饼太厚了或者太大了，可以适当少放一点点面糊，具体放多少自己把握。然后适当转动煎锅，让面糊呈圆形（一定要快，10 秒内完成，否则因为受热不均匀，饼可能会散开变成多块，或者是一个圆环饼套着一个小圆饼），等逐渐凝固后就成了圆饼，然后接触锅的那一面就变得金黄，这个过程大概 1 分钟。</p><p> 一大汤勺面糊 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1g02zu5p94aj229s29s7wi.jpg" alt="一大汤勺面糊" title="一大汤勺面糊"></p><p> 加面糊到锅里 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1g02zuex8yfj229s29sqv5.jpg" alt="加面糊到锅里" title="加面糊到锅里"></p><p> 转动成型 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1g02zuu7r6ej229s29su0x.jpg" alt="转动成型" title="转动成型"></p><p>3，等凝固后就可以翻身了，这个步骤说简单也简单，说难也难，如果直接用锅不方便翻身的话，可以借助铲子，翻身后，可以看到饼的上一面已经煎好了，金黄的。这个时候注意要适当把饼转动一下，吸收一下油，避免粘锅。</p><p> 给饼翻身 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1g02zv4hgxoj229s29s7wi.jpg" alt="给饼翻身" title="给饼翻身"></p><p>4，翻身后再煎 1 分钟左右，就可以出锅了，如果看到饼上面哪里煎的不均匀，还没熟，可以再着重煎几十秒。切记不能煎太久，要不然饼就糊了。</p><p> 翻身后继续煎 1 分钟，再根据实际情况着重煎一下，准备出锅 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1g02zvduw1jj229s29su0x.jpg" alt="准备出锅" title="准备出锅"></p><p>5，出锅装盘，继续下一张鸡蛋饼。</p><p> 全部出锅装盘 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1g02zvpluirj229s29sb2a.jpg" alt="全部出锅装盘" title="全部出锅装盘"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项</h1><p>1、特别注意，如果调制面糊不是特别熟练的话，可能面糊的粘稠度不适合，或者调味偏淡偏咸，这样都不好，所以最好尝试着煎一个，然后品尝一下，如果味道不对再加调料，如果煎出来的饼不对，再加水或者面粉。多试几次，确保煎出来的饼自己满意。如果一味地煎饼，最后发现不好吃，那就浪费了；</p><p>2、如果有两个锅可以用，为了节省时间，最好两个锅同时煎，要不然整个过程很枯燥，因为有一半的时间都在等待；</p><p>3、有时候可能看着好像煎糊了，不用担心，不影响吃，因为出锅后等一会儿，褐色就会变成金黄色，非常好看；</p><p>4、整个过程一定要确保是小火，否则饼很快就糊了；</p><p>5、难点在于翻身，只要一出错一张饼就废了（或者变成了一堆碎饼）。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;鸡蛋饼算是一种小吃，做法多种多样，可以煎，可以烙，可以蒸；吃法也多种多样，有的地方会卷配菜吃，有的地方会配粥吃，有的地方会直接吃。总而言之，鸡蛋饼算是一种万能美食，全国各地都有，大家也都喜欢吃，本文就记录鸡蛋煎饼的做法总结，本文记录的做法是采用煎的方式，另外还会额外放点葱花。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="鸡蛋饼" scheme="https://www.playpi.org/tags/%E9%B8%A1%E8%9B%8B%E9%A5%BC/"/>
    
      <category term="鸡蛋葱饼" scheme="https://www.playpi.org/tags/%E9%B8%A1%E8%9B%8B%E8%91%B1%E9%A5%BC/"/>
    
      <category term="鸡蛋煎饼" scheme="https://www.playpi.org/tags/%E9%B8%A1%E8%9B%8B%E7%85%8E%E9%A5%BC/"/>
    
  </entry>
  
  <entry>
    <title>ItChat 系列 0 - 初识 ItChat</title>
    <link href="https://www.playpi.org/2019020701.html"/>
    <id>https://www.playpi.org/2019020701.html</id>
    <published>2019-02-07T14:58:07.000Z</published>
    <updated>2019-02-07T14:58:07.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>微信已经是我们日常生活中常用的 APP 之一，每天都离不开。作为掌握技术的理工科人员，有时候总想着是否可以利用微信的接口完成一些重复的工作，例如群发消息、自动回复、接入机器人自动聊天等。当然，这些都可以实现，而且只要是人工可以做到的事情，基本都可以做到自动化（前提是微信提供了对应的接口，反例就是自动收发红包不行，当然微信不会直接提供 API 接口，需要自己寻找）。本文就讲解为了做到这些，需要的入门知识点，主要就是利用 ItChat 工具（屏蔽了微信的 API 接口，简化了使用微信接口的过程，不懂技术的普通人也可以轻松掌握），当然本文只是一个入门的例子而已（完成后对自己来说很实用而且有成就感），后续会讲解更加深入与广泛的内容。本文基于 Windows 7 操作系统，Python 2.7 版本（为了兼容性与易维护性，我推荐使用 Python 3.x 版本）</p><a id="more"></a><h1 id="ItChat- 简介"><a href="#ItChat- 简介" class="headerlink" title="ItChat 简介"></a>ItChat 简介 </h1><p> 摘录官方文档描述：</p><blockquote><p>itchat 是一个开源的微信个人号接口，使用 python 调用微信从未如此简单；<br>使用不到三十行的代码，你就可以完成一个能够处理所有信息的微信机器人；<br>当然，该 api 的使用远不止一个机器人，更多的功能等着你来发现；<br>该接口与公众号接口 itchatmp 共享类似的操作方式，学习一次掌握两个工具；<br>如今微信已经成为了个人社交的很大一部分，希望这个项目能够帮助你扩展你的个人的微信号、方便自己的生活。</p></blockquote><p>当然，我是觉得上面的描述有一些语句不通顺，但是不影响我们理解作者的原意。</p><p>其实微信官方并没有提供详细的 API 接口，ItChat 是利用网页版微信收集了接口信息，然后独立封装一层，屏蔽掉底层的接口信息，提供一套简单的使用接口，方便使用者调用，这不仅提升了效率，还扩展了使用人群。</p><h1 id="使用入门"><a href="# 使用入门" class="headerlink" title="使用入门"></a>使用入门 </h1><p> 以下使用入门包括基础环境的安装、itcaht 的安装、代码的编写、实际运行，当然，为了避免赘述，不会讲解的很详细，如果遇到一些问题，自行利用搜索引擎解决。</p><h2 id="安装 -Python- 环境"><a href="# 安装 -Python- 环境" class="headerlink" title="安装 Python 环境"></a>安装 Python 环境 </h2><h3 id="下载 -Python"><a href="# 下载 -Python" class="headerlink" title="下载 Python"></a> 下载 Python</h3><p>去官网：<a href="https://www.python.org/downloads/windows" target="_blank" rel="noopener">https://www.python.org/downloads/windows</a> ，选择自己需要的版本，我这里选择 Windows 系统的版本（64 位操作系统），Python 2.7（这是一个很古老的版本了，推荐大家使用 3.x 版本）；</p><p>我选择的版本 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzcck7qfjj21hc0p6n0z.jpg" alt="Windows 系统 64 位" title="Windows 系统 64 位"></p><p> 下载过程就和下载普通的文件、视频等一样，根据网速的限制有快有慢。</p><h3 id="安装 -Python"><a href="# 安装 -Python" class="headerlink" title="安装 Python"></a>安装 Python</h3><p>就像安装普通程序一样，直接双击下载的程序文件，选择安装即可，这里就不再赘述详细的安装过程了；</p><p>如果你们的环境不是 Windows 7 系统的，可以自行使用搜索引擎搜索教程；</p><p>这里一定要注意安装的版本是否适配自己的操作系统（包括系统类型与系统位数）；</p><p>在 Windows 系统的 <strong>程序和功能 </strong>中查看已经安装完成的 Python 程序（2.7 版本，我是使用 Anaconda2 安装的，所以看起来有些不一样）：<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzcbr6amhj20y80k5q5m.jpg" alt="windows 程序和功能" title="windows 程序和功能"></p><h3 id="配置环境变量"><a href="# 配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量 </h3><p> 如果这一步忽略了，使用 Python 或者 Python 自带的插件的时候（比如安装 ItChat 的时候就会用到 pip 工具），会找不到应用程序，只能先进入到 Python 目录或者插件所在的目录再使用对应的工具（例如进入 Python 所在的目录或者 pip 所在的目录），比较麻烦，所以在此建议大家配置一下环境变量；</p><p>配置环境变量的过程也不再赘述，大家自己利用搜索引擎获取，下图是基于 Windows 7 版本的配置截图示例；</p><p><strong>系统属性 </strong><br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzcdqptjbj215o0ngtez.jpg" alt="系统属性" title="系统属性"></p><p><strong> 高级系统设置 </strong><br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzcf7mux2j20fe0f7ta0.jpg" alt="高级系统设置" title="高级系统设置"></p><p><strong> 环境变量 </strong>，我这里编辑用户环境变量 PATH 的内容（如果不存在就新建，当然编辑系统环境变量 PATH 的内容也是可以的），切记内容一定是英文格式下的，多个使用英文逗号分隔 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzcfp2cdvj20ei0e03zq.jpg" alt="环境变量" title="环境变量"></p><p><strong> 用户环境变量 </strong>，我这里需要填写 2 条内容，使用英文逗号隔开（如果是直接安装的 Python，pip 和 python 应该在同一个路径下面，所以只需要 1 条就行了）<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzcg8856yj20ei0e0q4d.jpg" alt="用户环境变量" title="用户环境变量"></p><p>我的环境需要配置 2 条内容 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzcgokfnqj209501tmwy.jpg" alt="配置 2 条内容" title="配置 2 条内容"></p><p> 内容解释：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--pip 所在目录 </span><br><span class="line">D:\Anaconda2\Scripts\;</span><br><span class="line">--python 所在目录 </span><br><span class="line">D:\Anaconda2;</span><br></pre></td></tr></table></figure><h2 id="安装 -ItChat- 工具"><a href="# 安装 -ItChat- 工具" class="headerlink" title="安装 ItChat 工具"></a>安装 ItChat 工具 </h2><p> 在 Python 安装完成的情况下，才能进行接下来的操作，因为 ItChat 是基于 Python 环境运行的；为了验证 Python 是否正确安装，可以在命令行中输入 python，如果看到以下内容，就说明 Python 安装成功：<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzfxmlh41j20n60873zj.jpg" alt="验证 Python" title="验证 Python"></p><p>接下来利用 pip 工具（Python 自带的）直接安装 itchat，非常简单，使用命令（如果 pip 命令不可用，请检查 Python 的安装目录是否存在 pip.exe 文件）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install itchat</span><br></pre></td></tr></table></figure><p></p><p>安装 ItChat<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzfy2t8p5j20be016741.jpg" alt="itchat 安装命令" title="itchat 安装命令"></p><p>如果看到以下内容，说明 ItChat 安装成功：<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzfyl5gcsj20n60a6t9e.jpg" alt="itchat 安装成功" title="itchat 安装成功"></p><h2 id="入门代码示例"><a href="# 入门代码示例" class="headerlink" title="入门代码示例"></a>入门代码示例 </h2><p> 一切准备就绪，接下来就可以写代码了，当然，入门代码非常简单实用（我会尽可能多的添加注释说明）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 从 python 环境中导入 itchat 包，re 正则表达式包 </span></span><br><span class="line"><span class="keyword">import</span> itchat, re</span><br><span class="line"><span class="comment"># 从 itchat.content 中导入所有类、常量 (例如代码中的 TEXT 其实就是 itchat.content.TEXT 常量)</span></span><br><span class="line"><span class="keyword">from</span> itchat.content <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 导入时间包里面的 sleep 方法 </span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="comment"># 导入随机数包 </span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 注册消息类型为文本 (即只监控文本消息，其它的例如语音 / 图片 / 表情包 / 文件都不会监控)</span></span><br><span class="line"><span class="comment"># 也就是说只有普通的文字微信消息才能触发以下的代码 </span></span><br><span class="line"><span class="comment"># isGroupChat=True 开启群聊模式，即只是监控群聊内容 (如果不开启就监控个人聊天，不监控群聊)</span></span><br><span class="line"><span class="meta">@itchat.msg_register ([TEXT], isGroupChat=True)</span></span><br><span class="line"><span class="comment"># @itchat.msg_register ([TEXT])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text_reply</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="comment"># msg 是消息体，msg ['Text'] 用来获取消息内容 </span></span><br><span class="line">    <span class="comment"># 第一个单引号中的内容是关键词，使用正则匹配，可以自行更改 (我使用.* 表示任意内容), 如果使用中文注意 2.x 版本的 Python 会报错，需要 u 前缀 </span></span><br><span class="line">    message = msg [<span class="string">'Text'</span>]</span><br><span class="line">    print (message)</span><br><span class="line">    match = re.search (<span class="string">'.*'</span>, message)</span><br><span class="line">    <span class="comment"># match = re.search (u'年 | 春 | 快乐', message)</span></span><br><span class="line">    <span class="comment"># 增加睡眠机制，随机等待一定的秒数 (1-10 秒) 再回复，更像人类 </span></span><br><span class="line">    second = random.randint (<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">    sleep (second)</span><br><span class="line">    <span class="keyword">if</span> match:</span><br><span class="line">      <span class="comment"># msg ['FromUserName'] 用来获取用户名，发送消息给对方 </span></span><br><span class="line">      from_user_name = msg [<span class="string">'FromUserName'</span>]</span><br><span class="line">  print (from_user_name)</span><br><span class="line">      itchat.send ((<span class="string">'====test message'</span>), from_user_name)</span><br><span class="line">      <span class="comment"># 第一个单引号中的内容是回复的内容，可以自行更改 </span></span><br><span class="line"><span class="comment"># 热启动，退出一定时间内重新登录不需要扫码 (其实就是把二维码图片存下来，下次接着使用)</span></span><br><span class="line">itchat.auto_login (hotReload=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 开启命令行的二维码 </span></span><br><span class="line">itchat.auto_login (enableCmdQR=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 运行 </span></span><br><span class="line">itchat.run ()</span><br></pre></td></tr></table></figure><p>代码截图如下：<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzh40wm8uj215v0lp0ve.jpg" alt="代码示例" title="代码示例"></p><h2 id="演示"><a href="# 演示" class="headerlink" title="演示"></a>演示 </h2><p> 登录扫码 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzfzy6tf8j21bm0oq76m.jpg" alt="运行代码扫码" title="运行代码扫码"></p><p> 登录成功 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzg0nho9pj20cq01sjr6.jpg" alt="登录成功" title="登录成功"></p><p> 群聊自动回复（正则是任意内容，所以总是会自动回复）<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzg1f8g7nj20u00rp0wd.jpg" alt="群聊自动回复" title="群聊自动回复"></p><p>退出 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzg1qzmewj20n604omy3.jpg" alt="退出" title="退出"></p><p> 重新登录继续聊天（由于开启了热启动，不需要重新扫码）<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzg26yztyj20n6084gmn.jpg" alt="重新登录" title="重新登录"></p><p>继续聊天 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzg2p3tnuj20u01mc7co.jpg" alt="继续聊天" title="继续聊天"></p><h2 id="小问题总结"><a href="# 小问题总结" class="headerlink" title="小问题总结"></a> 小问题总结 </h2><p>1、部分系统可能字幅宽度有出入，可以通过将 enableCmdQR 赋值为特定的倍数进行调整：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如部分的 linux 系统，块字符的宽度为一个字符 (正常应为两字符), 故赋值为 2</span></span><br><span class="line">itchat.auto_login (enableCmdQR=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p></p><p>2、Python 2.7 版本的中文报错问题（在 Python 2.7 环境下使用中文需要额外注意，坑比较多）：<br> 例如代码中正则匹配带中文（由于编码问题导致无法匹配，或者会抛出异常）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正则搜索带中文，直接单引号在 Python 2.7 环境下是不行的 </span></span><br><span class="line">match = re.search (<span class="string">'年 | 春 | 快乐'</span>, message)</span><br></pre></td></tr></table></figure><p>实际运行时就会报错（报错信息如果不捕捉后台是看不到的）或者匹配结果不是想象中的（仅针对 Python 2.x 环境）</p><p>需要使用 u 前缀 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正则搜索带中文，直接单引号在 Python 2.7 环境下是不行的 </span></span><br><span class="line"><span class="comment"># 增加 u 前缀，表示 unicode 编码，才行 </span></span><br><span class="line">match = re.search (<span class="string">u'年 | 春 | 快乐'</span>, message)</span><br></pre></td></tr></table></figure><p>3、如果不开启热启动，每次重新登录时都会生成新的二维码，直接在 Wimdows 的命令行中，可能由于窗口太小显示不完整，此时需要拉伸一下命令行的窗口：</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzg62t07ej20n60sctbf.jpg" alt="窗口拉伸" title="窗口拉伸"></p><p>4、有些人的电脑设置问题，命令行环境背景为白色，生成的二维码的颜色黑白色是相反的，导致扫码时无法识别，此时需要设置代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认控制台背景色为暗色 (黑色)，若背景色为浅色 (白色)，可以将 enableCmdQR 赋值为负值 </span></span><br><span class="line">itchat.auto_login (enableCmdQR=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p></p><h2 id="接入机器人"><a href="# 接入机器人" class="headerlink" title="接入机器人"></a> 接入机器人 </h2><p> 一般读者做到上面的内容就算入门了，可以实现自动回复，并且关于 ItChat 也了解了一些，可以独自参考文档进行更加深入的开发了。但是，自动回复的内容毕竟太固定了，而且只能覆盖极少的内容，没办法实现真正的自动化。要想做到真正的自动化回复，机器人是少不了了，那么接下来讲解的就是如何接入一个第三方机器人，实现机器人自动回复。当然，代码内容也会稍显复杂，操作步骤也会稍显繁琐。</p><h3 id="接入机器人代码示例"><a href="# 接入机器人代码示例" class="headerlink" title="接入机器人代码示例"></a>接入机器人代码示例 </h3><p> 接入机器人时为了换种方式，先把群聊模式关闭，使用个人聊天监控模式（方便聊天内容的随意性，更能提现机器人的可用性）：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@itchat.msg_register ([TEXT])</span></span><br></pre></td></tr></table></figure><p></p><p>还要导入网络请求相关的包：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br></pre></td></tr></table></figure><p></p><p>需要使用图灵机器人的核心配置（注册图灵机器人的过程不在此赘述，官网链接：<a href="http://www.tuling123.com" target="_blank" rel="noopener">http://www.tuling123.com</a> ）：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 封装一个根据内容调用机器人接口，返回回复的方法 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="comment"># 构造了要发送给服务器的数据 </span></span><br><span class="line">    apiUrl = <span class="string">'http://www.tuling123.com/openapi/api'</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">'key'</span>    : APIKEY,</span><br><span class="line">        <span class="string">'info'</span>   : msg,</span><br><span class="line">        <span class="string">'userid'</span> : <span class="string">'wechat-robot'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.post (apiUrl, data=data).json ()</span><br><span class="line">        <span class="comment"># 字典的 get 方法在字典没有 'text' 值的时候会返回 None 而不会抛出异常 </span></span><br><span class="line">        <span class="keyword">return</span> r.get (<span class="string">'text'</span>)</span><br><span class="line">    <span class="comment"># 为了防止服务器没有正常响应导致程序异常退出，这里用 try-except 捕获了异常 </span></span><br><span class="line">    <span class="comment"># 如果服务器没能正常交互 (返回非 json 或无法连接), 那么就会进入下面的 return</span></span><br><span class="line">    <span class="keyword">except</span> Exception,err:</span><br><span class="line">        <span class="comment"># 打印一下错误信息 </span></span><br><span class="line">        print (err)</span><br><span class="line">        <span class="comment"># 将会返回一个 None</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p></p><p>完整代码示例（代码会封装的更好，格式更加规范，易读）：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 从 python 环境中导入 itchat 包，requests 网络请求包 </span></span><br><span class="line"><span class="keyword">import</span> itchat, requests</span><br><span class="line"><span class="comment"># 从 itchat.content 中导入所有类、常量 (例如代码中的 TEXT 其实就是 itchat.content.TEXT 常量)</span></span><br><span class="line"><span class="keyword">from</span> itchat.content <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 导入时间包里面的 sleep 方法 </span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="comment"># 导入随机数包 </span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 机器人的 apikey</span></span><br><span class="line">APIKEY = <span class="string">'376cb2ca51d542c6b2e660f3c9ea3754'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 封装一个根据内容调用机器人接口，返回回复的方法 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="comment"># 构造了要发送给服务器的数据 </span></span><br><span class="line">    apiUrl = <span class="string">'http://www.tuling123.com/openapi/api'</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">'key'</span>    : APIKEY,</span><br><span class="line">        <span class="string">'info'</span>   : msg,</span><br><span class="line">        <span class="string">'userid'</span> : <span class="string">'wechat-robot'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.post (apiUrl, data=data).json ()</span><br><span class="line">        <span class="comment"># 字典的 get 方法在字典没有 'text' 值的时候会返回 None 而不会抛出异常 </span></span><br><span class="line">        <span class="keyword">return</span> r.get (<span class="string">'text'</span>)</span><br><span class="line">    <span class="comment"># 为了防止服务器没有正常响应导致程序异常退出，这里用 try-except 捕获了异常 </span></span><br><span class="line">    <span class="comment"># 如果服务器没能正常交互 (返回非 json 或无法连接), 那么就会进入下面的 return</span></span><br><span class="line">    <span class="keyword">except</span> Exception,err:</span><br><span class="line">        <span class="comment"># 打印一下错误信息 </span></span><br><span class="line">        print (err)</span><br><span class="line">        <span class="comment"># 将会返回一个 None</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册消息类型为文本 (即只监控文本消息，其它的例如语音 / 图片 / 表情包 / 文件都不会监控)</span></span><br><span class="line"><span class="comment"># 也就是说只有普通的文字微信消息才能触发以下的代码 </span></span><br><span class="line"><span class="comment"># isGroupChat=True 开启群聊模式，即只是监控群聊内容 (如果不开启就监控个人聊天，不监控群聊)</span></span><br><span class="line"><span class="comment"># @itchat.msg_register ([TEXT], isGroupChat=True)</span></span><br><span class="line"><span class="meta">@itchat.msg_register ([TEXT])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tuling_reply</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="comment"># msg 是消息体，msg ['Text'] 用来获取消息内容 </span></span><br><span class="line">    <span class="comment"># 第一个单引号中的内容是关键词，使用正则匹配，可以自行更改 (我使用.* 表示任意内容), 如果使用中文注意 2.x 版本的 Python 会报错，需要 u 前缀 </span></span><br><span class="line">    message = msg [<span class="string">'Text'</span>]</span><br><span class="line">    print (message)</span><br><span class="line"><span class="comment"># 增加睡眠机制，随机等待一定的秒数 (1-10 秒) 再回复，更像人类 </span></span><br><span class="line">    second = random.randint (<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">    sleep (second)</span><br><span class="line">    <span class="comment"># 为了保证在图灵 apikey 出现问题的时候仍旧可以回复，这里设置一个默认回复 </span></span><br><span class="line">    defaultReply = <span class="string">'I received:'</span> + message</span><br><span class="line">    <span class="comment"># 如果图灵 apikey 出现问题，那么 reply 将会是 None</span></span><br><span class="line">    reply = get_response (message)</span><br><span class="line">    <span class="comment"># a or b 的意思是，如果 a 有内容，那么返回 a, 否则返回 b</span></span><br><span class="line">    <span class="keyword">return</span> reply <span class="keyword">or</span> defaultReply</span><br><span class="line"><span class="comment"># 热启动，退出一定时间内重新登录不需要扫码 (其实就是把二维码图片存下来，下次接着使用)</span></span><br><span class="line">itchat.auto_login (hotReload=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 开启命令行的二维码 </span></span><br><span class="line">itchat.auto_login (enableCmdQR=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 运行 </span></span><br><span class="line">itchat.run ()</span><br></pre></td></tr></table></figure><p></p><p>代码截图（使用工具渲染了一下）：<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzirq8uejj235s3xgu0x.jpg" alt="机器人接入代码" title="机器人接入代码"></p><h3 id="接入机器人演示"><a href="# 接入机器人演示" class="headerlink" title="接入机器人演示"></a>接入机器人演示 </h3><p> 演示一下，随便聊了几句：<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzzislea0dj20u01mcgug.jpg" alt="图灵机器人聊天" title="图灵机器人聊天"></p><h1 id="备注"><a href="# 备注" class="headerlink" title="备注"></a>备注 </h1><p>1、ItChat 项目 GitHub 地址：<a href="https://github.com/littlecodersh/itchat" target="_blank" rel="noopener">https://github.com/littlecodersh/itchat</a> ；</p><p>2、ItChat 项目说明文档：<a href="https://itchat.readthedocs.io/zh/latest" target="_blank" rel="noopener">https://itchat.readthedocs.io/zh/latest</a> ；</p><p>3、感谢微博科普博主 <a href="https://weibo.com/u/6969849160" target="_blank" rel="noopener"> 灵光灯泡 </a> 的科普视频 <a href="https://weibo.com/6969849160/HeLhjcKtA" target="_blank" rel="noopener">https://weibo.com/6969849160/HeLhjcKtA</a> 以及文档参考 <a href="https://shimo.im/docs/vCYHZ04LWTsugigR" target="_blank" rel="noopener"> 石墨文档</a> ；</p><p>4、Python 下载官网：<a href="https://www.python.org/downloads/windows" target="_blank" rel="noopener">https://www.python.org/downloads/windows</a> ，大家一定要选择与自己当前环境适配的版本（包括操作系统版本、Python 版本），环境变量最好配置一下；</p><p>5、图灵机器人官网：<a href="http://www.tuling123.com" target="_blank" rel="noopener">http://www.tuling123.com</a> ；</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;微信已经是我们日常生活中常用的 APP 之一，每天都离不开。作为掌握技术的理工科人员，有时候总想着是否可以利用微信的接口完成一些重复的工作，例如群发消息、自动回复、接入机器人自动聊天等。当然，这些都可以实现，而且只要是人工可以做到的事情，基本都可以做到自动化（前提是微信提供了对应的接口，反例就是自动收发红包不行，当然微信不会直接提供 API 接口，需要自己寻找）。本文就讲解为了做到这些，需要的入门知识点，主要就是利用 ItChat 工具（屏蔽了微信的 API 接口，简化了使用微信接口的过程，不懂技术的普通人也可以轻松掌握），当然本文只是一个入门的例子而已（完成后对自己来说很实用而且有成就感），后续会讲解更加深入与广泛的内容。本文基于 Windows 7 操作系统，Python 2.7 版本（为了兼容性与易维护性，我推荐使用 Python 3.x 版本）&lt;/p&gt;
    
    </summary>
    
      <category term="ItChat 系列" scheme="https://www.playpi.org/categories/series-of-itchat/"/>
    
    
      <category term="ItChat" scheme="https://www.playpi.org/tags/ItChat/"/>
    
      <category term="微信接口" scheme="https://www.playpi.org/tags/%E5%BE%AE%E4%BF%A1%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="自定义接口" scheme="https://www.playpi.org/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="自动回复" scheme="https://www.playpi.org/tags/%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D/"/>
    
      <category term="微信机器人" scheme="https://www.playpi.org/tags/%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>Spark 异常之 Netty 相关</title>
    <link href="https://www.playpi.org/2019011401.html"/>
    <id>https://www.playpi.org/2019011401.html</id>
    <published>2019-01-13T17:27:53.000Z</published>
    <updated>2019-01-13T17:27:53.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>在做项目的时候，需要新引入一个外部依赖，于是很自然地在项目的 pom.xml 文件中加入了依赖坐标，然后进行编译、打包、运行，没想到直接抛出了异常：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">13_17</span>:<span class="number">18</span>:<span class="number">52</span> [sparkDriverActorSystem-akka.actor.<span class="keyword">default</span>-dispatcher-<span class="number">5</span>] ERROR actor.ActorSystemImpl:<span class="number">66</span>: Uncaught fatal error from thread [sparkDriverActorSystem-akka.remote.<span class="keyword">default</span>-remote-dispatcher-<span class="number">7</span>] shutting down ActorSystem [sparkDriverActorSystem]</span><br><span class="line">java.lang.VerifyError: (class: org/jboss/netty/channel/socket/nio/NioWorkerPool, method: createWorker signature: (Ljava/util/concurrent/Executor;) Lorg/jboss/netty/channel/socket/nio/AbstractNioWorker;) Wrong return type in function</span><br></pre></td></tr></table></figure><p>任务运行失败，仔细看日志觉得很莫名奇妙，是一个 java.lang.VerifyError 错误，以前从来没见过类似的。本文记录这个错误的解决过程。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 在上述错误抛出之后，可以看到 SparkContext 初始化失败，然后进程就终止了；</p><p>完整日志如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">13_17</span>:<span class="number">18</span>:<span class="number">52</span> [sparkDriverActorSystem-akka.actor.<span class="keyword">default</span>-dispatcher-<span class="number">5</span>] ERROR actor.ActorSystemImpl:<span class="number">66</span>: Uncaught fatal error from thread [sparkDriverActorSystem-akka.remote.<span class="keyword">default</span>-remote-dispatcher-<span class="number">7</span>] shutting down ActorSystem [sparkDriverActorSystem]</span><br><span class="line">java.lang.VerifyError: (class: org/jboss/netty/channel/socket/nio/NioWorkerPool, method: createWorker signature: (Ljava/util/concurrent/Executor;) Lorg/jboss/netty/channel/socket/nio/AbstractNioWorker;) Wrong return type in function</span><br><span class="line">at akka.remote.transport.netty.NettyTransport.(NettyTransport.scala:<span class="number">283</span>)</span><br><span class="line">at akka.remote.transport.netty.NettyTransport.(NettyTransport.scala:<span class="number">240</span>)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0 (Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance (NativeConstructorAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance (DelegatingConstructorAccessorImpl.java:<span class="number">45</span>)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance (Constructor.java:<span class="number">423</span>)</span><br><span class="line">at akka.actor.ReflectiveDynamicAccess$$anonfun$createInstanceFor$<span class="number">2</span>.apply (DynamicAccess.scala:<span class="number">78</span>)</span><br><span class="line">at scala.util.Try$.apply (Try.scala:<span class="number">161</span>)</span><br><span class="line">at akka.actor.ReflectiveDynamicAccess.createInstanceFor (DynamicAccess.scala:<span class="number">73</span>)</span><br><span class="line">at akka.actor.ReflectiveDynamicAccess$$anonfun$createInstanceFor$<span class="number">3</span>.apply (DynamicAccess.scala:<span class="number">84</span>)</span><br><span class="line">at akka.actor.ReflectiveDynamicAccess$$anonfun$createInstanceFor$<span class="number">3</span>.apply (DynamicAccess.scala:<span class="number">84</span>)</span><br><span class="line">at scala.util.Success.flatMap (Try.scala:<span class="number">200</span>)</span><br><span class="line">at akka.actor.ReflectiveDynamicAccess.createInstanceFor (DynamicAccess.scala:<span class="number">84</span>)</span><br><span class="line">at akka.remote.EndpointManager$$anonfun$<span class="number">9</span>.apply (Remoting.scala:<span class="number">711</span>)</span><br><span class="line">at akka.remote.EndpointManager$$anonfun$<span class="number">9</span>.apply (Remoting.scala:<span class="number">703</span>)</span><br><span class="line">at scala.collection.TraversableLike$WithFilter$$anonfun$map$<span class="number">2</span>.apply (TraversableLike.scala:<span class="number">722</span>)</span><br><span class="line">at scala.collection.Iterator$class.foreach (Iterator.scala:727)</span><br><span class="line">at scala.collection.AbstractIterator.foreach (Iterator.scala:<span class="number">1157</span>)</span><br><span class="line">at scala.collection.IterableLike$class.foreach (IterableLike.scala:72)</span><br><span class="line">at scala.collection.AbstractIterable.foreach (Iterable.scala:<span class="number">54</span>)</span><br><span class="line">at scala.collection.TraversableLike$WithFilter.map (TraversableLike.scala:<span class="number">721</span>)</span><br><span class="line">at akka.remote.EndpointManager.akka$remote$EndpointManager$$listens (Remoting.scala:<span class="number">703</span>)</span><br><span class="line">at akka.remote.EndpointManager$$anonfun$receive$<span class="number">2</span>.applyOrElse (Remoting.scala:<span class="number">491</span>)</span><br><span class="line">at akka.actor.Actor$class.aroundReceive (Actor.scala:467)</span><br><span class="line">at akka.remote.EndpointManager.aroundReceive (Remoting.scala:<span class="number">394</span>)</span><br><span class="line">at akka.actor.ActorCell.receiveMessage (ActorCell.scala:<span class="number">516</span>)</span><br><span class="line">at akka.actor.ActorCell.invoke (ActorCell.scala:<span class="number">487</span>)</span><br><span class="line">at akka.dispatch.Mailbox.processMailbox (Mailbox.scala:<span class="number">238</span>)</span><br><span class="line">at akka.dispatch.Mailbox.run (Mailbox.scala:<span class="number">220</span>)</span><br><span class="line">at akka.dispatch.ForkJoinExecutorConfigurator$AkkaForkJoinTask.exec (AbstractDispatcher.scala:<span class="number">397</span>)</span><br><span class="line">at scala.concurrent.forkjoin.ForkJoinTask.doExec (ForkJoinTask.java:<span class="number">260</span>)</span><br><span class="line">at scala.concurrent.forkjoin.ForkJoinPool$WorkQueue.runTask (ForkJoinPool.java:<span class="number">1339</span>)</span><br><span class="line">at scala.concurrent.forkjoin.ForkJoinPool.runWorker (ForkJoinPool.java:<span class="number">1979</span>)</span><br><span class="line">at scala.concurrent.forkjoin.ForkJoinWorkerThread.run (ForkJoinWorkerThread.java:<span class="number">107</span>)</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">13_17</span>:<span class="number">18</span>:<span class="number">52</span> [sparkDriverActorSystem-akka.actor.<span class="keyword">default</span>-dispatcher-<span class="number">6</span>] INFO remote.RemoteActorRefProvider$RemotingTerminator:<span class="number">74</span>: Shutting down remote daemon.</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">13_17</span>:<span class="number">18</span>:<span class="number">52</span> [sparkDriverActorSystem-akka.actor.<span class="keyword">default</span>-dispatcher-<span class="number">6</span>] INFO remote.RemoteActorRefProvider$RemotingTerminator:<span class="number">74</span>: Remote daemon shut down; proceeding with flushing remote transports.</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">13_17</span>:<span class="number">18</span>:<span class="number">52</span> [sparkDriverActorSystem-akka.actor.<span class="keyword">default</span>-dispatcher-<span class="number">6</span>] ERROR Remoting:<span class="number">65</span>: Remoting system has been terminated abrubtly. Attempting to shut down transports</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">13_17</span>:<span class="number">18</span>:<span class="number">52</span> [sparkDriverActorSystem-akka.actor.<span class="keyword">default</span>-dispatcher-<span class="number">6</span>] INFO remote.RemoteActorRefProvider$RemotingTerminator:<span class="number">74</span>: Remoting shut down.</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">13_17</span>:<span class="number">19</span>:<span class="number">02</span> [main] ERROR spark.SparkContext:<span class="number">95</span>: Error initializing SparkContext.</span><br><span class="line">java.util.concurrent.TimeoutException: Futures timed out after [<span class="number">10000</span> milliseconds]</span><br><span class="line">at scala.concurrent.impl.Promise$DefaultPromise.ready (Promise.scala:<span class="number">219</span>)</span><br><span class="line">at scala.concurrent.impl.Promise$DefaultPromise.result (Promise.scala:<span class="number">223</span>)</span><br><span class="line">at scala.concurrent.Await$$anonfun$result$<span class="number">1</span>.apply (<span class="keyword">package</span>.scala:<span class="number">107</span>)</span><br><span class="line">at scala.concurrent.BlockContext$DefaultBlockContext$.blockOn (BlockContext.scala:<span class="number">53</span>)</span><br><span class="line">at scala.concurrent.Await$.result (<span class="keyword">package</span>.scala:<span class="number">107</span>)</span><br><span class="line">at akka.remote.Remoting.start (Remoting.scala:<span class="number">179</span>)</span><br><span class="line">at akka.remote.RemoteActorRefProvider.init (RemoteActorRefProvider.scala:<span class="number">184</span>)</span><br><span class="line">at akka.actor.ActorSystemImpl.liftedTree2$<span class="number">1</span>(ActorSystem.scala:<span class="number">620</span>)</span><br><span class="line">at akka.actor.ActorSystemImpl._start$lzycompute (ActorSystem.scala:<span class="number">617</span>)</span><br><span class="line">at akka.actor.ActorSystemImpl._start (ActorSystem.scala:<span class="number">617</span>)</span><br><span class="line">at akka.actor.ActorSystemImpl.start (ActorSystem.scala:<span class="number">634</span>)</span><br><span class="line">at akka.actor.ActorSystem$.apply (ActorSystem.scala:<span class="number">142</span>)</span><br><span class="line">at akka.actor.ActorSystem$.apply (ActorSystem.scala:<span class="number">119</span>)</span><br><span class="line">at org.apache.spark.util.AkkaUtils$.org$apache$spark$util$AkkaUtils$$doCreateActorSystem (AkkaUtils.scala:<span class="number">121</span>)</span><br><span class="line">at org.apache.spark.util.AkkaUtils$$anonfun$<span class="number">1</span>.apply (AkkaUtils.scala:<span class="number">53</span>)</span><br><span class="line">at org.apache.spark.util.AkkaUtils$$anonfun$<span class="number">1</span>.apply (AkkaUtils.scala:<span class="number">52</span>)</span><br><span class="line">at org.apache.spark.util.Utils$$anonfun$startServiceOnPort$<span class="number">1</span>.apply$mcVI$sp (Utils.scala:<span class="number">2024</span>)</span><br><span class="line">at scala.collection.immutable.Range.foreach$mVc$sp (Range.scala:<span class="number">141</span>)</span><br><span class="line">at org.apache.spark.util.Utils$.startServiceOnPort (Utils.scala:<span class="number">2015</span>)</span><br><span class="line">at org.apache.spark.util.AkkaUtils$.createActorSystem (AkkaUtils.scala:<span class="number">55</span>)</span><br><span class="line">at org.apache.spark.SparkEnv$.create (SparkEnv.scala:<span class="number">266</span>)</span><br><span class="line">at org.apache.spark.SparkEnv$.createDriverEnv (SparkEnv.scala:<span class="number">193</span>)</span><br><span class="line">at org.apache.spark.SparkContext.createSparkEnv (SparkContext.scala:<span class="number">288</span>)</span><br><span class="line">at org.apache.spark.SparkContext.(SparkContext.scala:<span class="number">457</span>)</span><br><span class="line">at org.apache.spark.api.java.JavaSparkContext.(JavaSparkContext.scala:<span class="number">59</span>)</span><br><span class="line">at com.ds.octopus.job.utils.SparkContextUtil.refresh (SparkContextUtil.java:<span class="number">77</span>)</span><br><span class="line">at com.ds.octopus.job.utils.SparkContextUtil.getJsc (SparkContextUtil.java:<span class="number">34</span>)</span><br><span class="line">at com.ds.octopus.job.executors.impl.WeiboZPZExporter.action (WeiboZPZExporter.java:<span class="number">95</span>)</span><br><span class="line">at com.ds.octopus.job.executors.impl.WeiboZPZExporter.action (WeiboZPZExporter.java:<span class="number">41</span>)</span><br><span class="line">at com.ds.octopus.job.executors.SimpleExecutor.execute (SimpleExecutor.java:<span class="number">40</span>)</span><br><span class="line">at com.ds.octopus.job.client.OctopusClient.run (OctopusClient.java:<span class="number">162</span>)</span><br><span class="line">at com.yeezhao.commons.buffalo.job.AbstractBUTaskWorker.runTask (AbstractBUTaskWorker.java:<span class="number">63</span>)</span><br><span class="line">at com.ds.octopus.job.client.TaskLocalRunnerCli.start (TaskLocalRunnerCli.java:<span class="number">109</span>)</span><br><span class="line">at com.yeezhao.commons.util.AdvCli.initRunner (AdvCli.java:<span class="number">191</span>)</span><br><span class="line">at com.ds.octopus.job.client.TaskLocalRunnerCli.main (TaskLocalRunnerCli.java:<span class="number">41</span>)</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">13_17</span>:<span class="number">19</span>:<span class="number">02</span> [main] INFO spark.SparkContext:<span class="number">58</span>: Successfully stopped SparkContext</span><br></pre></td></tr></table></figure><p></p><p>错误日志截图：<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz5j8uvmnrj219y0kqdil.jpg" alt="错误日志局部" title="错误日志局部"></p><p>根据日志没有看出有关 Java 层面的什么问题，只能根据 JNI 字段描述符：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class: org/jboss/netty/channel/socket/nio/NioWorkerPool</span><br></pre></td></tr></table></figure><p></p><p>猜测是某一个类的问题，根据：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method: createWorker signature: (Ljava/util/concurrent/Executor;) Lorg/jboss/netty/channel/socket/nio/AbstractNioWorker;) Wrong <span class="keyword">return</span> type in function</span><br></pre></td></tr></table></figure><p></p><p>猜测是某个方法的问题，方法的返回类型错误。</p><p>然后在项目中使用 ctrl+shift+t 快捷键（全局搜索 Java 类，每个人的开发工具设置的可能不一样）搜索类：NioWorkerPool，发现这个类的来源不是新引入的依赖包，而是原本就有的 netty 相关包，所以此时就可以断定这个莫名其妙的错误的原因就在于这个类的 createWorker 方法返回类型上面了。</p><p>搜索类 NioWorkerPool<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz5j9dcym1j216q0aztai.jpg" alt="搜索 NioWorkerPool" title="搜索 NioWorkerPool"></p><p>日志的 JNI 字段描述符显示返回类型是 AbstractNioWorker，但是这个一看就是抽象类，不是我们要找的，去类里面看源码，发现 createWorker 方法返回类型是 NioWorker：</p><p>类 NioWorkerPool 源码 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz5j9wfx1mj20wu0et3z8.jpg" alt="NioWorkerPool 源码" title="NioWorkerPool 源码"></p><p> 继续搜索类 NioWorker<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz5jagdz1qj216t09wwg0.jpg" alt="搜索 NioWorker" title="搜索 NioWorker"></p><p>好，此时发现问题了，这个类有 2 个，居然存在两个相同的包名，但是依赖坐标不一样，所以这个隐藏的原因在于类冲突，但是并不能算是依赖冲突引起的。也就是说，NioWorker 这个类重复了，但是依赖包坐标不一样，类的包路径却是一模一样的，不会引起版本冲突问题，而在实际运行任务的时候会抛出运行时异常，所以我觉得找问题的过程很艰辛。</p><p>使用依赖树查看依赖关系，是看不到版本冲突问题的，2 个依赖都存在：<br>io.netty 依赖 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz5jaxljmvj20mb05fglv.jpg" alt="io.netty 依赖" title="io.netty 依赖"></p><p>org.jboss.netty 依赖<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz5jb7z4o0j20la031t8r.jpg" alt="org.jboss.netty 依赖" title="org.jboss.netty 依赖"></p><p> 于是又在网上搜索了一下，发现果然是 netty 的问题，也就是新引入的依赖包导致的，但是根本原因令人哭笑：netty 的组织结构变化，发布的依赖坐标名称变化，但是所有的类的包名称并没有变化，导致了这个错误。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><p> 问题找到了，解决方法就简单了，移除传递依赖即可，同时也要注意以后再添加新的依赖一定要慎重，不然找问题的过程很是令人崩溃。</p><p>移除依赖 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz5jbj046wj20g907amxa.jpg" alt="移除依赖" title="移除依赖"></p><p> 移除配置示例 <br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 移除引发冲突的 jar 包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a> 问题总结</h1><p>1、参考：<a href="https://stackoverflow.com/questions/33573587/apache-spark-wrong-akka-remote-netty-version" target="_blank" rel="noopener">https://stackoverflow.com/questions/33573587/apache-spark-wrong-akka-remote-netty-version</a> ；</p><p>2、netty 的组织结构（影响发布的 jar 包坐标名称）变化了，但是所有的类的包名称仍然是一致的，很奇怪，导致我找问题也觉得莫名其妙，因为这不会引发版本冲突问题（但是本质上又是 2 个一模一样的类被同时使用，引发类冲突）；</p><p>3、这个错误信息挺有意思的，解决过程也很好玩，边找边学习；</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在做项目的时候，需要新引入一个外部依赖，于是很自然地在项目的 pom.xml 文件中加入了依赖坐标，然后进行编译、打包、运行，没想到直接抛出了异常：&lt;/p&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2019&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;01&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;13_17&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;52&lt;/span&gt; [sparkDriverActorSystem-akka.actor.&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;-dispatcher-&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] ERROR actor.ActorSystemImpl:&lt;span class=&quot;number&quot;&gt;66&lt;/span&gt;: Uncaught fatal error from thread [sparkDriverActorSystem-akka.remote.&lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;-remote-dispatcher-&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;] shutting down ActorSystem [sparkDriverActorSystem]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;java.lang.VerifyError: (class: org/jboss/netty/channel/socket/nio/NioWorkerPool, method: createWorker signature: (Ljava/util/concurrent/Executor;) Lorg/jboss/netty/channel/socket/nio/AbstractNioWorker;) Wrong return type in function&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;任务运行失败，仔细看日志觉得很莫名奇妙，是一个 java.lang.VerifyError 错误，以前从来没见过类似的。本文记录这个错误的解决过程。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="netty" scheme="https://www.playpi.org/tags/netty/"/>
    
      <category term="nio" scheme="https://www.playpi.org/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>Maven 插件异常之 socket write error</title>
    <link href="https://www.playpi.org/2019011101.html"/>
    <id>https://www.playpi.org/2019011101.html</id>
    <published>2019-01-11T14:09:10.000Z</published>
    <updated>2019-01-12T14:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>今天在整理代码的时候，在本机（自己的电脑）通过 Maven 的 deploy 插件（org.apache.maven.plugins:maven-deploy-plugin:2.7）进行发布，把代码打包成构件发布到远程的 Maven 仓库（公司的私服），这样方便大家调用。可是，其中有一个项目发布不了（其它类似的 2 个项目都可以，排除了环境的原因），总是报错：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to deploy artifacts: Could not transfer artifact xxx.yyy.zzz:dt-x-y-z:jar:<span class="number">0.0</span>.6-<span class="number">20190112.081518</span>-<span class="number">1</span> from/<span class="function">to <span class="title">snapshots</span> <span class="params">(http://maven.myself.com/nexus/content/repositories/snapshots)</span>: Connection reset by peer: socket write error</span></span><br></pre></td></tr></table></figure><p></p><p>以上错误日志中的项目名称、包名称均被替换。本文就记录从发现问题到解决问题的过程。环境所使用的 Maven 版本为：3.5.0。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 对一个公共项目进行打包发布，部署到公司私服（已经排除环境因素），出现异常；</p><p>使用命令 Maven：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure><p></p><p>出现异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD FAILURE</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: <span class="number">02</span>:<span class="number">49</span> min</span><br><span class="line">[INFO] Finished at: <span class="number">2019</span>-<span class="number">01</span>-<span class="number">12</span>T16:<span class="number">17</span>:<span class="number">21</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[INFO] Final Memory: <span class="number">68</span>M/<span class="number">1253</span>M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-deploy-plugin:<span class="number">2.7</span>:deploy (<span class="keyword">default</span>-deploy) on project dt-x-y-z: Failed to deploy artifacts: Could not transfer artifact xxx.yyy.zzz:dt-x-y-z:jar:<span class="number">0.0</span>.6-<span class="number">20190112.081518</span>-<span class="number">1</span> from/<span class="function">to <span class="title">snapshots</span> <span class="params">(http://maven.myself.com/nexus/content/repositories/snapshots)</span>: Connection reset by peer: socket write error -&gt; [Help 1]</span></span><br><span class="line"><span class="function">[ERROR]</span></span><br><span class="line"><span class="function">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e <span class="keyword">switch</span>.</span></span><br><span class="line"><span class="function">[ERROR] Re-run Maven using the -X <span class="keyword">switch</span> to enable full debug logging.</span></span><br><span class="line"><span class="function">[ERROR]</span></span><br><span class="line"><span class="function">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span></span><br><span class="line"><span class="function">[ERROR] [Help 1] http:<span class="comment">//cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException</span></span></span><br></pre></td></tr></table></figure><p>如果使用 -X 参数（完整命令：mvn deploy -X），可以稍微看到更详细的 Maven 部署日志信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD FAILURE</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: <span class="number">02</span>:<span class="number">49</span> min</span><br><span class="line">[INFO] Finished at: <span class="number">2019</span>-<span class="number">01</span>-<span class="number">12</span>T16:<span class="number">17</span>:<span class="number">21</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line">[INFO] Final Memory: <span class="number">68</span>M/<span class="number">1253</span>M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-deploy-plugin:<span class="number">2.7</span>:deploy (<span class="keyword">default</span>-deploy) on project dt-x-y-z: Failed to deploy artifacts: Could not transfer artifact xxx.yyy.zzz:dt-x-y-z:jar:<span class="number">0.0</span>.6-<span class="number">20190112.081518</span>-<span class="number">1</span> from/<span class="function">to <span class="title">snapshots</span> <span class="params">(http://maven.myself.com/nexus/content/repositories/snapshots)</span>: Connection reset by peer: socket write error -&gt; [Help 1]</span></span><br><span class="line"><span class="function">org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-deploy-plugin:2.7:<span class="title">deploy</span> <span class="params">(<span class="keyword">default</span>-deploy)</span> on project dt-x-y-z: Failed to deploy artifacts: Could not transfer artifact xxx.yyy.zzz:dt-x-y-z:jar:0.0.6-20190112.081518-1 from/to <span class="title">snapshots</span> <span class="params">(http://maven.myself.com/nexus/content/repositories/snapshots)</span>: Connection reset by peer: socket write error</span></span><br><span class="line"><span class="function">        at org.apache.maven.lifecycle.internal.MojoExecutor.<span class="title">execute</span><span class="params">(MojoExecutor.java:<span class="number">213</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.lifecycle.internal.MojoExecutor.<span class="title">execute</span><span class="params">(MojoExecutor.java:<span class="number">154</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.lifecycle.internal.MojoExecutor.<span class="title">execute</span><span class="params">(MojoExecutor.java:<span class="number">146</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.<span class="title">buildProject</span><span class="params">(LifecycleModuleBuilder.java:<span class="number">117</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.<span class="title">buildProject</span><span class="params">(LifecycleModuleBuilder.java:<span class="number">81</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.<span class="title">build</span><span class="params">(SingleThreadedBuilder.java:<span class="number">51</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.lifecycle.internal.LifecycleStarter.<span class="title">execute</span><span class="params">(LifecycleStarter.java:<span class="number">128</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.DefaultMaven.<span class="title">doExecute</span><span class="params">(DefaultMaven.java:<span class="number">309</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.DefaultMaven.<span class="title">doExecute</span><span class="params">(DefaultMaven.java:<span class="number">194</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.DefaultMaven.<span class="title">execute</span><span class="params">(DefaultMaven.java:<span class="number">107</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.cli.MavenCli.<span class="title">execute</span><span class="params">(MavenCli.java:<span class="number">993</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.cli.MavenCli.<span class="title">doMain</span><span class="params">(MavenCli.java:<span class="number">345</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.cli.MavenCli.<span class="title">main</span><span class="params">(MavenCli.java:<span class="number">191</span>)</span></span></span><br><span class="line"><span class="function">        at sun.reflect.NativeMethodAccessorImpl.<span class="title">invoke0</span><span class="params">(Native Method)</span></span></span><br><span class="line"><span class="function">        at sun.reflect.NativeMethodAccessorImpl.<span class="title">invoke</span><span class="params">(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span></span></span><br><span class="line"><span class="function">        at sun.reflect.DelegatingMethodAccessorImpl.<span class="title">invoke</span><span class="params">(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span></span></span><br><span class="line"><span class="function">        at java.lang.reflect.Method.<span class="title">invoke</span><span class="params">(Method.java:<span class="number">498</span>)</span></span></span><br><span class="line"><span class="function">        at org.codehaus.plexus.classworlds.launcher.Launcher.<span class="title">launchEnhanced</span><span class="params">(Launcher.java:<span class="number">289</span>)</span></span></span><br><span class="line"><span class="function">        at org.codehaus.plexus.classworlds.launcher.Launcher.<span class="title">launch</span><span class="params">(Launcher.java:<span class="number">229</span>)</span></span></span><br><span class="line"><span class="function">        at org.codehaus.plexus.classworlds.launcher.Launcher.<span class="title">mainWithExitCode</span><span class="params">(Launcher.java:<span class="number">415</span>)</span></span></span><br><span class="line"><span class="function">        at org.codehaus.plexus.classworlds.launcher.Launcher.<span class="title">main</span><span class="params">(Launcher.java:<span class="number">356</span>)</span></span></span><br><span class="line"><span class="function">Caused by: org.apache.maven.plugin.MojoExecutionException: Failed to deploy artifacts: Could not transfer artifact xxx.yyy.zzz:dt-x-y-z:jar:0.0.6-20190112.081518-1 from/to <span class="title">snapshots</span> <span class="params">(http://maven.myself.com/nexus/content/repositories/snapshots)</span>: Connection reset by peer: socket write error</span></span><br><span class="line"><span class="function">        at org.apache.maven.plugin.deploy.DeployMojo.<span class="title">execute</span><span class="params">(DeployMojo.java:<span class="number">193</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.plugin.DefaultBuildPluginManager.<span class="title">executeMojo</span><span class="params">(DefaultBuildPluginManager.java:<span class="number">134</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.lifecycle.internal.MojoExecutor.<span class="title">execute</span><span class="params">(MojoExecutor.java:<span class="number">208</span>)</span></span></span><br><span class="line"><span class="function">        ... 20 more</span></span><br><span class="line"><span class="function">Caused by: org.apache.maven.artifact.deployer.ArtifactDeploymentException: Failed to deploy artifacts: Could not transfer artifact xxx.yyy.zzz:dt-x-y-z:jar:0.0.6-20190112.081518-1 from/to <span class="title">snapshots</span> <span class="params">(http://maven.myself.com/nexus/content/repositories/snapshots)</span>: Connection reset by peer: socket write error</span></span><br><span class="line"><span class="function">        at org.apache.maven.artifact.deployer.DefaultArtifactDeployer.<span class="title">deploy</span><span class="params">(DefaultArtifactDeployer.java:<span class="number">143</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.plugin.deploy.AbstractDeployMojo.<span class="title">deploy</span><span class="params">(AbstractDeployMojo.java:<span class="number">167</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.plugin.deploy.DeployMojo.<span class="title">execute</span><span class="params">(DeployMojo.java:<span class="number">157</span>)</span></span></span><br><span class="line"><span class="function">        ... 22 more</span></span><br><span class="line"><span class="function">Caused by: org.eclipse.aether.deployment.DeploymentException: Failed to deploy artifacts: Could not transfer artifact xxx.yyy.zzz:dt-x-y-z:jar:0.0.6-20190112.081518-1 from/to <span class="title">snapshots</span> <span class="params">(http://maven.myself.com/nexus/content/repositories/snapshots)</span>: Connection reset by peer: socket write error</span></span><br><span class="line"><span class="function">        at org.eclipse.aether.internal.impl.DefaultDeployer.<span class="title">deploy</span><span class="params">(DefaultDeployer.java:<span class="number">326</span>)</span></span></span><br><span class="line"><span class="function">        at org.eclipse.aether.internal.impl.DefaultDeployer.<span class="title">deploy</span><span class="params">(DefaultDeployer.java:<span class="number">254</span>)</span></span></span><br><span class="line"><span class="function">        at org.eclipse.aether.internal.impl.DefaultRepositorySystem.<span class="title">deploy</span><span class="params">(DefaultRepositorySystem.java:<span class="number">422</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.artifact.deployer.DefaultArtifactDeployer.<span class="title">deploy</span><span class="params">(DefaultArtifactDeployer.java:<span class="number">139</span>)</span></span></span><br><span class="line"><span class="function">        ... 24 more</span></span><br><span class="line"><span class="function">Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Could not transfer artifact xxx.yyy.zzz:dt-x-y-z:jar:0.0.6-20190112.081518-1 from/to <span class="title">snapshots</span> <span class="params">(http://maven.myself.com/nexus/content/repositories/snapshots)</span>: Connection reset by peer: socket write error</span></span><br><span class="line"><span class="function">        at org.eclipse.aether.connector.basic.ArtifactTransportListener.<span class="title">transferFailed</span><span class="params">(ArtifactTransportListener.java:<span class="number">52</span>)</span></span></span><br><span class="line"><span class="function">        at org.eclipse.aether.connector.basic.BasicRepositoryConnector$TaskRunner.<span class="title">run</span><span class="params">(BasicRepositoryConnector.java:<span class="number">364</span>)</span></span></span><br><span class="line"><span class="function">        at org.eclipse.aether.connector.basic.BasicRepositoryConnector.<span class="title">put</span><span class="params">(BasicRepositoryConnector.java:<span class="number">283</span>)</span></span></span><br><span class="line"><span class="function">        at org.eclipse.aether.internal.impl.DefaultDeployer.<span class="title">deploy</span><span class="params">(DefaultDeployer.java:<span class="number">320</span>)</span></span></span><br><span class="line"><span class="function">        ... 27 more</span></span><br><span class="line"><span class="function">Caused by: org.apache.maven.wagon.TransferFailedException: Connection reset by peer: socket write error</span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.AbstractHttpClientWagon.<span class="title">put</span><span class="params">(AbstractHttpClientWagon.java:<span class="number">650</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.AbstractHttpClientWagon.<span class="title">put</span><span class="params">(AbstractHttpClientWagon.java:<span class="number">553</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.AbstractHttpClientWagon.<span class="title">put</span><span class="params">(AbstractHttpClientWagon.java:<span class="number">535</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.AbstractHttpClientWagon.<span class="title">put</span><span class="params">(AbstractHttpClientWagon.java:<span class="number">529</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.AbstractHttpClientWagon.<span class="title">put</span><span class="params">(AbstractHttpClientWagon.java:<span class="number">509</span>)</span></span></span><br><span class="line"><span class="function">        at org.eclipse.aether.transport.wagon.WagonTransporter$PutTaskRunner.<span class="title">run</span><span class="params">(WagonTransporter.java:<span class="number">653</span>)</span></span></span><br><span class="line"><span class="function">        at org.eclipse.aether.transport.wagon.WagonTransporter.<span class="title">execute</span><span class="params">(WagonTransporter.java:<span class="number">436</span>)</span></span></span><br><span class="line"><span class="function">        at org.eclipse.aether.transport.wagon.WagonTransporter.<span class="title">put</span><span class="params">(WagonTransporter.java:<span class="number">419</span>)</span></span></span><br><span class="line"><span class="function">        at org.eclipse.aether.connector.basic.BasicRepositoryConnector$PutTaskRunner.<span class="title">runTask</span><span class="params">(BasicRepositoryConnector.java:<span class="number">519</span>)</span></span></span><br><span class="line"><span class="function">        at org.eclipse.aether.connector.basic.BasicRepositoryConnector$TaskRunner.<span class="title">run</span><span class="params">(BasicRepositoryConnector.java:<span class="number">359</span>)</span></span></span><br><span class="line"><span class="function">        ... 29 more</span></span><br><span class="line"><span class="function">Caused by: java.net.SocketException: Connection reset by peer: socket write error</span></span><br><span class="line"><span class="function">        at java.net.SocketOutputStream.<span class="title">socketWrite0</span><span class="params">(Native Method)</span></span></span><br><span class="line"><span class="function">        at java.net.SocketOutputStream.<span class="title">socketWrite</span><span class="params">(SocketOutputStream.java:<span class="number">111</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.SocketOutputStream.<span class="title">write</span><span class="params">(SocketOutputStream.java:<span class="number">155</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.impl.io.SessionOutputBufferImpl.<span class="title">streamWrite</span><span class="params">(SessionOutputBufferImpl.java:<span class="number">126</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.impl.io.SessionOutputBufferImpl.<span class="title">flushBuffer</span><span class="params">(SessionOutputBufferImpl.java:<span class="number">138</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.impl.io.SessionOutputBufferImpl.<span class="title">write</span><span class="params">(SessionOutputBufferImpl.java:<span class="number">169</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.impl.io.ContentLengthOutputStream.<span class="title">write</span><span class="params">(ContentLengthOutputStream.java:<span class="number">115</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.AbstractHttpClientWagon$RequestEntityImplementation.<span class="title">writeTo</span><span class="params">(AbstractHttpClientWagon.java:<span class="number">209</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.impl.DefaultBHttpClientConnection.<span class="title">sendRequestEntity</span><span class="params">(DefaultBHttpClientConnection.java:<span class="number">158</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.impl.conn.CPoolProxy.<span class="title">sendRequestEntity</span><span class="params">(CPoolProxy.java:<span class="number">162</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.protocol.HttpRequestExecutor.<span class="title">doSendRequest</span><span class="params">(HttpRequestExecutor.java:<span class="number">237</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.protocol.HttpRequestExecutor.<span class="title">execute</span><span class="params">(HttpRequestExecutor.java:<span class="number">122</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.impl.execchain.MainClientExec.<span class="title">execute</span><span class="params">(MainClientExec.java:<span class="number">271</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.impl.execchain.ProtocolExec.<span class="title">execute</span><span class="params">(ProtocolExec.java:<span class="number">184</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.impl.execchain.RetryExec.<span class="title">execute</span><span class="params">(RetryExec.java:<span class="number">88</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.impl.execchain.RedirectExec.<span class="title">execute</span><span class="params">(RedirectExec.java:<span class="number">110</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.impl.client.InternalHttpClient.<span class="title">doExecute</span><span class="params">(InternalHttpClient.java:<span class="number">184</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.httpclient.impl.client.CloseableHttpClient.<span class="title">execute</span><span class="params">(CloseableHttpClient.java:<span class="number">82</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.AbstractHttpClientWagon.<span class="title">execute</span><span class="params">(AbstractHttpClientWagon.java:<span class="number">834</span>)</span></span></span><br><span class="line"><span class="function">        at org.apache.maven.wagon.providers.http.AbstractHttpClientWagon.<span class="title">put</span><span class="params">(AbstractHttpClientWagon.java:<span class="number">596</span>)</span></span></span><br><span class="line"><span class="function">        ... 38 more</span></span><br><span class="line"><span class="function">[ERROR]</span></span><br><span class="line"><span class="function">[ERROR]</span></span><br><span class="line"><span class="function">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span></span><br><span class="line"><span class="function">[ERROR] [Help 1] http:<span class="comment">//cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException</span></span></span><br></pre></td></tr></table></figure><p>由于对 Maven 构件的原理不清楚，通过日志报错也看不出根本原因是什么，根据最后一行日志的链接：<a href="http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException" target="_blank" rel="noopener">http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException</a> ，我看到描述：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Unlike many other errors, this exception is not generated by the Maven core itself but by a plugin. As a rule of thumb, plugins use this error to signal a problem <span class="keyword">in</span> their configuration or the information they retrieved from the POM.</span><br><span class="line"></span><br><span class="line">The concrete meaning of the exception depends on the plugin so please have a look at its documentation. The documentation <span class="keyword">for</span> many common Maven plugins can be reached via our plugin index.</span><br></pre></td></tr></table></figure><p></p><p>大致意思也就是说这种类型的错误一般不是 Maven 的问题，而是所使用的 Maven 构件的问题，在这里我使用了 deploy 构件，我也知道和 deploy 构件有关，但是具体原因是什么也没说明；</p><p>于是接下来使用 -e 参数（完整命令：mvn deploy -e），除了上述的报错日志外，还可以打印更为详细的错误日志追踪信息，然后发现一直会有下面的错误输入，而且一直重复，没有要停的迹象，我只能手动停掉 mvn 进程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: progressed file size cannot be greater than size: <span class="number">59156480</span> &gt; <span class="number">58029604</span></span><br></pre></td></tr></table></figure><p>异常信息截图 </p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzkj4vhui7j20vi06xdi6.jpg" alt="构件大小相关异常" title="构件大小相关异常"></p><p> 换算一下单位：<br>59156480KB=56.42M（正是需要发布的构件的大小）；<br>58029604KB=55.34M；</p><p>1、通过搜索引擎对异常信息的搜索，大部分结果显示和 Maven 后台的 Web 服务有关，如果使用的是 Nginx，会有一个参数用来限制上传文件的大小，上传文件的大小超过最大限制，就会上传失败，并且抛出异常。我部署其它的小构件没有问题，怀疑是这个原因，于是我询问运维人员公司的 Maven 私服对上传的公共构件有没有大小限制（即可能是 Nginx 服务有没有限制上传文件的大小），运维说不会。但是我还是怀疑，于是想通过 Web 端的界面来手动上传我的构件，发现 Web 端的界面没有开放，无法完成上传操作，接下来我就想看看 Maven 后台服务的对应参数配置的值是多大（也可能使用的是默认值），但是不知道后台采用的是什么服务（Nginx 还是 Netty 不确定），先放弃这条路；</p><p>2、也有结果显示是 Maven 的版本问题，有些版本有 bug，所以造成了这个问题。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><p> 既然没有分析出来具体的原因，只能尝试每一种解决方案了。</p><p>1、既然怀疑是 Maven 私服限制了构件的大小，那就想办法减小构件。先在本地 install，然后去本地仓库看一下生成的构件的大小，结果我惊讶地发现构件居然有 330M 之大，吓死人了，这个打包发布构件的配置肯定有问题，肯定把第三方依赖全部打进去了。我查看了以前生成的正常的构件，也就 60M 左右。</p><p>以下放出对比图 2 个 </p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzkisemw0oj20oy0d6glu.jpg" alt="旧版本正常构件大小" title="旧版本正常构件大小"></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzkit8ztcpj20oy0d6t91.jpg" alt="本地新构件过大" title="本地新构件过大"></p><p> 这一看就是把第三方各种依赖包都一起发布了，才会造成构件有这么大，于是更改 pom.xml 文件，把第三方依赖去除，deploy 的时候是不需要的，同时也删除了一些 resources 资源文件夹里面的文本文件，删除时发现文本文件竟然有几十 M，怪不得以前发布的构件大小有 60M 左右，原来都是文本文件在占用空间；</p><p>更新了之后，直接重新 deploy，不报错了，直接 deploy 成功，去私服仓库搜索查看，大概 30M 左右，很正常 </p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fzkjfjiisoj20im0igdgr.jpg" alt="最终正常的构件" title="最终正常的构件"></p><p>2、问题使用方法一已经解决了，也就是和 Maven 版本没有关系了，而且，在我的当前 Maven 环境下，我去 deploy 其它构件也是成功的，不会有任务报错，所以也从侧面反映了这个问题和 Mave 版本无关，和 Maven 环境也无关；</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a> 问题总结 </h1><p> 参考：<a href="http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException" target="_blank" rel="noopener">http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException</a> ；</p><p>apache 的官方 jira：<br><a href="http://mail-archives.apache.org/mod_mbox/maven-issues/201808.mbox/%3CJIRA.13182024.1535592594000.205524.1535738700211@Atlassian.JIRA%3E" target="_blank" rel="noopener">http://mail-archives.apache.org/mod_mbox/maven-issues/201808.mbox/%3CJIRA.13182024.1535592594000.205524.1535738700211@Atlassian.JIRA%3E</a> ；</p><p><a href="https://issues.apache.org/jira/browse/MNG-6469?page=com.atlassian.jira.plugin.system.issuetabpanels%3Aall-tabpanel" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/MNG-6469?page=com.atlassian.jira.plugin.system.issuetabpanels%3Aall-tabpanel</a> ；</p><p>这个问题去网上搜索不到资料，很痛苦，问人也没有能帮到我的，只能自己去慢慢摸索试验，整个过程比较艰难；</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天在整理代码的时候，在本机（自己的电脑）通过 Maven 的 deploy 插件（org.apache.maven.plugins:maven-deploy-plugin:2.7）进行发布，把代码打包成构件发布到远程的 Maven 仓库（公司的私服），这样方便大家调用。可是，其中有一个项目发布不了（其它类似的 2 个项目都可以，排除了环境的原因），总是报错：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Failed to deploy artifacts: Could not transfer artifact xxx.yyy.zzz:dt-x-y-z:jar:&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;.6-&lt;span class=&quot;number&quot;&gt;20190112.081518&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; from/&lt;span class=&quot;function&quot;&gt;to &lt;span class=&quot;title&quot;&gt;snapshots&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(http://maven.myself.com/nexus/content/repositories/snapshots)&lt;/span&gt;: Connection reset by peer: socket write error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上错误日志中的项目名称、包名称均被替换。本文就记录从发现问题到解决问题的过程。环境所使用的 Maven 版本为：3.5.0。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Maven" scheme="https://www.playpi.org/tags/Maven/"/>
    
      <category term="deploy" scheme="https://www.playpi.org/tags/deploy/"/>
    
  </entry>
  
  <entry>
    <title>使用 Gson 将 = 转为 u003d 的问题</title>
    <link href="https://www.playpi.org/2019010601.html"/>
    <id>https://www.playpi.org/2019010601.html</id>
    <published>2019-01-06T13:57:22.000Z</published>
    <updated>2019-01-07T13:57:22.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>今天遇到一个问题，实现 Web 后台接收 http 请求的一个方法，发现前端传过来的参数值，有一些特殊符号总是使用了 unicode 编码，例如等号 =，后台接收到的就是 \u003d，导致使用这个参数做 JSON 变换的时候就会出错。我看了一下这个参数取值，是前端直接填写的，而填写的人是从其它地方复制过来的，人为没有去改变，前端没有验证转换，导致传入后台的已经是这样了，那么后台只好自己想办法转换。</p><a id="more"></a><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><p> 其实就是字符串还原操作，把 Java 字符串里面的 unicode 编码子串还原为原本的字符，例如把 \u003d 转为 = 这样。</p><p>自己实现一个工具类，做编码字符串和普通字符串的转换，可以解决这个问题。</p><p>单个编码转换，公共方法示例：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * unicode 转字符串 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unicode 全为 Unicode 的字符串 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">unicode2String</span><span class="params">(String unicode)</span> </span>&#123;</span><br><span class="line">    StringBuffer string = <span class="keyword">new</span> StringBuffer ();</span><br><span class="line">    String [] hex = unicode.split (<span class="string">"\\\\u"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; hex.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 转换出每一个代码点 </span></span><br><span class="line">        <span class="keyword">int</span> data = Integer.parseInt (hex [i], <span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 追加成 string</span></span><br><span class="line">        string.append ((<span class="keyword">char</span>) data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string.toString ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>整个字符串转换，公共方法示例：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 含有 unicode 的字符串转一般字符串 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unicodeStr 混有 Unicode 的字符串 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">unicodeStr2String</span><span class="params">(String unicodeStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = unicodeStr.length ();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 正则匹配条件，可匹配 \\u 1 到 4 位，一般是 4 位可直接使用 String regex = "\\\\u [a-f0-9A-F]&#123;4&#125;";</span></span><br><span class="line">    String regex = <span class="string">"\\\\u [a-f0-9A-F]&#123;1,4&#125;"</span>;</span><br><span class="line">    Pattern pattern = Pattern.compile (regex);</span><br><span class="line">    Matcher matcher = pattern.matcher (unicodeStr);</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer ();</span><br><span class="line">    <span class="keyword">while</span> (matcher.find ()) &#123;</span><br><span class="line">        <span class="comment">// 原本的 Unicode 字符 </span></span><br><span class="line">        String oldChar = matcher.group ();</span><br><span class="line">        <span class="comment">// 转换为普通字符 </span></span><br><span class="line">        String newChar = unicode2String (oldChar);</span><br><span class="line">        <span class="keyword">int</span> index = matcher.start ();</span><br><span class="line">        <span class="comment">// 添加前面不是 unicode 的字符 </span></span><br><span class="line">        sb.append (unicodeStr.substring (count, index));</span><br><span class="line">        <span class="comment">// 添加转换后的字符 </span></span><br><span class="line">        sb.append (newChar);</span><br><span class="line">        <span class="comment">// 统计下标移动的位置 </span></span><br><span class="line">        count = index + oldChar.length ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加末尾不是 Unicode 的字符 </span></span><br><span class="line">    sb.append (unicodeStr.substring (count, length));</span><br><span class="line">    <span class="keyword">return</span> sb.toString ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>调用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"ABCDEFG\\u003d"</span>;</span><br><span class="line">System.out.println (<span class="string">"====unicode2String 工具转换:"</span> + unicodeStr2String (str));</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">====unicode2String 工具转换：ABCDEFG=</span><br></pre></td></tr></table></figure><p>截图示例：</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyyep0kwtgj20yv0kk0ug.jpg" alt="自己转换" title="自己转换"></p><h1 id="问题后续"><a href="# 问题后续" class="headerlink" title="问题后续"></a>问题后续 </h1><p> 后续我又在想，这个字符串到底是怎么来的，为什么填写的人会复制出来这样一个字符串，一般 unicode 编码不会出现在日常生活中的。我接着发现这个字符串是从另外一个系统导出的，导出的时候是一个类似于 Java 实体类的 JSON 格式字符串，从里面复制出来这个值，就是 \u003d 格式的。</p><p>那我觉得肯定是这个系统有问题，做 JSON 序列化的时候没有控制好序列化的方式，导致对于特殊字符就会自动转为 unicode 编码，给他人带来麻烦，当然，我无法得知系统内部做了什么，但是猜测可能是使用 Gson 工具做序列化的时候没有正确使用 Gson 的对象，只是简单的生成 JSON 字符串而已，例如看我下面的代码示例（等号 = 会被转为 \u003d）。</p><p>使用普通的 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gson gson1 = <span class="keyword">new</span> Gson ();</span><br></pre></td></tr></table></figure><p> 会导致后续转换 JSON 字符串的时候出现 unicode 编码子串的情况，而正确生成 Gson 对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gson gson2 = <span class="keyword">new</span> GsonBuilder ().disableHtmlEscaping ().create ();</span><br></pre></td></tr></table></figure><p> 则不会出现这种情况。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyyeompqqcj20zr0k3jt4.jpg" alt="正确使用 Gson" title="正确使用 Gson"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天遇到一个问题，实现 Web 后台接收 http 请求的一个方法，发现前端传过来的参数值，有一些特殊符号总是使用了 unicode 编码，例如等号 =，后台接收到的就是 \u003d，导致使用这个参数做 JSON 变换的时候就会出错。我看了一下这个参数取值，是前端直接填写的，而填写的人是从其它地方复制过来的，人为没有去改变，前端没有验证转换，导致传入后台的已经是这样了，那么后台只好自己想办法转换。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Gson" scheme="https://www.playpi.org/tags/Gson/"/>
    
      <category term="等号编码转换" scheme="https://www.playpi.org/tags/%E7%AD%89%E5%8F%B7%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="u003d" scheme="https://www.playpi.org/tags/u003d/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Pages 禁止百度蜘蛛爬取的问题</title>
    <link href="https://www.playpi.org/2019010501.html"/>
    <id>https://www.playpi.org/2019010501.html</id>
    <published>2019-01-04T16:42:49.000Z</published>
    <updated>2019-01-05T16:42:49.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:49 GMT+0800 (China Standard Time) --><p>最近才发现我的静态博客站点，大部分的网页没被百度收录，除了少量的网页是我自动提交（主动推动、自动推送）的，或者手动提交的，其它的网页都不被收录（网页全部是利用自动提交的 sitemap 方式提交的，一个都没收录）。我查看百度的站长工具后台，发现通过 sitemap 方式提交链接这种方式不可行，因为百度蜘蛛采集链接信息之前需要访问 baidusitemap.xml 文件，而这个文件是在 GitHub Pages 里面的，但是 GitHub Pages 是禁止百度蜘蛛爬取的，所以百度蜘蛛在获取 baidusitemap.xml 文件这一步骤就被禁止了，GitHub Pages 返回 403 错误（在 http 协议中表示禁止访问），因此抓取失败（哪怕获取到 baidusitemap.xml 文件也不行，因为后续需要采集的静态网页全部是放在 GitHub Pages 中的，全部都会被禁止）。本文就详细描述这种现象，以及寻找可行的解决方案。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 利用搜索引擎的 site 搜索可以看到百度与谷歌明显的差别 <br> 百度搜索结果（只有少量的收录，仅有的还是通过主动推送与自动推送提交的）<br>图 </p><p> 谷歌搜索结果（收录很多，而且很全面）<br>图 </p><p> 首先在百度站长工具后台看到 baidusitemap.xml 抓取失败，查看具体原因是抓取失败（http 状态码 403）。</p><p>抓取失败 <br> 图</p><p>抓取失败原因概述 <br> 图</p><p>根据抓取失败原因，我还以为是文件不存在，或者根据链接打不开（链接是：<a href="https://www.playpi.org/baidusitemap.xml">https://www.playpi.org/baidusitemap.xml</a> ），我使用浏览器和 curl 命令都尝试过了，链接没有问题，可以正常打开。然后根据 403 错误发现是拒绝访问，那就有可能是百度爬虫的问题了（被 GitHub Pages 禁止爬取了）。</p><p>使用浏览器打开 <br> 图</p><p>使用命令行打开（如下使用 curl 命令）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://www.playpi.org/baidusitemap.xml</span><br></pre></td></tr></table></figure><p>图 </p><p> 于是接下来，我就给官方提交了反馈，官方只是回复我说是链接问题。</p><p>提交反馈 <br> 图</p><p>反馈回复 <br> 图</p><p>前面我已经证明了链接没问题，那我就要猜想是百度蜘蛛爬虫的问题了，于是按照官方回复的建议，使用诊断工具看看是否可行。</p><p>诊断工具测试多次都失败 <br> 图</p><p>失败原因仍旧是拒绝访问（http 403 状态码）<br>图 </p><p> 我又接着查看文档，发现拒绝访问的原因之一就是托管服务供应商阻止百度 Spider 访问我的网站。</p><p>文档说明截取片段 <br> 图</p><p>接下里我又查找了资料，并尝试给 GitHub 的技术支持发送邮件询问，得到了确认的答复，GitHub 已经禁止了百度蜘蛛爬虫的访问。</p><p>邮件回复 <br> 图</p><h1 id="解决方案"><a href="# 解决方案" class="headerlink" title="解决方案"></a>解决方案 </h1><p> 本来这个问题是很好解决的（更换静态博客存储的主机即可，例如各种项目托管服务：码市、gitcafe、七牛云等，或者自己购买一台云主机），但是我不能抛弃 GitHub，于是问题变得复杂了。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:49 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近才发现我的静态博客站点，大部分的网页没被百度收录，除了少量的网页是我自动提交（主动推动、自动推送）的，或者手动提交的，其它的网页都不被收录（网页全部是利用自动提交的 sitemap 方式提交的，一个都没收录）。我查看百度的站长工具后台，发现通过 sitemap 方式提交链接这种方式不可行，因为百度蜘蛛采集链接信息之前需要访问 baidusitemap.xml 文件，而这个文件是在 GitHub Pages 里面的，但是 GitHub Pages 是禁止百度蜘蛛爬取的，所以百度蜘蛛在获取 baidusitemap.xml 文件这一步骤就被禁止了，GitHub Pages 返回 403 错误（在 http 协议中表示禁止访问），因此抓取失败（哪怕获取到 baidusitemap.xml 文件也不行，因为后续需要采集的静态网页全部是放在 GitHub Pages 中的，全部都会被禁止）。本文就详细描述这种现象，以及寻找可行的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="https://www.playpi.org/categories/building/"/>
    
    
      <category term="建站" scheme="https://www.playpi.org/tags/building/"/>
    
      <category term="GitHub Pages" scheme="https://www.playpi.org/tags/GitHub-Pages/"/>
    
      <category term="SEO" scheme="https://www.playpi.org/tags/SEO/"/>
    
      <category term="百度蜘蛛" scheme="https://www.playpi.org/tags/%E7%99%BE%E5%BA%A6%E8%9C%98%E8%9B%9B/"/>
    
      <category term="Baiduspider" scheme="https://www.playpi.org/tags/Baiduspider/"/>
    
  </entry>
  
  <entry>
    <title>蒸水蛋做法总结</title>
    <link href="https://www.playpi.org/2018122901.html"/>
    <id>https://www.playpi.org/2018122901.html</id>
    <published>2018-12-29T15:21:25.000Z</published>
    <updated>2018-12-29T16:21:25.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>蒸水蛋是一道小吃，有时候就简称为水蛋，可以当菜配饭吃，也可以配包子当做早餐，或者晚上蒸一碗当做宵夜，都非常好。吃起来嫩滑爽口，而且营养也丰富，做法非常简单，本文就记录蒸水蛋的过程。</p><a id="more"></a><h1 id="食材准备"><a href="# 食材准备" class="headerlink" title="食材准备"></a>食材准备 </h1><p>2 人份的材料（1 人份减半即可，但是我觉得 1 人份的太少了，做起来浪费，不值当）：</p><ul><li> 鸡蛋 2 只（1 只做成 1 碗）</li><li>葱花少许 </li><li> 生抽少许 </li><li> 食用盐少许 </li><li> 香油少许 </li></ul><h1 id="制作步骤"><a href="# 制作步骤" class="headerlink" title="制作步骤"></a> 制作步骤 </h1><p>1、准备 2 只小碗（有条件的可以使用带盖子的蒸盅，也就是平时吃快餐盛汤的那种带盖子的小碗），普通的小饭碗即可，一定要是耐热的材料，不要用秸秆环保碗、塑料饭盒、普通玻璃碗等（蒸的时候温度很高，虽然水的沸点是 100 度，但是锅内因为有水蒸气存在，压强变大，同时水蒸气转为液态会放热，锅内实际温度大于 100 度），分别打入 1 只鸡蛋，加少许食用盐，搅拌均匀（下面过程就以 1 份为准，另外 1 份是同样的操作）；</p><p>2、搅拌均匀后开始加温水（最好是温水），温水的量大概是鸡蛋液的 2 倍，即鸡蛋液比温水等于 1:2，注意加温水的量，少了多了都不好（2-3 倍都行，如果碗大一点可能 1 份水蛋就需要放 2 只鸡蛋，不然显得太少了），继续搅拌，此时搅拌完成后表面应该会有一层小泡沫，可以用勺子把小泡沫都盛出去，保证蒸出来的水蛋表面光滑（怕浪费保留也行）；</p><p> 搅拌均匀 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz5jgxdp2qj229s29sb29.jpg" alt="搅拌均匀" title="搅拌均匀"></p><p>3、蒸鸡蛋的时候使用保鲜膜封住碗口（有条件的使用整蛊更方便，盖子一盖即可），或者使用小盘子反盖在碗口，这样做是为了保证密封，一方面为了保证蒸出来的水蛋嫩滑，另一方面为了避免液化的水蒸气滴进去，影响水蛋的质量，先大火烧水，等水开后转为小火（火力很重要），再蒸 8 分钟即可出锅（这个时间很重要，太久了鸡蛋就老了）；</p><p> 开始蒸，我为了省事就不撇小泡沫，也不盖保鲜膜了，所以做出来的成品会有点难看 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz5jhj31txj229s29skjl.jpg" alt="开始蒸" title="开始蒸"></p><p>4、取出后，滴入少许香油、生抽（不加也行，直接吃），撒入一点点葱花，即可食用，入口即化，滑嫩可口；</p><p> 成品 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz5jhyeow6j229s29se81.jpg" alt="成品" title="成品"></p><p> 以下这个我认为是做失败的，加太多水，蒸的过程中不断滴入液化的水蒸气，破坏了美感，也没葱花，但是吃起来绝对美味。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyo56bfejij229s29sx6p.jpg" alt="很勉强的蒸水蛋" title="很勉强的蒸水蛋"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1、食用盐是搅拌鸡蛋的时候就加入的，不是蒸好后再放的，这样才能入味而且分布均匀；</p><p>2、加水时一定要加温水，不是冷水，也不是热水，温水才能让蒸出来的水蛋保持嫩滑；</p><p>3、如果使用保鲜膜，一定要用可以蒸的材料，不是随便能用的。如果是 PVC 材料（聚氯乙烯），坚决不行，含有塑化剂释放有毒物质影响健康，如果是 PE 材料（聚乙烯），无毒，但是耐热温度不够，也不行，如果是 PVDC 材料（聚偏氯乙烯），安全温度在 140 度，可以使用。所以还是使用盘子比较好。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;蒸水蛋是一道小吃，有时候就简称为水蛋，可以当菜配饭吃，也可以配包子当做早餐，或者晚上蒸一碗当做宵夜，都非常好。吃起来嫩滑爽口，而且营养也丰富，做法非常简单，本文就记录蒸水蛋的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="蒸水蛋" scheme="https://www.playpi.org/tags/%E8%92%B8%E6%B0%B4%E8%9B%8B/"/>
    
      <category term="水蛋" scheme="https://www.playpi.org/tags/%E6%B0%B4%E8%9B%8B/"/>
    
      <category term="蒸鸡蛋" scheme="https://www.playpi.org/tags/%E8%92%B8%E9%B8%A1%E8%9B%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spark 异常之 java.net.BindException: 地址已在使用</title>
    <link href="https://www.playpi.org/2018122801.html"/>
    <id>https://www.playpi.org/2018122801.html</id>
    <published>2018-12-28T15:49:01.000Z</published>
    <updated>2018-12-28T15:49:01.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>今天查看日志发现，所有的 Spark 程序提交时会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.BindException: 地址已在使用 </span><br></pre></td></tr></table></figure><p>而且不止一次，会连续有多个这种异常，但是 Spark 程序又能正常运行，不会影响到对应的功能。本文就记录发现问题、分析问题的过程。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 在 Driver 端查看日志，发现连续多次相同的异常（省略了业务相关类信息）：</p><p>异常截图 </p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fymxb3zolsj210v0dzabe.jpg" alt="异常截图" title="异常截图"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次异常 </span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0:<span class="number">4040</span>: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0 (Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind (Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind (Net.java:<span class="number">425</span>)</span><br><span class="line">at sun.nio.ch.ServerSocketChannelImpl.bind (ServerSocketChannelImpl.java:<span class="number">223</span>)</span><br><span class="line">at sun.nio.ch.ServerSocketAdaptor.bind (ServerSocketAdaptor.java:<span class="number">74</span>)</span><br><span class="line">at org.spark-project.jetty.server.nio.SelectChannelConnector.open (SelectChannelConnector.java:<span class="number">187</span>)</span><br><span class="line">at org.spark-project.jetty.server.AbstractConnector.doStart (AbstractConnector.java:<span class="number">316</span>)</span><br><span class="line">at org.spark-project.jetty.server.nio.SelectChannelConnector.doStart (SelectChannelConnector.java:<span class="number">265</span>)</span><br><span class="line">at org.spark-project.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:<span class="number">64</span>)</span><br><span class="line">at org.spark-project.jetty.server.Server.doStart (Server.java:<span class="number">293</span>)</span><br><span class="line">at org.spark-project.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:<span class="number">64</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$.org$apache$spark$ui$JettyUtils$$connect$<span class="number">1</span>(JettyUtils.scala:<span class="number">252</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$$anonfun$<span class="number">5</span>.apply (JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$$anonfun$<span class="number">5</span>.apply (JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.util.Utils$$anonfun$startServiceOnPort$<span class="number">1</span>.apply$mcVI$sp (Utils.scala:<span class="number">2024</span>)</span><br><span class="line">at scala.collection.immutable.Range.foreach$mVc$sp (Range.scala:<span class="number">141</span>)</span><br><span class="line">at org.apache.spark.util.Utils$.startServiceOnPort (Utils.scala:<span class="number">2015</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$.startJettyServer (JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.ui.WebUI.bind (WebUI.scala:<span class="number">136</span>)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$<span class="number">13</span>.apply (SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$<span class="number">13</span>.apply (SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at scala.Option.foreach (Option.scala:<span class="number">236</span>)</span><br><span class="line">at org.apache.spark.SparkContext.&lt;init&gt;(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at org.apache.spark.api.java.JavaSparkContext.&lt;init&gt;(JavaSparkContext.scala:<span class="number">59</span>)</span><br><span class="line">......</span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED org.spark-project.jetty.server.Server@<span class="number">33e434</span>c8: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0 (Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind (Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind (Net.java:<span class="number">425</span>)</span><br><span class="line">at sun.nio.ch.ServerSocketChannelImpl.bind (ServerSocketChannelImpl.java:<span class="number">223</span>)</span><br><span class="line">at sun.nio.ch.ServerSocketAdaptor.bind (ServerSocketAdaptor.java:<span class="number">74</span>)</span><br><span class="line">at org.spark-project.jetty.server.nio.SelectChannelConnector.open (SelectChannelConnector.java:<span class="number">187</span>)</span><br><span class="line">at org.spark-project.jetty.server.AbstractConnector.doStart (AbstractConnector.java:<span class="number">316</span>)</span><br><span class="line">at org.spark-project.jetty.server.nio.SelectChannelConnector.doStart (SelectChannelConnector.java:<span class="number">265</span>)</span><br><span class="line">at org.spark-project.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:<span class="number">64</span>)</span><br><span class="line">at org.spark-project.jetty.server.Server.doStart (Server.java:<span class="number">293</span>)</span><br><span class="line">at org.spark-project.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:<span class="number">64</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$.org$apache$spark$ui$JettyUtils$$connect$<span class="number">1</span>(JettyUtils.scala:<span class="number">252</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$$anonfun$<span class="number">5</span>.apply (JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$$anonfun$<span class="number">5</span>.apply (JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.util.Utils$$anonfun$startServiceOnPort$<span class="number">1</span>.apply$mcVI$sp (Utils.scala:<span class="number">2024</span>)</span><br><span class="line">at scala.collection.immutable.Range.foreach$mVc$sp (Range.scala:<span class="number">141</span>)</span><br><span class="line">at org.apache.spark.util.Utils$.startServiceOnPort (Utils.scala:<span class="number">2015</span>)</span><br><span class="line">at org.apache.spark.ui.JettyUtils$.startJettyServer (JettyUtils.scala:<span class="number">262</span>)</span><br><span class="line">at org.apache.spark.ui.WebUI.bind (WebUI.scala:<span class="number">136</span>)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$<span class="number">13</span>.apply (SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$<span class="number">13</span>.apply (SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at scala.Option.foreach (Option.scala:<span class="number">236</span>)</span><br><span class="line">at org.apache.spark.SparkContext.&lt;init&gt;(SparkContext.scala:<span class="number">481</span>)</span><br><span class="line">at org.apache.spark.api.java.JavaSparkContext.&lt;init&gt;(JavaSparkContext.scala:<span class="number">59</span>)</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次异常 </span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0:<span class="number">4041</span>: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0 (Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind (Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind (Net.java:<span class="number">425</span>)</span><br><span class="line">...... 其它信息都一样 </span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次异常 </span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0:<span class="number">4042</span>: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0 (Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind (Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind (Net.java:<span class="number">425</span>)</span><br><span class="line">....... 其它信息都一样 </span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次异常 </span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">28_12</span>:<span class="number">50</span>:<span class="number">56</span> [main] WARN component.AbstractLifeCycle:<span class="number">204</span>: FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0:<span class="number">4043</span>: java.net.BindException: 地址已在使用 </span><br><span class="line">java.net.BindException: 地址已在使用 </span><br><span class="line">at sun.nio.ch.Net.bind0 (Native Method)</span><br><span class="line">at sun.nio.ch.Net.bind (Net.java:<span class="number">433</span>)</span><br><span class="line">at sun.nio.ch.Net.bind (Net.java:<span class="number">425</span>)</span><br><span class="line">....... 其它信息都一样 </span><br></pre></td></tr></table></figure><p> 可以轻易发现核心的地方在于：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FAILED SelectChannelConnector@<span class="number">0.0</span>.0.0: 端口号: java.net.BindException: 地址已在使用 </span><br></pre></td></tr></table></figure><p></p><p>端口号在不断变化，从 4040 一直到 4043，才停止了异常的抛出。</p><h1 id="问题分析"><a href="# 问题分析" class="headerlink" title="问题分析"></a>问题分析 </h1><p> 在 Spark 创建 context 的时候，会使用 4040 端口作为默认的 SparkUI 端口，如果遇到 4040 端口被占用，则会抛出异常。接着会尝试下一个可用的端口，采用累加的方式，则使用 4041 端口，很不巧，这个端口也被占用了，也会抛出异常。接着就是重复上面的过程，直到找到空闲的端口。</p><p>这个异常其实没什么问题，是正常的，原因可能就是在一台机器上面有多个进程都在使用 Spark，创建 context，有的 Spark 任务正在运行着，占用了 4040 端口；或者就是单纯的端口被某些应用程序占用了而已。此时是不能简单地把这些进程杀掉的，会影响别人的业务。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><p> 既然找到了问题，解决办法就很简单了：</p><p>1、这本来就不是问题，直接忽略即可，不会影响 Spark 任务的正常运行；</p><p>2、如果非要不想看到异常日志，那么可以检查机器的 4040 端口被什么进程占用了，看看能不能杀掉，当然这种方法不好了；</p><p>3、可以自己指定端口（使用 spark.ui.port 配置项），确保使用空闲的端口即可（不建议，因为要确认空闲的端口，如果端口不空闲，Spark 的 context 会创建失败，更麻烦，还不如让 Spark 自己去重试）。</p><p>参考：<a href="https://community.hortonworks.com/questions/8257/how-can-i-resolve-it.html" target="_blank" rel="noopener">hortonworks</a></p><p>原文：</p><blockquote><p>When a spark context is created, it starts an application UI on port 4040 by default. When the UI starts, it checks to see if the port is in use, if so it should increment to 4041. Looks like you have something running on port 4040 there. The application should show you the warning, then try to start the UI on 4041.<br>This should not stop your application from running. If you really want to get around the WARNING, you can manually specify which port for the UI to start on, but I would strongly advise against doing so.<br>To manually specify the port, add this to your spark-submit:<br>–conf spark.ui.port=your_port</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天查看日志发现，所有的 Spark 程序提交时会抛出异常：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.net.BindException: 地址已在使用 &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;而且不止一次，会连续有多个这种异常，但是 Spark 程序又能正常运行，不会影响到对应的功能。本文就记录发现问题、分析问题的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="BindException" scheme="https://www.playpi.org/tags/BindException/"/>
    
  </entry>
  
  <entry>
    <title>HDFS 异常之 READ is not supported in state standby</title>
    <link href="https://www.playpi.org/2018122702.html"/>
    <id>https://www.playpi.org/2018122702.html</id>
    <published>2018-12-27T11:06:42.000Z</published>
    <updated>2018-12-27T11:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>今天查看日志发现，以前正常运行的 Spark 程序会不断抛出异常：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.hadoop.ipc.RemoteException (org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby</span><br></pre></td></tr></table></figure><p></p><p>但是却没有影响到功能的正常运行，只不过是抛出了大量的上述异常，而且内容都一样，也都是操作 HDFS 产生的，所以猜测与 HDFS 集群（或者配置）有关系。本文就记录发现问题、解决问题的过程。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 按照日常操作，查看 Spark 任务的 Driver 端的日志，结果发现了大量的重复异常，又看了一下对功能的影响，结果发现没有影响，所有功能均正常运行，产生的结果也是期望的。</p><h2 id="问题分析"><a href="# 问题分析" class="headerlink" title="问题分析"></a>问题分析 </h2><p> 详细来看一下 Driver 端的日志异常信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">2018-12-26_23:25:40 [main] INFO retry.RetryInvocationHandler:140: Exception while invoking getFileInfo of class ClientNamenodeProtocolTranslatorPB over hadoop1/192.168.10.162:8020. Trying to fail over immediately.</span><br><span class="line">org.apache.hadoop.ipc.RemoteException (org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.ha.StandbyState.checkOperation (StandbyState.java:<span class="number">87</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.NameNode$NameNodeHAContext.checkOperation (NameNode.java:<span class="number">1722</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.checkOperation (FSNamesystem.java:<span class="number">1362</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.getFileInfo (FSNamesystem.java:<span class="number">4414</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.server.namenode.NameNodeRpcServer.getFileInfo (NameNodeRpcServer.java:<span class="number">893</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.protocolPB.ClientNamenodeProtocolServerSideTranslatorPB.getFileInfo (ClientNamenodeProtocolServerSideTranslatorPB.java:<span class="number">835</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos$ClientNamenodeProtocol$<span class="number">2</span>.callBlockingMethod (ClientNamenodeProtocolProtos.java)</span><br><span class="line">at org.apache.hadoop.ipc.ProtobufRpcEngine$Server$ProtoBufRpcInvoker.call (ProtobufRpcEngine.java:<span class="number">619</span>)</span><br><span class="line">at org.apache.hadoop.ipc.RPC$Server.call (RPC.java:<span class="number">962</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Server$Handler$<span class="number">1</span>.run (Server.java:<span class="number">2039</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Server$Handler$<span class="number">1</span>.run (Server.java:<span class="number">2035</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged (Native Method)</span><br><span class="line">at javax.security.auth.Subject.doAs (Subject.java:<span class="number">422</span>)</span><br><span class="line">at org.apache.hadoop.security.UserGroupInformation.doAs (UserGroupInformation.java:<span class="number">1628</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Server$Handler.run (Server.java:<span class="number">2033</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Client.call (Client.java:<span class="number">1468</span>)</span><br><span class="line">at org.apache.hadoop.ipc.Client.call (Client.java:<span class="number">1399</span>)</span><br><span class="line">at org.apache.hadoop.ipc.ProtobufRpcEngine$Invoker.invoke (ProtobufRpcEngine.java:<span class="number">232</span>)</span><br><span class="line">at com.sun.proxy.$Proxy30.getFileInfo (Unknown Source)</span><br><span class="line">at org.apache.hadoop.hdfs.protocolPB.ClientNamenodeProtocolTranslatorPB.getFileInfo (ClientNamenodeProtocolTranslatorPB.java:<span class="number">768</span>)</span><br><span class="line">at sun.reflect.GeneratedMethodAccessor34.invoke (Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke (Method.java:<span class="number">498</span>)</span><br><span class="line">at org.apache.hadoop.io.retry.RetryInvocationHandler.invokeMethod (RetryInvocationHandler.java:<span class="number">187</span>)</span><br><span class="line">at org.apache.hadoop.io.retry.RetryInvocationHandler.invoke (RetryInvocationHandler.java:<span class="number">102</span>)</span><br><span class="line">at com.sun.proxy.$Proxy31.getFileInfo (Unknown Source)</span><br><span class="line">at org.apache.hadoop.hdfs.DFSClient.getFileInfo (DFSClient.java:<span class="number">2007</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DistributedFileSystem$<span class="number">19</span>.doCall (DistributedFileSystem.java:<span class="number">1136</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DistributedFileSystem$<span class="number">19</span>.doCall (DistributedFileSystem.java:<span class="number">1132</span>)</span><br><span class="line">at org.apache.hadoop.fs.FileSystemLinkResolver.resolve (FileSystemLinkResolver.java:<span class="number">81</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DistributedFileSystem.getFileStatus (DistributedFileSystem.java:<span class="number">1132</span>)</span><br><span class="line">at org.apache.hadoop.fs.FileSystem.isFile (FileSystem.java:<span class="number">1426</span>)</span><br></pre></td></tr></table></figure><p>注意一下核心异常所在：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception while invoking getFileInfo of class ClientNamenodeProtocolTranslatorPB over hadoop1/192.168.10.162:8020. Trying to fail over immediately.</span><br><span class="line">org.apache.hadoop.ipc.RemoteException (org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby</span><br></pre></td></tr></table></figure><p></p><p>当去从 hadoop1/192.168.10.162:8020 这里 getFileInfo 的时候，抛出了异常，而且明确告诉我们这台机器处于 standby 状态，不支持读取操作。此时，可以想到，肯定是 hadoop1/192.168.10.162:8020 这台机器已经处于 standby 状态了，无法提供服务，所以抛出此异常。既然问题找到了，那么问题产生的原因是什么呢，以及为什么对功能没有影响，接下来一一分析。</p><p>首先查看 hdfs-site.xml 配置文件，看看 namenode 相关的配置项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.nameservices<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>r-cluster<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.ha.namenodes.r-cluster<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>nn1,nn2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.r-cluster.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop1:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.r-cluster.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>rocket15:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，namenode 相关配置有 2 台机器：nn1、nn2，而上述产生异常的信息表明连接 nn1 被拒绝，那么我去看一下 HDFS 集群的状态，发现 nn1 果然是 standby 状态的，而 nn2（rocket15） 才是 active 状态。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyluqlzruwj20ln0b6mxq.jpg" alt="nn2 的 active 状态" title="nn2 的 active 状态"></p><p>再仔细查看日志，没有发现连接 nn2 的异常，那就说明是第一次连接 nn1 抛出异常，然后试图连接 nn2，成功连接，没有抛出异常，接下来程序就正常处理数据了，对功能没有任何影响。</p><p>到这里，我们已经分析出了整个过程，现象表明这个异常只是连接了 standby 状态的 namenode，是正常抛出的。然后会再次连接另外一台 active 状态的 namenode，连接成功。</p><h2 id="抛异常的流程细节"><a href="# 抛异常的流程细节" class="headerlink" title="抛异常的流程细节"></a>抛异常的流程细节 </h2><p>1、客户端在连接 HDFS 的时候，会从配置文件 hdfs-site.xml 中，读取 nameservices 的配置，获取机器编号，我这里是 nn1 和 nn2，分别对应着 2 台 namenode 机器；</p><p>2、客户端会首先选择编号较小的 namenode（我这里是 nn1，对应着 hadoop1），试图连接；</p><p>3、如果这台 namenode 是 active 状态，则客户端可以正常处理请求；但是如果这台 namenode 是 standby 状态，则客户端抛出由服务端返回的异常：Operation category READ is not supported in state standby，同时打印 ip 信息，接着会尝试连接另外一台编号较大的 namenode（我这里是 nn2，即 rocket15）；</p><p>4、如果连接成功，则客户端可以正常处理请求；如果 nn2 仍然像 nn1 一样，客户端会抛出一样的异常，此时会继续反复重试 nn1 与 nn2（重试次数有配置项，间隔时间有配置项）；如果有成功的，则客户端可以正常处理请求，如果全部失败，则客户端无法正常处理请求，此时应该要关注解决 namenode 为什么全部都处在 standby 状态。</p><p> 配置参数如下（参考 <a href="https://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml" target="_blank" rel="noopener">Hadoop 官方文档 </a>）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 客户端重试次数，默认 15 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.max.attempts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>15<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 客户端 2 次重试间隔时间，默认 500 毫秒 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.sleep.base.millis<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>500<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 客户端 2 次重试间隔时间，默认 1500 毫秒 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.sleep.max.millis<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1500<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 客户端 1 次连接中重试次数，默认 0, 在网络不稳定时建议加大此值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.connection.retries<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 客户端 1 次连接中超时重试次数，仅是指超时重试，默认 0, 在网络不稳定时建议加大此值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.client.failover.connection.retries.on.timeouts<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a> 问题解决 </h1><p> 既然明确了问题，并且分析出了具体原因，解决起来就简单了，对于我这种情况，有 2 种方法：</p><p>1、不用解决，也无需关心，这个异常没有任何影响，会自动重连另外一台 active 状态的 namenode 机器的；</p><p>2、如果就是一心想把异常消除掉，那就更改 hdfs-site.xml 配置文件里面的 nameservices 配置项对应的机器，把编号最小的机器设置成状态为 active 的 namenode（例如我这里把 nn1、nn2 的对应的机器 ip 地址交换一下即可，确保 nn1 是 active 状态的），那么连接 HDFS 的时候第一次就会直接连接这台机器，就不会抛出异常了（但是要注意 namenode 以后可能是会挂的，挂了会自动切换，那么到那个时候还要更改这个配置项）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.r-cluster.nn1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>rocket15:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.rpc-address.r-cluster.nn2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop1:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><p>1、参考：<a href="http://support-it.huawei.com/docs/zh-cn/fusioninsight-all/maintenance-guide/zh-cn_topic_0062904132.html" target="_blank" rel="noopener">http://support-it.huawei.com/docs/zh-cn/fusioninsight-all/maintenance-guide/zh-cn_topic_0062904132.html</a></p><p>2、这个问题其实不是问题，只不过抛出了异常，我看到有点担心而已，但是如果连接所有的机器都抛出这种异常，并且重试了很多次就有影响了，说明所有的 namenode 都挂了，根本无法正常操作 HDFS 系统；</p><p>3、根据 2 进行总结：如果只是在操作 HDFS 的时候打印一次（每次操作都会打印一次），说明第一次连接到了 standby 状态的 namenode，是正常的，不用关心；但是，如果出现了大量的异常（比如连续 10 次，连续 20 次），说明 namenode 出问题了，此时应该关心 namenode 的状态，确保正常服务。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天查看日志发现，以前正常运行的 Spark 程序会不断抛出异常：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;org.apache.hadoop.ipc.RemoteException (org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是却没有影响到功能的正常运行，只不过是抛出了大量的上述异常，而且内容都一样，也都是操作 HDFS 产生的，所以猜测与 HDFS 集群（或者配置）有关系。本文就记录发现问题、解决问题的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Hadoop 从零基础到入门系列" scheme="https://www.playpi.org/categories/series-of-hadoop/"/>
    
    
      <category term="Hadoop" scheme="https://www.playpi.org/tags/Hadoop/"/>
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="HDFS" scheme="https://www.playpi.org/tags/HDFS/"/>
    
      <category term="nameNode" scheme="https://www.playpi.org/tags/nameNode/"/>
    
      <category term="standby" scheme="https://www.playpi.org/tags/standby/"/>
    
  </entry>
  
  <entry>
    <title>HDFS 异常之 Filesystem closed</title>
    <link href="https://www.playpi.org/2018122701.html"/>
    <id>https://www.playpi.org/2018122701.html</id>
    <published>2018-12-27T09:35:54.000Z</published>
    <updated>2018-12-27T09:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:49 GMT+0800 (China Standard Time) --><p>今天通过 Hadoop 的 api 去操作 HDFS 里面的文件，读取文本内容，但是在代码里面总是抛出以下异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.io.IOException: Filesystem closed</span><br></pre></td></tr></table></figure><p>然而文本内容又是正常读取出来的，但是我隐隐觉得读取的文本内容可能不全，应该只是所有文本内容的一部分。本文就记录这个问题的原因、影响以及解决方法。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 通过查看日志发现，有大量的异常日志打印出来，全部都是操作 HDFS 的时候产生的，有的是使用 Spark 连接 HDFS 读取文本数据，有的是使用 Hadoop 的 Java api 通过文件流来读取数据，每次读取操作都会产生一个如下异常信息（会影响实际读取的内容，多个 DataNode 的内容会漏掉）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">26_23</span>:<span class="number">25</span>:<span class="number">46</span> [SparkListenerBus] ERROR scheduler.LiveListenerBus:<span class="number">95</span>: Listener EventLoggingListener threw an exception</span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">at sun.reflect.GeneratedMethodAccessor33.invoke (Unknown Source)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke (Method.java:<span class="number">498</span>)</span><br><span class="line">at org.apache.spark.scheduler.EventLoggingListener$$anonfun$logEvent$<span class="number">3</span>.apply (EventLoggingListener.scala:<span class="number">150</span>)</span><br><span class="line">at org.apache.spark.scheduler.EventLoggingListener$$anonfun$logEvent$<span class="number">3</span>.apply (EventLoggingListener.scala:<span class="number">150</span>)</span><br><span class="line">at scala.Option.foreach (Option.scala:<span class="number">236</span>)</span><br><span class="line">at org.apache.spark.scheduler.EventLoggingListener.logEvent (EventLoggingListener.scala:<span class="number">150</span>)</span><br><span class="line">at org.apache.spark.scheduler.EventLoggingListener.onJobStart (EventLoggingListener.scala:<span class="number">173</span>)</span><br><span class="line">at org.apache.spark.scheduler.SparkListenerBus$class.onPostEvent (SparkListenerBus.scala:34)</span><br><span class="line">at org.apache.spark.scheduler.LiveListenerBus.onPostEvent (LiveListenerBus.scala:<span class="number">31</span>)</span><br><span class="line">at org.apache.spark.scheduler.LiveListenerBus.onPostEvent (LiveListenerBus.scala:<span class="number">31</span>)</span><br><span class="line">at org.apache.spark.util.ListenerBus$class.postToAll (ListenerBus.scala:55)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus.postToAll (AsynchronousListenerBus.scala:<span class="number">37</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>$$anonfun$run$<span class="number">1</span>$$anonfun$apply$mcV$sp$<span class="number">1</span>.apply$mcV$sp (AsynchronousListenerBus.scala:<span class="number">80</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>$$anonfun$run$<span class="number">1</span>$$anonfun$apply$mcV$sp$<span class="number">1</span>.apply (AsynchronousListenerBus.scala:<span class="number">65</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>$$anonfun$run$<span class="number">1</span>$$anonfun$apply$mcV$sp$<span class="number">1</span>.apply (AsynchronousListenerBus.scala:<span class="number">65</span>)</span><br><span class="line">at scala.util.DynamicVariable.withValue (DynamicVariable.scala:<span class="number">57</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>$$anonfun$run$<span class="number">1</span>.apply$mcV$sp (AsynchronousListenerBus.scala:<span class="number">64</span>)</span><br><span class="line">at org.apache.spark.util.Utils$.tryOrStopSparkContext (Utils.scala:<span class="number">1181</span>)</span><br><span class="line">at org.apache.spark.util.AsynchronousListenerBus$$anon$<span class="number">1</span>.run (AsynchronousListenerBus.scala:<span class="number">63</span>)</span><br><span class="line">Caused by: java.io.IOException: Filesystem closed</span><br><span class="line">at org.apache.hadoop.hdfs.DFSClient.checkOpen (DFSClient.java:<span class="number">795</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DFSOutputStream.flushOrSync (DFSOutputStream.java:<span class="number">1986</span>)</span><br><span class="line">at org.apache.hadoop.hdfs.DFSOutputStream.hflush (DFSOutputStream.java:<span class="number">1947</span>)</span><br><span class="line">at org.apache.hadoop.fs.FSDataOutputStream.hflush (FSDataOutputStream.java:<span class="number">130</span>)</span><br><span class="line">... <span class="number">20</span> more</span><br></pre></td></tr></table></figure><p>最直接清晰的描述就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.io.IOException: Filesystem closed</span><br></pre></td></tr></table></figure><p>上述异常信息表明 HDFS 的 Filesystem 被关闭了，但是代码仍旧试图打开文件流读取内容。</p><h1 id="问题解决"><a href="# 问题解决" class="headerlink" title="问题解决"></a>问题解决 </h1><h2 id="分析一下"><a href="# 分析一下" class="headerlink" title="分析一下"></a> 分析一下 </h2><p> 根据上述信息，查看代码，每次操作 HDFS 都是独立的，会先根据统一的 conf 创建 Filesystem，然后根据文件路径创建 Path，打开输入流，读取内容，读取完成后关闭 Filesystem，没有什么异常的地方。</p><p>同时，根据异常信息可以发现，异常的抛出点并不是业务逻辑代码，更像是已经开始开启文件流读取文件，读着读着 Filesystem 就被关闭了，然后引发了异常，而业务逻辑中并没有突然关闭 Filesystem 的地方，也没有多线程操作 Filesystem 的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文件内容 </span></span><br><span class="line"><span class="comment"> * 纯文本，不做转换 </span></span><br><span class="line"><span class="comment"> * 如果传入目录，返回空内容 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hdfsFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">getFileContent</span><span class="params">(String hdfsFile)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; dataResult = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    FileSystem fs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 连接 hdfs</span></span><br><span class="line">        fs = FileSystem.get (CONF);</span><br><span class="line">        Path path = <span class="keyword">new</span> Path (hdfsFile);</span><br><span class="line">        <span class="keyword">if</span> (fs.isFile (path)) &#123;</span><br><span class="line">            FSDataInputStream fsDataInputStream = fs.open (path);</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader (<span class="keyword">new</span> InputStreamReader (fsDataInputStream));</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != (line = bufferedReader.readLine ())) &#123;</span><br><span class="line">                dataResult.add (line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGGER.error (<span class="string">"!!!! 当前输入参数为目录，不读取内容:&#123;&#125;"</span>, hdfsFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error (<span class="string">"!!!! 处理 hdfs 出错:"</span> + e.getMessage (), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != fs) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fs.close ();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LOGGER.error (<span class="string">"!!!! 关闭文件流出错:"</span> + e.getMessage (), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查找文档发现，这个异常是 Filesystem 的缓存导致的。</p><p>当任务提交到集群上面以后，多个 datanode 在 getFileSystem 过程中，由于 Configuration 一样，会得到同一个 FileSystem。如果有一个 datanode 在使用完关闭连接，其它的 datanode 在访问时就会出现上述异常，导致数据缺失（如果数据恰好只存在一个 datanode 上面，可能没问题）。</p><h2 id="找到方法"><a href="# 找到方法" class="headerlink" title="找到方法"></a>找到方法 </h2><p> 通过上面的分析，找到了原因所在，那么解决方法有 2 种：</p><p>1、可以在 HDFS 的 core-site.xml 配置文件里面把 fs.hdfs.impl.disable.cache 设置为 true，这样设置会全局生效，所有使用这个配置文件的连接都会使用这种方式，有时候可能不想这样更改，那就使用第 2 种方式；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.hdfs.impl.disable.cache<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、在 HDFS 提供的 Java api 里面更改配置信息，则会只针对使用当前 conf 的连接有效，相当于临时参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存 fs, 避免多 datanode 异常：Caused by: java.io.IOException: Filesystem closed</span></span><br><span class="line">CONF.setBoolean (<span class="string">"fs.hdfs.impl.disable.cache"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>上面 2 种方法的目的都是为了关闭缓存 Filesyetem 实例，这样每次获得的 Filesystem 实例都是独立的，不会产生上述的异常，但是缺点就是会增加网络的 I/O，频繁开启、关闭文件流。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><p>1、参考：<a href="https://stackoverflow.com/questions/23779186/ioexception-filesystem-closed-exception-when-running-oozie-workflow" target="_blank" rel="noopener">https://stackoverflow.com/questions/23779186/ioexception-filesystem-closed-exception-when-running-oozie-workflow</a> ；</p><p>2、保留日志，查看日志很重要；</p><p>3、FileSytem 类内部有一个 static CACHE，用来保存每种文件系统的实例集合，FileSystem 类中可以通过参数 fs.% s.impl.disable.cache 来指定是否禁用缓存 FileSystem 实例（其中 % s 替换为相应的 scheme，比如 hdfs、local、s3、s3n 等）。如果没禁用，一旦创建了相应的 FileSystem 实例，这个实例将会保存在缓存中，此后每次 get 都会获取同一个实例，但是如果被关闭了，则再次用到就会无法获取（多 datanode 读取数据的时候）；</p><p>4、源码分析放在以后，留坑。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:49 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天通过 Hadoop 的 api 去操作 HDFS 里面的文件，读取文本内容，但是在代码里面总是抛出以下异常：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Caused by: java.io.IOException: Filesystem closed&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然而文本内容又是正常读取出来的，但是我隐隐觉得读取的文本内容可能不全，应该只是所有文本内容的一部分。本文就记录这个问题的原因、影响以及解决方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Hadoop 从零基础到入门系列" scheme="https://www.playpi.org/categories/series-of-hadoop/"/>
    
    
      <category term="Hadoop" scheme="https://www.playpi.org/tags/Hadoop/"/>
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="Filesystem" scheme="https://www.playpi.org/tags/Filesystem/"/>
    
      <category term="HDFS" scheme="https://www.playpi.org/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>可乐鸡翅做法总结</title>
    <link href="https://www.playpi.org/2018122501.html"/>
    <id>https://www.playpi.org/2018122501.html</id>
    <published>2018-12-24T17:36:37.000Z</published>
    <updated>2018-12-25T17:36:37.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>可乐鸡翅，是一道做法很简单的菜，很巧妙地将饮料和鸡翅结合在一起，做出来的可乐鸡翅既好看又好吃。本文简单介绍可乐鸡翅的做法总结，这是一种偏甜的做法。</p><a id="more"></a><h1 id="食材准备"><a href="# 食材准备" class="headerlink" title="食材准备"></a>食材准备 </h1><p>3 人份的材料（8-10 个鸡翅），吃多了也不好吃</p><p>1、鸡翅 9 个，最好是鸡中翅（一般 2-3 元一个）；</p><p>2、可乐 1 罐（330 毫升的，如果鸡翅多的话，适当增加可乐）；</p><p> 选择百事可乐 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz0rg4ht5bj229s29shbr.jpg" alt="百事可乐一罐" title="百事可乐一罐"></p><p>3、姜片、八角、桂皮（也可以不用）；</p><p>4、料酒、生抽、老抽、食用盐；</p><h1 id="制作步骤"><a href="# 制作步骤" class="headerlink" title="制作步骤"></a> 制作步骤 </h1><p>1、在鸡翅背面划几刀（正面保留完整为了摆盘好看而已），更容易入味，用食用盐、料酒、老抽腌制 10 分钟，备用；</p><p> 划刀腌制 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz0rh3a3lzj229s29s7wi.jpg" alt="划刀腌制" title="划刀腌制"></p><p>2、锅中加水，放入姜片、少量料酒，鸡翅也下锅（冷水下锅），煮开即可，不用煮透（煮透鸡翅就老了），看到浮沫很多就可以捞出，用温水清洗一下，晾干（晾不干就用厨房纸擦一下，防止煎的时候溅油），此时如果发现有不干净的鸡毛可以拔干净；</p><p> 鸡翅冷水下锅 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz0rhqcl9lj229s29skjl.jpg" alt="鸡翅冷水下锅" title="鸡翅冷水下锅"></p><p> 鸡翅焯水出浮沫 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz0riaxvy9j229s29shdu.jpg" alt="鸡翅焯水出浮沫" title="鸡翅焯水出浮沫"></p><p>3、锅中放入少量油（不放也行，鸡翅会自己出油的），放入姜片，开始煎鸡翅，开小火，煎至两面金黄即可，不可以煎太久，否则鸡翅老了不好吃；</p><p> 小火煎 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz0riy1se2j22ao328e81.jpg" alt="小火煎" title="小火煎"></p><p>4、加一罐可乐，适量料酒、生抽、老抽，适量桂皮、八角，开始小火炖煮，炖至可乐还有一小碗水的量的时候，尝尝味道，适量加盐；</p><p> 加入可乐、配料 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz0rjpt2asj22ao328b29.jpg" alt="加入可乐" title="加入可乐"></p><p> 小火炖煮 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz0rlapea0j229s29su0y.jpg" alt="小火炖煮" title="小火炖煮"></p><p>5、炖至汤浓收汁，基本所有的汁都覆盖在鸡翅上面了，鸡翅也有味道，装盘，正面朝上，把锅中剩余的汤汁淋入鸡翅中（大概 1-2 饭勺的量），再撒上少许白芝麻，既好看又好吃。</p><p> 可以收汁 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz0rlzom65j229s29su0y.jpg" alt="可以收汁" title="可以收汁"></p><p> 收汁之前补充食用盐、老抽 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz0rm8gegzj229s29sqv6.jpg" alt="收汁之前补充食用盐、老抽" title="收汁之前补充食用盐、老抽"></p><p> 收汁完成 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz0rm3rj6xj229s29se82.jpg" alt="收汁完成" title="收汁完成"></p><p> 装盘 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fz0rmcq1luj229s29s7wi.jpg" alt="装盘" title="装盘"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项</h1><p>1、不要再放糖了，一罐可乐里面含糖大概 35 克；</p><p>2、如果放了那种本身是咸味的生抽，也不用放盐了，或者少量放一点点（放盐之前先尝尝汤水的味道，不容易出差错）；</p><p>3、焯水的时候冷水下锅，防止肉老了，并且放一点姜片和料酒，去腥味；</p><p>4、鸡翅焯水后晾干很有必要，否则下一步骤煎的时候水和热油混合一起会溅出油的；</p><p>5、甜味和咸味的控制依据个人口味调整，此外，可口可乐比百事可乐更甜，即含糖量更高。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;可乐鸡翅，是一道做法很简单的菜，很巧妙地将饮料和鸡翅结合在一起，做出来的可乐鸡翅既好看又好吃。本文简单介绍可乐鸡翅的做法总结，这是一种偏甜的做法。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="可乐鸡翅" scheme="https://www.playpi.org/tags/%E5%8F%AF%E4%B9%90%E9%B8%A1%E7%BF%85/"/>
    
  </entry>
  
  <entry>
    <title>Spark 错误之 JavaSparkContext not serializable</title>
    <link href="https://www.playpi.org/2018122101.html"/>
    <id>https://www.playpi.org/2018122101.html</id>
    <published>2018-12-20T16:43:50.000Z</published>
    <updated>2018-12-20T16:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>今天更新代码，对 Spark 里面的 RDD 随便增加了一个 Function，结果遇到了序列化（Serializable）的问题，这个不是普通的自定义类不能序列化问题，而是 JavaSparkContext 的用法问题，由于小看了这个问题，多花了一点时间解决问题，本文就记录下这一过程。</p><a id="more"></a><h1 id="问题出现"><a href="# 问题出现" class="headerlink" title="问题出现"></a>问题出现 </h1><p> 针对已有的项目改动了一点点，结果直接出现了这个错误：</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fydoetmx57j21gx0hjgph.jpg" alt="日志报错" title="日志报错"></p><p>一开始疏忽大意了，以为像往常一样，是某些需要传递的对象对应的类没有序列化，由于对代码不敢改动太大，就想着用最简单的方法，把几个自定义类都序列化了，以为就应该可以了。结果，还是不行，此时虽然不会有自定义类的序列化问题了，但是却出现了终极错误：JavaSparkContext not serializable，这是什么意思呢，是说 JavaSparkContext 不能序列化，总不能把 JavaSparkContext 序列化吧，Spark 是不允许这么干的。</p><p>那么问题是什么呢？我首先猜测肯定是 Function 里面用到了 JavaSparkContext 对象，导致启动 Spark 任务的时候，需要序列化 Function 用到的所有对象（当然也需要序列化对象所属类里面的所有属性），而这些 Function 所用到的所有对象里面，就有 JavaSparkContext 对象。于是，我耐心看了一下代码，果然，在创建 Function 对象的时候，竟然把 JavaSparkContext 对象作为参数传进去了，还是因为 JavaSparkContext 不能乱用。</p><p>其实，报错日志里面都已经明显指向说明了，除了自定义的类，错误归结于 <br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at org.apache.spark.api.java.AbstractJavaRDDLike.mapPartitions (JavaRDDLike.scala:<span class="number">46</span>)</span><br></pre></td></tr></table></figure><p></p><p> 而这里的代码，正是我增加的一部分，为了贪图简单方便，直接把 JavaSparkContext 对象传递给了 mapPartitions 对应的 Function。</p><h1 id="解决问题"><a href="# 解决问题" class="headerlink" title="解决问题"></a>解决问题 </h1><p> 既然找到了问题，接下来就好办了。既然 JavaSparkContext 不能乱用，那就不用，把这个传递参数去掉，即可正常运行，但是这样做太简单粗暴，不是解决问题的思路。仔细分析一下，可以有 2 种解决办法（思路就是避免序列化）：</p><p>1、如果在 Function 里面非要用到 JavaSparkContext 对象，那就把 JavaSparkContext 对象设置为全局静态的 Java 属性（使用 static 关键字），那么在哪里都可以调用它了，而无需担心序列化的问题（静态属性可以避免从 Driver 端发送到 Executor 端，从而避免了序列化过程）；</p><p>2、对于 Function 不要使用内部匿名类，这样必然需要序列化 Function 对象，同时也必然需要序列化 Function 对象用到的 JavaSparkContext 对象，其实可以把 Function 类定义为内部静态类，就可以避免序列化了。</p><h1 id="问题总结"><a href="# 问题总结" class="headerlink" title="问题总结"></a>问题总结 </h1><p>1、出现这种错误，不要想当然地认为就是某种原因造成的，而要先看详细日志，否则会走弯路，浪费一些时间（虽然最终也能解决问题）；</p><p>2、有时候状态不好，晕乎乎的，找问题又慢又低效，此时应该休息一下，等头脑清醒了再继续找问题，否则可能事倍功半，而且影响心情。</p><p> 参考：<a href="https://stackoverflow.com/questions/27706813/javasparkcontext-not-serializable" target="_blank" rel="noopener">https://stackoverflow.com/questions/27706813/javasparkcontext-not-serializable</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天更新代码，对 Spark 里面的 RDD 随便增加了一个 Function，结果遇到了序列化（Serializable）的问题，这个不是普通的自定义类不能序列化问题，而是 JavaSparkContext 的用法问题，由于小看了这个问题，多花了一点时间解决问题，本文就记录下这一过程。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="Spark序列化" scheme="https://www.playpi.org/tags/Spark%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="serializable" scheme="https://www.playpi.org/tags/serializable/"/>
    
  </entry>
  
  <entry>
    <title>微博 url mid 相互转换算法实现 - Java 版本</title>
    <link href="https://www.playpi.org/2018122001.html"/>
    <id>https://www.playpi.org/2018122001.html</id>
    <published>2018-12-20T15:29:13.000Z</published>
    <updated>2018-12-20T15:29:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p> 对微博数据有了解的人都知道，一条微博内容对应有唯一的微博 url，同时对微博官方来说，又会生成一个 mid，mid 就是一条微博的唯一标识（就像 uid 是微博用户的唯一标识一样），也类似于人的身份证号。其实，微博 url 里面有一串看起来无意义的字符（由字母、数字组成，6-8 个字符长度），可以和 mid 互相转换，本文就根据理论以及 Java 版本的实现，讲解微博 url 与 mid 的互相转换过程。</p><a id="more"></a><p> 待整理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;对微博数据有了解的人都知道，一条微博内容对应有唯一的微博 url，同时对微博官方来说，又会生成一个 mid，mid 就是一条微博的唯一标识（就像 uid 是微博用户的唯一标识一样），也类似于人的身份证号。其实，微博 url 里面有一串看起来无意义的字符（由字母、数字组成，6-8 个字符长度），可以和 mid 互相转换，本文就根据理论以及 Java 版本的实现，讲解微博 url 与 mid 的互相转换过程。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="微博url" scheme="https://www.playpi.org/tags/%E5%BE%AE%E5%8D%9Aurl/"/>
    
      <category term="微博mid" scheme="https://www.playpi.org/tags/%E5%BE%AE%E5%8D%9Amid/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中字符串截取方法总结</title>
    <link href="https://www.playpi.org/2018121901.html"/>
    <id>https://www.playpi.org/2018121901.html</id>
    <published>2018-12-18T16:31:19.000Z</published>
    <updated>2018-12-18T16:31:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:49 GMT+0800 (China Standard Time) --><p>最近在处理数据的时候，用到了 JavaScript 编程语言，通过绕弯路来解决 ETL 处理的逻辑，其中就用到了字符串的截取方法，查 JavaScript 的文档看到了 3 个方法，被绕的有点晕，本文就总结一下 JavaScript 中字符串截取的方法。</p><a id="more"></a><h1 id="开篇"><a href="# 开篇" class="headerlink" title="开篇"></a>开篇 </h1><p> 首先声明，JavaScript 中对方法名字的大小写是敏感的，该是小写就是小写，该是大写就是大写。</p><h1 id="substring- 方法"><a href="#substring- 方法" class="headerlink" title="substring () 方法"></a>substring () 方法 </h1><h2 id="定义和用法"><a href="# 定义和用法" class="headerlink" title="定义和用法"></a> 定义和用法 </h2><blockquote><p>substring () 方法用于截取字符串中介于两个指定下标之间的字符</p></blockquote><h2 id="语法"><a href="# 语法" class="headerlink" title="语法"></a> 语法 </h2><blockquote><p>stringObject.substring (start, stop)</p></blockquote><p> 上述参数解释：</p><table><thead><tr><th style="text-align:center">参数名 </th><th style="text-align:center"> 解释说明 </th></tr></thead><tbody><tr><td style="text-align:center">start</td><td style="text-align:center"> 必须，一个整数（是负数则被自动置为 0），要截取的子串的第一个字符在 stringObject 中的位置 </td></tr><tr><td style="text-align:center">end</td><td style="text-align:center"> 可选（如果省略该参数，则被默认为字符串长度），一个整数（是负数则被自动置为 0），比要截取的子串的最后一个字符在 stringObject 中的位置多 1</td></tr></tbody></table><h2 id="返回值"><a href="# 返回值" class="headerlink" title="返回值"></a>返回值 </h2><p> 一个全新的字符串，其实就是 stringObject 的一个子字符串，其内容是从 start 到 stop-1 的所有字符，其长度为 stop 减 start。</p><h2 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a>注意事项 </h2><p>1、substring () 方法返回的子字符串包括 start 处的字符，但是不包括 stop 处的字符，这一点可能很多人会迷惑，其实很多编程语言都是这个逻辑；</p><p>2、如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串，不是 null，也不是 undefined）；</p><p>3、如果 start 比 stop 大，那么该方法在截取子串之前会先交换这两个参数，这就会导致参数的顺序不影响截取的结果了；</p><p>4、参数理论上不能出现负数（在本方法中无特殊意义，在其它方法中就有特殊意义了），如果有，那么在截取子串之前会被置为 0。</p><h2 id="举例说明"><a href="# 举例说明" class="headerlink" title="举例说明"></a> 举例说明 </h2><p><strong> 例子 1（从下标 3 截取到字符串最后）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write (str.substring (<span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 10 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-world!</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 2（从下标 3 截取到下标 8）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write (str.substring (<span class="number">3</span>, <span class="number">8</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 5 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 3（从下标 3 截取到下标 8，但是参数位置反了）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write (str.substring (<span class="number">8</span>, <span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 5 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 4（参数为负数，从下标 0 截取到下标 3）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write (str.substring (<span class="number">-1</span>, <span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 3 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hel</span><br></pre></td></tr></table></figure><p></p><h1 id="substr- 方法"><a href="#substr- 方法" class="headerlink" title="substr () 方法"></a>substr () 方法 </h1><h2 id="定义和用法 -1"><a href="# 定义和用法 -1" class="headerlink" title="定义和用法"></a> 定义和用法 </h2><blockquote><p>substr () 方法可在字符串中截取从 start 下标开始的指定长度的子串</p></blockquote><h2 id="语法 -1"><a href="# 语法 -1" class="headerlink" title="语法"></a> 语法 </h2><blockquote><p>stringObject.substr (start, length)</p></blockquote><p> 上述参数解释：</p><table><thead><tr><th style="text-align:center">参数名 </th><th style="text-align:center"> 解释说明 </th></tr></thead><tbody><tr><td style="text-align:center">start</td><td style="text-align:center"> 必须，必须是数值（0、正数、负数都可以），表示要截取的子串的起始下标。如果是负数，那么该参数声明的是从字符串的尾部开始计算的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。（参数为负数也可以理解成字符串长度加负数之和即为起始下标）</td></tr><tr><td style="text-align:center">length</td><td style="text-align:center">可选（如果省略该参数，那么默认为从 start 开始一直到 stringObject 的结尾对应的长度），必须是数值（0、正数、负数都可以）。</td></tr></tbody></table><h2 id="返回值 -1"><a href="# 返回值 -1" class="headerlink" title="返回值"></a>返回值 </h2><p> 一个全新的字符串，包含从 stringObject 的 start（包括 start 所指的字符）下标开始的 length 个字符。如果没有指定 length，那么返回的字符串包含从 start 到 stringObject 的结尾的字符。如果 length 指定为负数或者 0，那么返回空串。如果 length 指定为远远大于 stringObject 长度的正数，那么返回的字符串包含从 start 到 stringObject 的结尾的字符。</p><h2 id="注意事项 -1"><a href="# 注意事项 -1" class="headerlink" title="注意事项"></a>注意事项 </h2><p>1、start 参数为负数是有特殊含义的；</p><p>2、如果 length 指定为负数或者 0，那么返回空串（即长度为 0 的字符串，不是 null，也不是 undefined）；</p><p>3、ECMAscript 没有对该方法进行标准化，因此不建议使用它。</p><h2 id="举例说明 -1"><a href="# 举例说明 -1" class="headerlink" title="举例说明"></a> 举例说明 </h2><p><strong> 例子 1（从下标 3 截取到字符串最后）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write (str.substr (<span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 9 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-world!</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 2（从下标 3 截取长度为 5 的子串）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write (str.substr (<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 5 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 3（从下标 3 截取长度为 - 5 的子串，返回空串）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write (str.substr (<span class="number">3</span>, <span class="number">-5</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（返回空串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p><strong>例子 4（start 参数为负数，即从字符串倒数第 5 个位置截取长度为 3 的子串）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write (str.substr (<span class="number">-5</span>, <span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 3 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orl</span><br></pre></td></tr></table></figure><p></p><h1 id="slice- 方法"><a href="#slice- 方法" class="headerlink" title="slice () 方法"></a>slice () 方法 </h1><h2 id="定义和用法 -2"><a href="# 定义和用法 -2" class="headerlink" title="定义和用法"></a> 定义和用法 </h2><blockquote><p>slice () 方法用于截取字符串中介于两个指定下标之间的字符，与 substring () 方法的功能类似</p></blockquote><h2 id="语法 -2"><a href="# 语法 -2" class="headerlink" title="语法"></a> 语法 </h2><blockquote><p>stringObject.slice (start, end)</p></blockquote><p> 上述参数解释：</p><table><thead><tr><th style="text-align:center">参数名 </th><th style="text-align:center"> 解释说明 </th></tr></thead><tbody><tr><td style="text-align:center">start</td><td style="text-align:center"> 必须，一个整数（0、正数、负数，负数有特殊含义），要截取的子串的第一个字符在 stringObject 中的位置。如果是负数，那么该参数声明的是从字符串的尾部开始计算的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。（参数为负数也可以理解成字符串长度加负数之和即为起始下标）</td></tr><tr><td style="text-align:center">end</td><td style="text-align:center">可选（如果省略该参数，则被默认为字符串长度），一个整数（负数含义与 start 相同），比要截取的子串的最后一个字符在 stringObject 中的位置多 1</td></tr></tbody></table><h2 id="返回值 -2"><a href="# 返回值 -2" class="headerlink" title="返回值"></a>返回值 </h2><p> 一个全新的字符串，其实就是 stringObject 的一个子字符串，其内容是从 start 到 stop-1 的所有字符，其长度为 stop 减 start。</p><h2 id="注意事项 -2"><a href="# 注意事项 -2" class="headerlink" title="注意事项"></a>注意事项 </h2><p>1、slice () 方法返回的子字符串包括 start 处的字符，但是不包括 stop 处的字符，这一点可能很多人会迷惑，其实很多编程语言都是这个逻辑；</p><p>2、如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串，不是 null，也不是 undefined）；</p><p>3、参数可以出现负数（比 substring () 方法灵活多了）。</p><h2 id="举例说明 -2"><a href="# 举例说明 -2" class="headerlink" title="举例说明"></a> 举例说明 </h2><p><strong> 例子 1（从下标 3 截取到字符串最后）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write (str.slice (<span class="number">3</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出（长度为 9 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-world!</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 2（从下标 3 截取到下标 8）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write (str.slice (<span class="number">3</span>, <span class="number">8</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 5 的子串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 3（从下标 3 截取到下标 8，但是参数使用负数，从下标 - 9 截取到下标 - 4）：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write (str.slice (<span class="number">-9</span>, <span class="number">-4</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>输出（长度为 5 的子串，（-4）-（-9）=5）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lo-wo</span><br></pre></td></tr></table></figure><p></p><p><strong>例子 4（从下标 3 截取到下标 2）：</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"Hello-world!"</span></span><br><span class="line"><span class="built_in">document</span>.write (str.slice (<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>输出返回空串）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:49 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;最近在处理数据的时候，用到了 JavaScript 编程语言，通过绕弯路来解决 ETL 处理的逻辑，其中就用到了字符串的截取方法，查 JavaScript 的文档看到了 3 个方法，被绕的有点晕，本文就总结一下 JavaScript 中字符串截取的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="JavaScript" scheme="https://www.playpi.org/tags/JavaScript/"/>
    
      <category term="字符串截取" scheme="https://www.playpi.org/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>西红柿疙瘩汤做法总结</title>
    <link href="https://www.playpi.org/2018121601.html"/>
    <id>https://www.playpi.org/2018121601.html</id>
    <published>2018-12-15T17:57:00.000Z</published>
    <updated>2018-12-16T17:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>西红柿疙瘩汤，是一道做法非常简单的主食与配菜混为一起的菜品，适合在寒冷的冬天食用，吃一碗热乎乎的，非常暖胃，我知道在中原地区（河南、安徽北部）都有这个做法。本文就讲述西红柿疙瘩汤的做法总结。</p><a id="more"></a><h1 id="食材准备"><a href="# 食材准备" class="headerlink" title="食材准备"></a>食材准备 </h1><p> 以下的食材份量大约 2 人份：</p><ul><li>黄心乌菜一颗（实在没有使用其它青菜也可以）</li><li>西红柿一颗（粉的最好，与脆的对立）</li><li>鸡蛋 2 颗 </li><li> 面粉 100 克 </li><li> 小葱、香菜各 2 棵 </li><li> 调味料（食用盐、芝麻油）</li></ul><h1 id="制作步骤"><a href="# 制作步骤" class="headerlink" title="制作步骤"></a>制作步骤 </h1><p> 从开火到关火预计耗时 15-20 分钟：</p><p>0、葱花香菜段；<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5zv7hnmj229s29s4qq.jpg" alt="葱花香菜段" title="葱花香菜段"></p><p>1、西红柿去皮，划十字刀花，放入热水中烫 1 分钟左右，取出直接去皮，不去皮也行，但是会影响口感，去皮后切丁，切小一点，放入碗中备用；</p><p>粉粉的西红柿 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5kxue8tj229s29se81.jpg" alt="一颗西红柿" title="一颗西红柿"></p><p> 十字花刀 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwaageagj229s29shdt.jpg" alt="十字花刀" title="十字花刀"></p><p> 开水烫 1 分钟（30 秒翻身一次），轻易去皮 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwbgrggsj229s29shdt.jpg" alt="开水烫 1 分钟" title="开水烫 1 分钟"></p><p> 西红柿去皮 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwc37dlbj229s29sb2a.jpg" alt="西红柿去皮" title="西红柿去皮"></p><p> 西红柿切丁 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwcm3w8nj229s29s4qq.jpg" alt="西红柿切丁" title="西红柿切丁"></p><p>2、准备黄心乌菜，洗干净，随便切（手撕也行，无所谓），切成条状或者小块状，别太大就行；<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyp2f1kua2j229s29skjl.jpg" alt="黄心乌长这样" title="黄心乌长这样"></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5m1xtc6j229s29su0x.jpg" alt="黄心乌切碎" title="黄心乌切碎"></p><p>3、面粉放入大碗中，放在水龙头下，让水一滴一滴滴下来，迅速搅拌面粉，很快就可以做成面粒；<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5otcr3mj229s29s7wi.jpg" alt="面粒长这样" title="面粒长这样"></p><p>4、鸡蛋打入碗中，搅拌均匀备用；</p><p>5、锅烧热，倒入油，炒制西红柿丁，中小火炒制 3-5 分钟，此时西红柿的状态就是一半是糊状，一半是小颗粒，混合在一起，倒入开水（注意量的控制，比想象的多倒一点，面粒会吸收大量水分的），大火烧开；</p><p> 西红柿丁炒制 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwi298lzj229s29snpe.jpg" alt="西红柿丁炒制" title="西红柿丁炒制"></p><p> 加开水，煮开 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwinvlclj229s29s4qq.jpg" alt="加开水" title="加开水"></p><p>6、烧开后放入面粒，大火煮 5 分钟，面粒基本熟透，汤变得浓稠，放入青菜，中火继续煮 1 分钟左右，鸡蛋液慢慢淋入锅中，搅拌，放入食用盐，中火继续煮 2 分钟；</p><p> 放入面粒，继续煮 5 分钟 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwjke2u4j229s29s7wi.jpg" alt="放入面粒" title="放入面粒"></p><p>7、开锅，放入芝麻油、香菜段，葱花，搅拌十几秒，关火。</p><p> 一锅 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy94yo4wibj229s29snpd.jpg" alt="一锅" title="一锅"></p><p> 一碗 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya5xkeysqj229s29shdt.jpg" alt="一碗" title="一碗"></p><p> 做完顺便又加了 2 个菜：<br>花菜回锅肉 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya60u5iacj229s29se81.jpg" alt="花菜回锅肉" title="花菜回锅肉"></p><p> 辣椒回锅肉 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya61058ppj229s29su0x.jpg" alt="辣椒回锅肉" title="辣椒回锅肉"></p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项 </h1><p>1、青菜最好选择黄心乌，因为我一直吃的都是这种，黄心乌这种青菜一般在沿淮地区才播种，因为它比较耐寒，在秋季播种，在冬天收割，一般北方的冬天也看不到其它青菜可以生长了；</p><p>2、条件允许的话，可以放一点酱肉之类的肉粒进去，更能增加食欲；</p><p>3、做面粒的时候切记不要直接倒水搅拌，这样是做不成的一粒一粒的效果的，只能用水滴进去然后迅速搅拌，使水滴周围裹上面粉形成一粒，很快就全部都是面粒了，而且很均匀，另外，做好面粒后要立马使用，不要提前做好放那里，因为放久了（10 分钟都不行）面粒会粘连在一起，实在要放的话再多加点面粉进去，让面粒之间隔开；</p><p>4、西红柿最好选择粉的，就是那种吃起来很柔绵的，更容易做成均匀的汤；</p><p>5、如果在煮的过程中发现有点粘锅，那是因为水少了，面太多了，这时候用汤勺试着加 1-2 勺水进去，再搅拌一下，如果还是粘锅再加 1-2 勺，千万不要一下子加很多水，面汤最好的状态就是不粘锅但是又很浓稠；</p><p>6、做回锅肉，肉要煮到什么程度才能回锅，简单的判断方法就是筷子可以轻易穿透肉，一般要煮 20 分钟以上。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fya63x2errj229s29snpd.jpg" alt="肉回锅之前" title="肉回锅之前"></p><h1 id="补充说明"><a href="# 补充说明" class="headerlink" title="补充说明"></a> 补充说明</h1><p>2018 年 12 月 23 日，广州突然降温，降到 17 度左右（前一天的冬至还 25 度呢，短袖都穿起来了），天气冷了，于是又煮了一锅。可惜这次没买到香菜，没买到黄心乌菜，也没买到酱肉，凑活着吃。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fyiauqznd7j229s29sx6p.jpg" alt="2018 年 12 月 23 日又煮了一锅" title="2018 年 12 月 23 日又煮了一锅"></p><p>2018 年 12 月 30 日，广州的温度降到了个位数，最低 5 度，实在是冷。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fypwm9ud6ij229s29shdt.jpg" alt="2018 年 12 月 31 日" title="2018 年 12 月 31 日"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;西红柿疙瘩汤，是一道做法非常简单的主食与配菜混为一起的菜品，适合在寒冷的冬天食用，吃一碗热乎乎的，非常暖胃，我知道在中原地区（河南、安徽北部）都有这个做法。本文就讲述西红柿疙瘩汤的做法总结。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="西红柿疙瘩汤" scheme="https://www.playpi.org/tags/%E8%A5%BF%E7%BA%A2%E6%9F%BF%E7%96%99%E7%98%A9%E6%B1%A4/"/>
    
      <category term="疙瘩汤" scheme="https://www.playpi.org/tags/%E7%96%99%E7%98%A9%E6%B1%A4/"/>
    
  </entry>
  
  <entry>
    <title>常用正则表达式列表</title>
    <link href="https://www.playpi.org/2018121401.html"/>
    <id>https://www.playpi.org/2018121401.html</id>
    <published>2018-12-13T18:18:48.000Z</published>
    <updated>2018-12-14T18:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p> 正则表达式是一种表达式语句。本文记录一些常用的正则表达式，以便使用。</p><a id="more"></a><p> 待整理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;正则表达式是一种表达式语句。本文记录一些常用的正则表达式，以便使用。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="正则表达式" scheme="https://www.playpi.org/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>与微博内容分析相关的正则表达式</title>
    <link href="https://www.playpi.org/2018121101.html"/>
    <id>https://www.playpi.org/2018121101.html</id>
    <published>2018-12-11T14:16:19.000Z</published>
    <updated>2018-12-11T14:16:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>在分析微博内容时，常常需要进行特殊内容去除与抽取，例如抽取微博话题、微博昵称、微博表情、微博短链接、网址长链接等等。本文依据实际使用情况，记录下了与微博内容分析相关的正则表达式，以便查用。</p><a id="more"></a><h1 id="微博表情"><a href="# 微博表情" class="headerlink" title="微博表情"></a>微博表情 </h1><p> 表情是使用左右中括号包含的文本（在实际使用时，显示的是 emoji 表情，不是单纯的字符），例如：[爱心]、[微笑]、[笑哭]，分别表示：:heart:、❤️、:smile:、😊、:joy:、😂</p><p>参考：<a href="https://emojipedia.org" target="_blank" rel="noopener">emoji 百科 </a> 。</p><p> 如果在微博内容中抽取表情，使用正则表达式（1-7 个字符，中文和字母，不排除有的新的表情出现，导致字符更长）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[[\u4e00-\u9fa5A-Za-z]&#123;1,7&#125;\]</span><br></pre></td></tr></table></figure><p>不同字符长度的表情举例（我用了 10 分钟把微博表情全部浏览了一遍，发现 [小黄人] 系列、[文明遛狗] 是最近刚刚发布出来的）：[耶]、[来]、[跪了]、[ok]、[中国赞]、[紫金草]、[doge]、[文明遛狗]、[给你小心心]、[小黄人微笑]、[弗莱见钱眼开]、[小黄人剪刀手]、[哆啦 A 梦害怕]、[带着微博去旅行]。</p><h1 id="微博昵称"><a href="# 微博昵称" class="headerlink" title="微博昵称"></a>微博昵称 </h1><p> 微博昵称是用户填写的昵称，并且在转发或者提到时，会增加 @ 前缀，例如有一个 playpi 微博用户，在实际微博内容中，会以 @playpi 的形式出现，当然，微博昵称的可用字符是有限制的，不是任意字符都行，长度也是有限制的，最少 4 个字符，最多 30 个字符。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy6r1bwv0xj20mi082dfy.jpg" alt="微博昵称字符限制" title="微博昵称字符限制"></p><p>以及微博客服的回答：<a href="https://www.weibo.com/2016713117/FCf87jJZt?type=comment#_rnd1544860586591" target="_blank" rel="noopener">微博客服微博 </a> 。</p><p> 但是这个规则是针对修改昵称的限制，如果有些帐号是以前注册的，并且昵称在微博官方限制以前没有修改过，那么就有可能是 2 个字符，3 个字符，例如各个明星、作家、自媒体的个人微博：@阑夕、@王力宏、@韩寒 等等。</p><p>如果在微博内容中抽取昵称，使用正则表达式（中文、数字、字母、横线、下划线的组合，2-30 个字符）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@[\u4e00-\u9fa5A-Z0-9a-z_-]&#123;2,30&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="微博话题"><a href="# 微博话题" class="headerlink" title="微博话题"></a>微博话题 </h1><p> 话题是微博定义的一种概念，可以用来标识热门事件、重大新闻、明星、综艺节目等等，发布规则就是使用 2 个 #符号包含话题内容（例如：# 创造 101#），话题即生成，微博还专门有一个实时话题榜单。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy6ro4qztbj20v40q2doc.jpg" alt="微博话题榜" title="微博话题榜"></p><p>如果在微博内容中抽取话题，使用正则表达式（2 个 #号之间，非指定的符号，长度在 1-49 之间）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[^@&lt;&gt;#"&amp;'\r\n\t]&#123;1,49&#125;#</span></span><br></pre></td></tr></table></figure><p></p><p>注意，我找到 2014 年的 <a href="https://iask.sina.com.cn/b/wnINuLfme5.html" target="_blank" rel="noopener">一篇旧帖子 </a>，微博小秘书评论说话题不能包含指定的几个特殊字符，还有内容长度限制，但是我在微博页面试了一下，这些特殊字符都可以使用（但是生成的话题页面，&lt; 字符、&gt; 字符被转成了 html 字符实体，换行符后的内容被截断，@符号、’ 单引号、” 双引号被自动替换掉，# 符号根本无法发布，空格符可以正常使用），而且长度限制是 1-49 个字符（中英文、标点都算 1 个字符）。但是为了话题内容的传播，还是使用通俗易懂的中文或者字母比较好。</p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy6s5061rxj20gv03uwei.jpg" alt="话题测试发布" title="话题测试发布"></p><p><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy6s42ecfzj20k904l0sq.jpg" alt="话题测试结果" title="话题测试结果"></p><h1 id="微博短链接"><a href="# 微博短链接" class="headerlink" title="微博短链接"></a> 微博短链接 </h1><p> 微博短链接是微博官方提供的网址压缩功能产生的一种只包含少量字符的短网址，例如：<a href="http://finance.sina.com.cn" target="_blank" rel="noopener">http://finance.sina.com.cn</a> ，压缩后为：<a href="http://t.cn/RnM1Uti" target="_blank" rel="noopener">http://t.cn/RnM1Uti</a> 。这样的话，发微博时链接占用更少的字符长度。如果发微博时，内容中带了链接，例如视频地址、淘宝店地址，会被自动压缩为短链接。微博短链接可以直接在浏览器中访问，会被微博的网址解析服务器转换为原来的正常链接再访问。</p><p>如果在微博内容中抽取短链接，使用正则表达式（我这里只是抽取 t.cn 域名的，6-8 个字母、数字）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https&#123;0,1&#125;://t.cn/[A-Z0-9a-z]&#123;6,8&#125;[/]&#123;0,1&#125;#</span></span><br></pre></td></tr></table></figure><p></p><p>参考：<br>微博开放平台说明：<a href="http://open.weibo.com/wiki/2/short_url/shorten" target="_blank" rel="noopener">http://open.weibo.com/wiki/2/short_url/shorten</a> ；<br>免费在线短链接转换工具：<a href="http://dwz.wailian.work" target="_blank" rel="noopener">http://dwz.wailian.work</a> 。</p><h1 id="网址长链接"><a href="# 网址长链接" class="headerlink" title="网址长链接"></a>网址长链接 </h1><p> 网址长链接也就是普通的网址，有多种可能性。</p><p>如果在微博内容中抽取网址长链接，使用正则表达式（我这里只考虑 http、https、ftp、file 协议）：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(https?|ftp|file)://[-A-Za-z0-9+&amp;@<span class="comment">#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|]</span></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;在分析微博内容时，常常需要进行特殊内容去除与抽取，例如抽取微博话题、微博昵称、微博表情、微博短链接、网址长链接等等。本文依据实际使用情况，记录下了与微博内容分析相关的正则表达式，以便查用。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="正则表达式" scheme="https://www.playpi.org/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="微博内容" scheme="https://www.playpi.org/tags/%E5%BE%AE%E5%8D%9A%E5%86%85%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>Win10 默认程序设置无效</title>
    <link href="https://www.playpi.org/2018120901.html"/>
    <id>https://www.playpi.org/2018120901.html</id>
    <published>2018-12-09T09:21:14.000Z</published>
    <updated>2018-12-09T09:21:14.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>装了 Windows 10 系统（教育版本），用了将近 3 个月了，最近发现一个诡异的现象，我的默认程序设置每次都只是设置后生效一段时间，例如视频播放器、音乐播放器，我分别设置成了迅雷看看、网易云音乐，用了半天之后，发现又变成了 Window 10 系统自带的视频播放器。这个现象也不是重启之后才出现的，而是平时用着用着就会出现，很莫名其妙。后来查阅资料发现这是一个普遍的现象，这个问题的根本原因是 Windows 10 自带的 bug，通常导致这个 bug 出现的原因是开启了系统的自动更新。</p><a id="more"></a><h1 id="现象"><a href="# 现象" class="headerlink" title="现象"></a>现象 </h1><p> 在 Windows 10 系统（没有打对应补丁的）中，如果开启了系统自动更新，就会触发相应的 bug：默认程序会被系统更改回系统自带的程序，例如视频播放器、音乐播放器等等。这个问题的原因用官方标识来指定就是由于 <strong>KB3135173</strong> 所致，同时这个 bug 已经有对应的补丁了。</p><p>按照系统设置，把某些默认程序改为自己需要的，我这里把视频播放器改为迅雷影音，设置特定格式的文件（.mkv，.mp4 等等）使用迅雷影音打开。</p><p>在桌面右下角打开 <strong>所有设置 </strong>选项 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0n2j57csj20bq0ahmz4.jpg" alt="所有设置" title="所有设置"></p><p> 在 Windows 设置中，选择 <strong>应用 </strong>选项 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0nlh83ifj20xc0pwdgf.jpg" alt="选择应用" title="选择应用"></p><p> 选择默认应用，设置视频播放器为 <strong>迅雷影音 </strong><br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0nnjkzdcj20xc0pw445.jpg" alt="设置视频播放器为迅雷影音" title="设置视频播放器为迅雷影音"></p><p> 上述的设置步骤实际上还不够，因为视频类型有很多种，还需要进一步指定每种类型的默认播放器，在默认应用下方有一个 <strong>按文件类型指定默认应用 </strong>选项 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0nqc3hdtj20xc0pw43w.jpg" alt="按文件类型指定默认应用" title="按文件类型指定默认应用"></p><p> 我这里特别关注 <strong>.mkv</strong>、<strong>.mp4</strong> 这 2 种格式的文件，默认应用设置为 <strong>迅雷影音 </strong><br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0nusxmrxj20md0pw0tu.jpg" alt="单独设置 2 种文件类型" title="单独设置 2 种文件类型"></p><p> 上述内容设置完成，就可以使用了，但是用不了多久，系统时不时就弹出提示框，通知默认程序重置，然后又被设置为系统内置的应用了 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0mr10t67j20bh0h977t.jpg" alt="弹出提示框" title="弹出提示框"></p><h1 id="解决方案"><a href="# 解决方案" class="headerlink" title="解决方案"></a> 解决方案 </h1><h2 id="不推荐方案"><a href="# 不推荐方案" class="headerlink" title="不推荐方案"></a> 不推荐方案 </h2><p> 更改注册表、使用命令行卸载系统默认程序，这些方案是可行的，但是对于普通用户来说太麻烦了一点，根本不懂得如何操作，而且解决方法太粗暴了，当然喜欢折腾的人是可以选择的。</p><p>以下给出几个命令行示例（需要在管理员模式下执行，打开 Windows PowerShell 的时候选择有管理员的那个）：</p><p>卸载 “电影和电视” 应用（星号表示通配符，下同）<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-appxpackage *zunevideo* | remove-appxpackage</span><br></pre></td></tr></table></figure><p></p><p>卸载 “Groove 音乐” 应用 <br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-appxpackage *zunemusic* | remove-appxpackage</span><br></pre></td></tr></table></figure><p></p><p> 卸载 “照片” 应用 <br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get-appxpackage *photos* | remove-appxpackage</span><br></pre></td></tr></table></figure><p></p><p> 如果还想恢复已经卸载的系统自带应用，可以使用以下命令（重装所有系统内置的应用）<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-AppxPacKage -allusers | foreach &#123;Add-AppxPacKage -register <span class="string">"<span class="variable">$($_.InstallLocation)</span>appxmanifest.xml"</span> -DisableDevelopmentMode&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="推荐直接打补丁（更新系统）"><a href="# 推荐直接打补丁（更新系统）" class="headerlink" title="推荐直接打补丁（更新系统）"></a>推荐直接打补丁（更新系统）</h2><p>这个方法很简单，容易操作，直接在系统更新里面更新即可，确保要能更新到 <strong>KB3135173</strong> 这个补丁才行（或者更高版本的补丁）。</p><p>我这里是已经更新完成的，等待重启，补丁标识是 <strong>KB4469342</strong>。<br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fy0n75u4o3j20xc0pw442.jpg" alt="系统更新" title="系统更新"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;装了 Windows 10 系统（教育版本），用了将近 3 个月了，最近发现一个诡异的现象，我的默认程序设置每次都只是设置后生效一段时间，例如视频播放器、音乐播放器，我分别设置成了迅雷看看、网易云音乐，用了半天之后，发现又变成了 Window 10 系统自带的视频播放器。这个现象也不是重启之后才出现的，而是平时用着用着就会出现，很莫名其妙。后来查阅资料发现这是一个普遍的现象，这个问题的根本原因是 Windows 10 自带的 bug，通常导致这个 bug 出现的原因是开启了系统的自动更新。&lt;/p&gt;
    
    </summary>
    
      <category term="知识改变生活" scheme="https://www.playpi.org/categories/knowledge-for-life/"/>
    
    
      <category term="Win10" scheme="https://www.playpi.org/tags/Win10/"/>
    
      <category term="默认程序设置" scheme="https://www.playpi.org/tags/%E9%BB%98%E8%AE%A4%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Spark on Yarn 查看日志</title>
    <link href="https://www.playpi.org/2018120702.html"/>
    <id>https://www.playpi.org/2018120702.html</id>
    <published>2018-12-06T18:06:20.000Z</published>
    <updated>2018-12-06T18:06:20.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p> 一直一来都是直接在 Yarn 的 UI 界面上面查看 Spark 任务的日志的，感觉看少量的内容还勉强可以，但是如果内容很多，浏览器就没法看了，更没法分析。本文讲述如何使用 Yarn 自带的命令在终端查看 Spark 任务的日志，也可以拷贝出日志文件，便于分析。</p><a id="more"></a><p>1、查看某个 Spark 任务的日志，使用 logs 入口：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn logs -applicationId application_1542870632001_26426</span><br></pre></td></tr></table></figure><p></p><p> 如果日志非常多，直接看会导致刷屏，看不到有用的信息，所以可以重定向到文件中，再查看文件：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn logs -applicationId application_1542870632001_26426 &gt; ./application.log</span><br></pre></td></tr></table></figure><p></p><p>2、查看某个 Spark 任务的状态，使用 application 入口：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn application -status application_1542870632001_26426</span><br></pre></td></tr></table></figure><p></p><p> 同时也可以看到队列、任务类型、日志链接等详细信息 <br><img src="https://ws1.sinaimg.cn/large/b7f2e3a3gy1fxxloh9spej20uo0auaas.jpg" alt="查看状态" title="查看状态"></p><p>3、kill 掉某个 Spark 任务，有时候是直接在 Driver 端 kill 掉进程，然后 Yarn 的 Spark 任务也会随之失败，但是这种做法是不妥的。其实 kill 掉 Spark 任务有自己的命令：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn application -<span class="built_in">kill</span> application_1542870632001_26426</span><br></pre></td></tr></table></figure><p></p><p>4、需要注意的是，步骤 1 中去查看日志，要确保当前 HADOOP_USER_NAME 用户是提交 Spark 任务的用户，否则是看不到日志的，因为日志是放在 HDFS 对应的目录中的，其中路径中会有用户名。此外，步骤 1 中的日志要等 Spark 任务运行完了才能看到，否则日志文件不存在（还没收集到 HDFS 中）。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;一直一来都是直接在 Yarn 的 UI 界面上面查看 Spark 任务的日志的，感觉看少量的内容还勉强可以，但是如果内容很多，浏览器就没法看了，更没法分析。本文讲述如何使用 Yarn 自带的命令在终端查看 Spark 任务的日志，也可以拷贝出日志文件，便于分析。&lt;/p&gt;
    
    </summary>
    
      <category term="基础技术知识" scheme="https://www.playpi.org/categories/basic-technical-knowledge/"/>
    
    
      <category term="Spark" scheme="https://www.playpi.org/tags/Spark/"/>
    
      <category term="Yarn" scheme="https://www.playpi.org/tags/Yarn/"/>
    
      <category term="日志查看" scheme="https://www.playpi.org/tags/%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B/"/>
    
  </entry>
  
  <entry>
    <title>煮鸡蛋做法总结</title>
    <link href="https://www.playpi.org/2018120301.html"/>
    <id>https://www.playpi.org/2018120301.html</id>
    <published>2018-12-02T18:30:45.000Z</published>
    <updated>2018-12-02T18:30:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --><p>本文记录水煮鸡蛋的做法总结。</p><a id="more"></a><h1 id="介绍"><a href="# 介绍" class="headerlink" title="介绍"></a>介绍 </h1><p> 水煮鸡蛋是最常见的吃法之一，做法非常简单，直接将鸡蛋放入开水中煮熟即可。煮熟的鸡蛋营养丰富，水煮鸡蛋的营养可以 100% 被保留，是所有的鸡蛋做法中营养被保留的最好的一种。建议每天食用 1-2 个，因为过量的食用可能会导致营养不良，同时鸡蛋的营养并没有被身体吸收，相当于浪费了。</p><p>在生活当中，大家几乎每天早上都会吃煮鸡蛋，或者茶叶蛋，但是有一些人卖的煮鸡蛋不算成功的煮鸡蛋，因为剥皮的时候发现不好剥，蛋壳与蛋白紧紧粘在一起，吃起来可麻烦了，这是因为煮鸡蛋的做法错误，遗漏了重要的步骤。</p><h1 id="做法步骤"><a href="# 做法步骤" class="headerlink" title="做法步骤"></a>做法步骤 </h1><p>1、简单地清洗一下鸡蛋，因为鸡蛋的表面可能会有一些茅草、粪便之类的污垢，这是因为鸡蛋必须是原生的，存储、运输、销售过程都不能清洗，如果非要清洗，水会破坏表面的保护膜，放不了两天鸡蛋就坏了；</p><p>2、放在冷水中浸泡一会儿，1-2 分钟，这样做的目的是防止沸水煮的时候蛋壳破裂；</p><p>3、放入锅中，水的高度稍微没过鸡蛋，使用中火煮开水，不要使用大火，大火煮的速度太快，鸡蛋容易裂开，另外中火使水沸腾的时间会长一些，预热了鸡蛋，味道更香；</p><p>4、水沸腾后，改为小火，煮 7-8 分钟（如果继续使用中火，5 分钟左右即可）；</p><p>5、如果需要溏心蛋（蛋清凝固，蛋黄成稠液状，软嫩滑润），煮 5 分钟即可；</p><p>6、煮熟后不要立即捞出，等 1-2 分钟，然后才捞出，切记此时需要放入冷水中，浸泡 1-3 分钟，这一步骤的目的是保证鸡蛋容易剥开，避免蛋白和蛋壳粘在一起。</p><h1 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a> 注意事项</h1><p>1、煮鸡蛋前最好放入冷水中浸泡 1-2 分钟，防止煮的过程开裂；</p><p>2、注意控制火力和时间，鸡蛋不能煮太久，超过 10 分钟会有化学反应，导致营养流失；</p><p>3、煮熟后不要立即捞出，捞出后也要放在冷水中浸泡，防止蛋白和蛋壳粘在一起；</p><p>4、每天不要吃太多，1-2 个就够了；</p><p>5、如果想要保持蛋黄在中间，煮鸡蛋的过程中要适当搅拌让鸡蛋旋转。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Feb 15 2019 22:56:50 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;本文记录水煮鸡蛋的做法总结。&lt;/p&gt;
    
    </summary>
    
      <category term="菜谱" scheme="https://www.playpi.org/categories/cookbook/"/>
    
    
      <category term="煮鸡蛋" scheme="https://www.playpi.org/tags/%E7%85%AE%E9%B8%A1%E8%9B%8B/"/>
    
  </entry>
  
</feed>
